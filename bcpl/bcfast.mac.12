;<BCPL>BCFAST.MAC;12    10-OCT-74 14:01:09    EDIT BY JOHNSON
; CORRECTED  SFPTR  (GL47)  TO RETURN 0 ON SUCCESS.
;<WOLF>BCFAST.MAC;17    12-JUN-73 15:17:06	EDIT BY ROVNER
;  FIXED 1 BUG IN ACCALL

	TITLE BCFAST
; BCPL HAND CODED SUBROUTINES
;RE-ENTRANT VERSIONS: JJW, 5/29/73

SEARCH STENEX
MLON



S=16	; THE BCPL STACK POINTER
R=1	;REGISTER FOR JSP AND FCN RETURN
P=17	;REGISTER FOR STACK FOR ACCALL

A=4
B=5
C=6
D=7



EXTERN	GL267,GL270,GL272,GL273

OPDEF SAV[MOVEM R,0(S)]	; SAVE THE RETURN ADDRESS IN THE STACK
OPDEF RET[JRST 2,@0(S)]	;BCPL RETURN
DEFINE ARG(N) <1+<N>(S)>	;PTR TO ARGUMENT
				;ARG 0 = 1(S) = NUMBER OF ARGS
				;ARG 1 = 2(S) = 1ST ARG, ETC.


SUBTTL ACCALL(LV-SUBR,AC-IN,AC-OUT)
;RE-ENTRANT VERSION OF ACCALL
GL3:	JRST .+1
	SAV
	MOVEI	17,10020(16)
	CAMLE	17,GL272
	JSP	1,@GL273
	MOVEM S,ARG 4		;SAVE STACK PTR
	MOVEM	17,ARG 5	;SAVE 17
	SETZM ARG 6		;RESULT=0 IF ILLEGAL
	MOVE B,ARG 0		;# OF ARGS TO ACCALL
	JUMPLE B,ACC.X		;ILLEGAL
	CAIL B,4
	MOVEI B,3		;MAX OF 3 ARGS
	JRST .(B)		;BRANCH ON NUMBER OF ARGS
	JRST ACC.1
	JRST ACC.2
	JRST ACC.3

ACC.1:	SETZM ARG 3		;FLAG FOR NO AC INIT OR SAVE
	JRST ACC.3

ACC.2:	MOVE A,ARG 2		;SAME AC VECTOR FOR IN AND OUT
	MOVEM A,ARG 3
ACC.3:	MOVEI A,5		;SET UP TO COUNT # OF SKIPS
	MOVEM A,ARG 6
	HRRZS ARG 1		;MAKE SURE NO GARBAGE IN LH ARG 1
	SETZM	GL270	;MARK SAFE17BOOL FALSE
	MOVEM	P,GL267	;STORE A SAFE VALUE FOR 17
	HRRZI P,ARG 7		;SET PUSHDOWNPTR TO ARG 7
	HRLI P,-10000		;LH P = LPDL LENGTH = ARBITRARY HERE
	SKIPN ARG 3
	JRST ACC.4		;NO AC INIT
;AM ABOUT TO CLOBBER S. HOWEVER, CAN REFERENCE STACK VIA P:
DEFINE ARGP(N) <-7+<N>(P)>
	HRLZ 16,ARG 2		;LOAD AC 0-16 FROM BLOCK POINTED
	BLT 16,16		; TO BY ARG 2
ACC.4:	PUSHJ P,@ARGP 1		;PUSHJ TO THE SUBROUTINE
	SOS ARGP 6		;COUNT SKIPS
	SOS ARGP 6
	SOS ARGP 6
	SOS ARGP 6
	SKIPN ARGP 3		;CHECK ARG 3 AGAIN
	JRST ACC.X		;NO AC RETURN
	MOVEM 15,(P)		;TEMP SAVE AC'S 15 AND 16
	MOVEM 16,1(P)
	HRRZ 16,ARGP 3		;AC16 _ 0,,ARG 3
	MOVE 15,16
	BLT 16,14(15)		;RETURN AC'S 0 - 14
	MOVE 16,(P)
	MOVEM 16,15(15)		;RETURN AC'S 15 AND 16
	MOVE 16,1(P)
	MOVEM 16,16(15)
ACC.X:	MOVE S,ARGP 4		;RESTORE S AND 17
	MOVE	17,ARG 5
	SETOM	GL270	;17 IS AGAIN SAFE
	MOVE R,ARG 6		;RETURN NSKIPS
	RET

SUBTTL JSYS(N,AC-IN,AC-OUT)
;RE-ENTRANT VERSION OF JSYS CALLER, REQUIRED TO ALLOW JSYS
; TO BE CALLED FROM A PSEUDO-INTERRUPT PROCEDURE.
;THIS VERSION DOES NOT SAVE ENVIRONMENT AC'S (AS THE FORMER ONE DID,
; FOR SOME REASON).
;RETURNED VALUE = NUMBER OF SKIPS = 0(ERROR), 1, 2, OR 3.
;ARG 1 = JSYS NUMBER
;ARG 2 = PTR TO IN-AC'S
;ARG 3 = PTR TO OUT-AC'S

GL0:	JRST	.+1
	SAV
	MOVEI	17,6(16)
	CAMLE	17,GL272
	JSP	1,@GL273
	SETZ	11,		;RESULT = 0 IF ILLEGAL
	MOVE	1,ARG 0		;# ARGS
	JUMPLE	1,DJ.X		;ILLEGAL
	CAIL	1,4
	MOVEI	1,3		;MAX. # OF ARGS = 3
	JRST	.(1)		;BRANCH ON # OF ARGS
	JRST	DJ.1
	JRST	DJ.2
	JRST	DJ.3

DJ.1:	SETZM	ARG 3		;FLAG FOR NO AC INIT OR SAVE
	JRST	DJ.3

DJ.2:	MOVE	1,ARG 2		;SAME VECTOR FOR AC'S IN AND OUT
	MOVEM	1,ARG 3
DJ.3:	MOVE	1,ARG 1		;JSYS NUMBER
	CAILE	1,0
	CAIL	1,1000
	JRST	DJ.X		;ILLEGAL JSYS NUMBER
	HRLI	1,(JSYS)	;BUILD THE JSYS AND LEAVE IT IN ARG 1
	MOVEM	1,ARG 1
	SKIPN	ARG 3		;PRELOAD AC'S?
	JRST	DJ.4		;NO
	HRLZ	0,ARG 2
	AOBJN	0,.+1		;0 _ 1+INACPTR,,1
	BLT	0,10		;LOAD AC'S 1-10 FROM INVEC|1 - INVEC|10
DJ.4:	MOVEI	11,3
	XCT	ARG 1		;EXECUTE THE JSYS
	SOJ	11,		;CATCH THE SKIPS (MAX OF 3)
	SOJ	11,
	EXCH	11,ARG 3	;SAVE NSKIPS.  RETURN RESULT AC'S?
	JUMPE	11,DJ.X		;NOPE
	HRRZ	0,11
	AOBJN	0,.+1		;0 _ 1,,1+OUTACPTR
	BLT	0,10(11)	;STORE AC'S 1-10 IN OUTVEC|1 - OUTVEC|10
DJ.X:	MOVE	R,ARG 3		;RETURN NSKIPS
	RET
SUBTTL UTILITY ROUTINES (POINT,LDB,DPB,ILDB,IDPB,IBP,LOCK)

GL12:	JRST	.+1
	SAV
	MOVEI	17,5(16)
	CAMLE	17,GL272
	JSP	1,@GL273
; POINT (SIZE,LOC,BIT)
	MOVE	A,ARG 0
	SETZ	R,
	JUMPLE	A,G.RET
	CAIG	A,2
	SETOM	ARG 3	;NOT SPEC'D, USE -1
	CAIG	A,1
	SETZM	ARG 2	;NO LOC, USE 0
;CONSTRUCT BYTE PTR
	HRRZ	R,ARG 2	;LOC
	MOVE	A,ARG 1	;BYTE SIZE
	DPB	A,[POINT 6,R,11]
	MOVN	A,ARG 3	;BIT POSITION
	ADDI	A,^D35
;A= 35 - BIT
	CAIL	A,0
	CAILE	A,^D36	;A IS # BITS TO RIGHT OF BYTE
	SETZB	A,R		;RET 0 IF ERROR
	DPB	A,[POINT 6,R,5]
G.RET:	RET

GL14:	JRST	.+1
	SAV
;DPB(BYTE,PTR)
	MOVE	A,ARG 0
	CAIGE	A,2
	RET
	MOVE	A,ARG 1
	SKIPE	B,ARG 2
	DPB	A,B	;IF PTR NOT 0
	RET

GL16:	JRST	.+1
	SAV
;IDPB(BYTE, lv PTR)
	MOVE	A,ARG 0
	CAIGE	A,2
	RET
	MOVE	A,ARG 1
	MOVE	B,ARG 2
	SKIPE	0(B)
	IDPB	A,0(B)
	RET

GL13:	JRST	.+1
	SAV
;LDB(PTR)
	SETZ	R,
	SKIPG	ARG 0
	RET
	SKIPE	A,ARG 1
	LDB	R,A
	RET

GL15:	JRST	.+1
	SAV
;ILDB(lv PTR)
	SETZ	R,
	SKIPG	ARG 0
	RET
	MOVE	A,ARG 1
	SKIPE	0(A)
	ILDB	R,0(A)
	RET

GL17:	JRST	.+1
	SAV
;IBP(lv PTR)
	SETZ	R,
	SKIPG	ARG 0
	RET
	MOVE	A,ARG 1
	SKIPE	0(A)
	IBP	0(A)
	MOVE	R,0(A)
	RET

GL20:	JRST	.+1
	SAV
;LOCK(lv LOCKWORD)
	SETZ	R,
	SKIPG	ARG 0
	RET
	MOVE	A,ARG 1
	AOSE	0(A)
	SETO	R,	;TRUE
	RET

; NUMBARGS()
GL300:	JRST	.+1
	SAV
	HRRZ	1,@0(S)
	MOVN	1,1
	ADD	1,S
	HRRZ	1,1(1)
	RET
 SUBTTL BYTE IN/OUT ROUTINES (BIN, PBIN, BOUT, PBOUT)

BINGLB=GL40
EOFLG=GL21
INPT=GL10
OUTPT=GL11

GL40:	JRST	.+1
	SAV
	MOVEI	17,10(16)
	CAMLE	17,GL272
	JSP	1,@GL273
; BIN(J)
BNENT:	SKIPN	ARG 1
	JRST	BINEND
	SKIPG	1,ARG 1
	JRST	FNBIN
	BIN
	SKIPN	1,2
	JRST	EOFLK
BINRET:	SETZM	EOFLG
	RET

EOFLK:	MOVE	3,1
	MOVE	1,ARG 1
	GTSTS
	MOVE	1,3
	AND	2,[1400,,0]
	JUMPE	2,BINRET
BINEND:	SETOM	EOFLG
	MOVEI	1,777
	RET

FNBIN:	HLR	2,1
	ANDI	2,777000
	CAIE	2,777000
	JRST	BINEND
	HRRES	1
	MOVNS	1
	HRLI	1,(JSP 1,0)
	MOVEM	1,ARG 2		;BUILD A JSP 1,SUBR IN ARG 2
	MOVEI	1,2
	MOVEM	1,ARG 3
	HLR	1,ARG 1
	ANDI	1,777
	MOVEM	1,ARG 4
	SETZM	ARG 5
	ADDI	S,3
	XCT ARG <2-3>		;EXECUTE THE JSP 1,SUBR
	SUBI	S,3
	RET

GL36:	JRST	.+1
	SAV
	MOVEI	17,10(16)
	CAMLE	17,GL272
	JSP	1,@GL273
;PBIN()
	MOVE	1,INPT
	MOVEM	1,ARG 1
	JRST	BNENT

GL31:	JRST	.+1
	SAV
	MOVEI	17,10(16)
	CAMLE	17,GL272
	JSP	1,@GL273
;READCH(I,L)
	MOVE	1,ARG 1
	MOVEM	1,ARG 5
	MOVEI	1,1
	MOVEM	1,ARG 4
	ADDI	S,4
	JSP	1,BINGLB	;BIN
	SUBI	S,4
	MOVEM	1,@ARG 2
	RET

GL41:	JRST	.+1
	SAV
	MOVEI	17,10(16)
	CAMLE	17,GL272
	JSP	1,@GL273
; BOUT(JFN,CH)
BOTENT:	SKIPN	ARG 1
	RET
	SKIPG	ARG 1
	JRST	BOUTFN
	HRRE	1,ARG 1
	MOVE	2,ARG 2
	BOUT
	RET

BOUTFN:	HLR	1,ARG 1
	ANDI	1,777000
	CAIE	1,776000
	RET
	MOVE	1,ARG 1
	HRRES	1
	MOVNS	1
	HRLI	1,(JSP 1,0)
	MOVEM	1,ARG 3		;BUILD A JSP 1,SUBR IN ARG 3
	MOVEI	1,2
	MOVEM	1,ARG 4
	HLR	1,ARG 1
	ANDI	1,777
	MOVEM	1,ARG 5
	MOVE	1,ARG 2
	MOVEM	1,ARG 6
	ADDI	S,4
	XCT	ARG <3-4>	;EXECUTE THE JSP 1,SUBR IN ARG 3
	SUBI	S,4
	RET

GL37:	JRST	.+1
	SAV
	MOVEI	17,10(16)
	CAMLE	17,GL272
	JSP	1,@GL273
; PBOUT(BYTE)
	MOVE	1,ARG 1
	MOVEM	1,ARG 2
	MOVE	1,OUTPT
	MOVEM	1,ARG 1
	JRST	BOTENT

GL32:	JRST	.+1
	SAV
	MOVEI	17,10(16)
	CAMLE	17,GL272
	JSP	1,@GL273
; WRITECH(JFN,CH) OR WRITECH(CH)
	MOVE	2,ARG 0
	CAIE	2,1
	JRST	BOTENT
	AOS	ARG 0
	MOVE	2,ARG 1
	MOVEM	2,ARG 2
	MOVE	2,OUTPT
	MOVEM	2,ARG 1
	JRST	BOTENT
 SUBTTL  FILE-MANIPULATION SUBROUTINES (RFPTR, SFPTR)


GL4:	JRST	.+1
	SAV
; RFPTR(STREAM)
	MOVE	1,ARG 1
	RFPTR
	 JRST	GL4A
	MOVE	1,2
	RET
GL4A:	MOVN	1,1
	RET

GL47:	JRST	.+1
	SAV
; SFPTR(STREAM,BYTE PTR)
	MOVE	1,ARG 1
	MOVE	2,ARG 2
	SFPTR
	 JRST	GL47A
	SETZ	1,
	RET
GL47A:	MOVN	1,1
	RET
 SUBTTL  FORTRAN-CALLING ROUTINES (FARG, FCALL)

GL46:	JRST	.+1
	SAV
; FARG(TYPE,LV)
	HRLZ	R,ARG 1
	LSH	R,5
	HRR	R,ARG 2
	RET

GL22:	JRST	.+1
	SAV
; FCALL(LV-F4SUBR,ARGVEC,LV-AC1)
	HRRZ 1,ARG 1
	HRLI 1,(JSA 16,0)
	MOVEM 1,ARG 4	;SET UP FORTRAN CALLING SEQUENCE AT ARG 4
	MOVEI 1,ARG 4	;AC1 POINTS TO LOC FOR 1ST FORTRAN ARG -1
	MOVE 2,ARG 2	;AC2 POINTS TO VECTOR OF NARGS, ARG1, ARG2,...
	HRLI 1,3	;AC1 AND AC2 GET INDEXED BY AC3
	HRLI 2,3
	MOVEI 3,1
FLOOP:	CAMLE 3,0(2)	;END OF LIST OF ARGS?
	JRST ENDFA	;YEP
	MOVS 4,@2	;NO - PICK UP NEXT ARG
	ADDI 4,(JUMP)
	MOVSM 4,@1
	AOJA 3,FLOOP

ENDFA:	MOVE 4,[JRST FRTRN]	;END THE ARG LIST WITH A JUMP BACK HERE
	MOVEM 4,@1
	JRST ARG 4	;JUMP TO THE FORTRAN CALLING SEQ. IN THE STACK

FRTRN:	MOVE	2,1	;FORTRAN CALL RETURNS HERE
	MOVE	1,0
	MOVE	3,ARG 0	;3_# ARGS TO FCALL
	CAIN	3,2
	RET
	MOVEM	2,@ARG 3
	RET

; THE FOLLOWING THREE ROUTINES ARE FLOATING POINT SERVICE ROUTINES:
;	FLOAT(X) MAKES A FPT NUMBER FROM AN INTEGER
GL53:	JRST	.+1
	SAV
	MOVM	0,ARG 1
	HLRZ	1,0
	FSC	1,255
	HRLI	0,0
	FSC	0,233
	FADR	1,0
	SKIPGE	ARG 1
	MOVNS	1,1
	RET

;	FIX(X) MAKES AN INTEGER FROM A FPT NUMBER (TRUNCATED)
GL54:	JRST	.+1
	SAV
	MOVM	1,ARG 1
	MULI	1,400
	EXCH	1,2
	ASH	1,-243(2)
	SKIPGE	ARG 1
	MOVNS	1,1
	RET

;	FIXR(X) MAKES AN INTEGER FROM A FPT NUMBER (ROUNDED)
GL55:	JRST	.+1
	SAV
	MOVM	1,ARG 1
	MULI	1,400
	EXCH	1,2
	LSHC	1,-243(2)
	CAIGE	2,0
	AOJ	1,
	SKIPGE	ARG 1
	MOVNS	1,1
	RET

;ABSOLUTE VALUE FUNCTION - SAME ONE WORKS FOR INTEGER AND FLOATING POINT
; VALUE_ABS(NUMBER)
GL56:	JRST .+1
	SAV
	MOVM R,ARG 1
	RET


; BLT(FROM,TO,LAST,SAFE)
	DEFINE NARGS < ARG 0 >
	DEFINE FROM  < ARG 1 >
	DEFINE TO    < ARG 2 >
	DEFINE LAST  < ARG 3 >
GL52:	JRST	.+1
	SAV
	MOVE A,NARGS
	CAIN A,3	; SAFE ARG OMITTED?
	JRST FBLT	; YES, DO PLAIN BLT
	MOVE A,FROM	; NO, ARE WE BLTING DOWN?
	CAML A,TO
	JRST FBLT	; YES, PLAIN BLT
	ADD A,LAST	; NO- BLT'ING UP - DOES IT OVERLAP?

	SUB A,TO
	CAML A,TO
	JRST RBLT	; YES. DO FUNNY REVERSE BLT
FBLT:	HRL A,FROM	; NO OVERLAP. SAFE TO DO PLAIN BLT
	HRR A,TO
	BLT A,@LAST
	RET

; DATA OVERLAPS, BUT MUST BE PRESERVED. DO REVERSE BLT

RBLT:	MOVE A,LAST
	MOVE B,FROM
	SUB B,TO	; NUMBER OF WORDS-1
	ADDI B,(A)	; LAST SOURCE WORD
	HRRO B,B

LP:	POP B,(A)
	CAMLE A,TO	; WRITTEN INTO FIRST TARGET WORD YET?
	SOJA A,LP
	RET
LIT

GL10:	100	;INPUT
GL11:	101	;OUTPUT
GL21:	0	;EofFlg

ENTRY	GL0,GL3,GL10,GL11,GL12,GL13,GL14,GL15,GL16
ENTRY	GL17,GL20,GL21,GL22,GL31,GL32,GL36,GL37,GL40,GL41,GL46
ENTRY	GL4,GL47,GL52,GL53,GL54,GL55,GL56,GL300
	END
