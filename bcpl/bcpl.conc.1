
		HEADBCPL.BCP;6


   1;	// Declarations for the BCPL Compiler, used throughout the Compiler.

   2;	global
   3;	{
   4;	// Jim Miller's statics, in HANDCD

   5;	  jimtbptr:             #502
   6;	  jimbytptr:            #513
   7;	  jimtbl:               #514

   8;	// NLEX2 statics

   9;	  RequestTable:         #515
  10;	  RequireTable:         #523
  11;	  DebugSW:              #525

  12;	// NMAIN2 statics

  13;	  SWupper:              #554
  14;	  SWbits:               #500
  15;	  Reportcount:          #501
  16;	  MONITOR:              #503
  17;	  GetnameV:             #504
  18;	  ConsoleStream:        #561
  19;	  Cautions:             #562
  20;	  GetnameP:             #505
  21;	  ExtDecl:              #506
  22;	  ExtDeclS:             #507
  23;	  StaticN:              #510
  24;	  NextParameter:        #511
  25;	  Ocode:                #512
  26;	  Curline:              #517
  27;	  Curfile:              #520
  28;	  Warns:                #521

  29;	// NMAIN1 routines

  30;	  Abort:                #516
  31;	  Newvec:               #547
  32;	ruppersptr:#557
  33;	suppersptr:#560

  34;	// NMAIN2 routines

  35;	  NextParam:            #522
  36;	  WriteChar:            #524
  37;	  Plist:                #526
  38;	  List1:                #527
  39;	  List2:                #530
  40;	  List3:                #531
  41;	  List4:                #532
  42;	  List5:                #533
  43;	  List6:                #534
  44;	  Wfline:               #550
  45;	  BCPLreport:           #551

  46;	// NMAIN3 routines

  47;	  SymtabInit:           #535
  48;	  SymtabStoreSymbol:    #536
  49;	  SymtabNextN:          #537
  50;	  SymtabStoreEnd:       #540
  51;	  SymtabStoreArgs:      #541
  52;	  SymtabTransEnd:       #542
  53;	  SymtabStoreILC:       #543
  54;	  SymtabStoreCommand:   #544
  55;	  SymtabStoreStack:     #545
  56;	  SymtabFinish:         #546

  57;	// Major routines in CAE, TRN, and CG

  58;	  ConstructTree:        #552    // in CAE0
  59;	  TranslateTree:        #553    // in TRN0
  60;	  Cg:                   #555    // in CG0
  61;	 }

  62;	manifest
  63;	{
  64;	// Selectors for tree node elements
  65;	 H1  :=          0
  66;	  H2  :=          1
  67;	  H3  :=          2
  68;	  H4  :=          3
  69;	  H5  :=          4
  70;	  H6  :=          5             // Selectors for tree nodes.

  71;	  NAMELENGTH  :=  23
  72;	  ExtDeclN  :=    2
  73;	  GetFileMax  :=  16
  74;	  CaseMax  :=     150

  75;	  GlobNMax  :=    #1777	//Maximum allowed global number
  76;	  RequireSize  := 100           // #regs
  77;	  RequestSize  := 20            // #regs
  78;	  ExtDeclT  :=    300 * ExtDeclN
  79;	  GetnameT  :=    2 * GetFileMax - 1
  80;	 }

  81;	structure                       // Option bits.
  82;	{ SW
  83;	  { Symtab bitb
  84;	    Ocode bitb
  85;	    Debug bitb
  86;	    Help bitb
  87;	    Ncs bitb
  88;	    Synrep bitb
  89;	    Pprep bitb
  90;	    SymtabLong bitb
  91;	    Bss bitb
  92;	    MACfil bitb
  93;	   }

  94;	  String                        // BCPL string.
  95;	  { n byte                      // Length in chars.
  96;	    c^511 char
  97;	   }
  98;	 }

  99;	manifest
 100;	{                               // Specification of PDP-10 -- the
 101;	                                //-- machine on which the compiler
 102;	                                //-- runs.
 103;	  Bitsperbyte  :=   9
 104;	  Bytebits  :=      9
 105;	  Bytesperword  :=  4
 106;	  Bitsperword  :=   36
 107;	  StringLength  :=  511
 108;	  StringMaxOb  :=   511
 109;	  Endofstreamch  := #777

 110;	 }


		HEADCAE.BCP;4


 111;	// Declarations for the BCPL Compiler -- LEX and CAE.

 112;	global
 113;	{                               // CAE0 statics
 114;	  ERRORNAME:     #400
 115;	  TRUENODE:      #401
 116;	  FALSENODE:     #402
 117;	  NILNODE:       #403

 118;	// CAE1 routines

 119;	  Readblockbody: #404
 120;	  Rblock:        #405
 121;	  Rnamelist:     #406
 122;	  EqVec:         #410

 123;	// CAE2 routines

 124;	  Rexp:          #411

 125;	// CAE3 routines

 126;	  Rdef:          #412
 127;	  Rcom:          #413
 128;	  Rselect:       #414

 129;	// CAE4 routines

 130;	  Rstruct:       #415
 131;	  Rqualname:     #416
 132;	 }

 133;	get "<xbcpl>headbcpl"           // Declarations for BCPL.
 134;	get "<xbcpl>headlex"            // Communication in LEX and CAE.
 135;	get "<xbcpl>headcaecon"         // Manifests for lexemes and tree
 136;	                                //-- nodes.



		HEADCAECON.BCP;3

 137;	//  Declarations of constants for the BCPL Compiler -- LEX and CAE.

 138;	   //  Declarations for Canonic Symbols and AE-Tree Nodes.
 139;	manifest
 140;	 {
 141;	    GET _ 1; RESERVE _ 2; SYNONYM _ 3; UNRESERVE _ 4; NUMBER _ 16; NAME _ 17; STRINGCONST _ 18
 142;	    CHARCONST _ 19; TRUE _ 20; FALSE _ 21; NIL _ 22; LV _ 23; RV _ 24; NEG _ 25; NOT _ 26; RH _ 27
 143;	    LH _ 28; Q1 _ 29; Q2 _ 30; Q3 _ 31; Q4 _ 32; SIZE _ 33; OFFSET _ 34; FPLUS _ 35; FMINUS _ 36
 144;	    FMULT _ 37; FDIV _ 38; FNEG _ 39; FGR _ 40; FEQ _ 41; FLS _ 42; PLUS _ 43; MINUS _ 44
 145;	    MULT _ 45; DIV _ 46; REM _ 47; LOGAND _ 48; LOGOR _ 49; EQ _ 50; NE _ 51; LS _ 52; LE _ 53
 146;	    GE _ 54; GR _ 55; EQV _ 56; NEQV _ 57; EQUIV _ 58; NEQUIV _ 59; LSHIFT _ 60; RSHIFT _ 61
 147;	    LSCALE _ 62; RSCALE _ 63; VECAP _ 64; RIGHTLUMP _ 65; LEFTLUMP _ 66; COMCOM _ 67; COMMA _ 68
 148;	    COND _ 69; ASS _ 70; UPLUMP _ 71; DOT _ 72; RBRA _ 73; RKET _ 74; TABLE _ 75; LIST _ 76
 149;	    VALOF _ 77; RESULTIS _ 78; REPNAME _ 79; REPVAL _ 80; NUMBARGS _ 81; LEFTSIDE _ 82
 150;	    SELECTON _ 91; STATIC _ 92; EXT _ 93; MANIFEST _ 94; INDEX _ 95; STRUCTURE _ 97; LET _ 98
 151;	    AND _ 99; VALDEF _ 100; CONSTDEF _ 101; FNDEF _ 102; RTDEF _ 103; BE _ 104; VEC _ 105
 152;	    FNAP _ 106; RTAP _ 107; SEMICOLON _ 108; END _ 109; SEQ _ 110; GOTO _ 111; COLON _ 112
 153;	    TEST _ 113; IFSO _ 114; IFNOT _ 115; DO _ 116; OR _ 117; IF _ 118; UNLESS _ 119; UNTIL _ 120
 154;	    WHILE _ 121; REPEAT _ 122; REPEATUNTIL _ 123; REPEATWHILE _ 124; FOR _ 125; TO _ 126; BY _ 127
 155;	    SWITCHON _ 128; BRANCHON _ 129; INTO _ 130; CASE _ 131; CASETO _ 132; DEFAULT _ 133
 156;	    ENDCASE _ 134; LINE _ 135; BREAK _ 136; LOOP _ 137; RETURN _ 138; FINISH _ 139; ABORT _ 140
 157;	    ERROR _ 141; SECTBRA _ 142; SECTKET _ 143; OVERLAY _ 144; BIT _ 145; BITB _ 146; BITN _ 147
 158;	    BYTE _ 148; BYTEN _ 149; CHAR _ 150; FILL _ 151; WORD _ 152; SD _ 153; SDATOM _ 154; REP _ 155
 159;	    GLOBAL_156 ; RNAME_233 ; LHZ_236 ; RHZ_237 ; Q1Z_238 
 160;	   Q2Z_239 ; Q3Z_240 ; Q4Z_241 ; ASCIZCONST_242
 161;	CSIZE_83 ; REQUEST_84 ; REQUIRE_85 ; IFDEBUG_86
 162;	  }


		HEADCG.BCP;8


 163;	// Declarations for the Code Generator of the BCPL Compiler for TENEX.

 164;	get "<xbcpl>headbcpl"
 165;	get "<bcpl>head"
 166;	get "<xbcpl>headtrncon"

 167;	// CG3 routines

 168;	external
 169;	{ WRCH
 170;	    VMINIT
 171;	    WROCT
 172;	    WRPU
 173;	    WRIMP
 174;	    WRLST
 175;	    RLINIT
 176;	    CGPS2
 177;	    WRINT
 178;	    WREXT
 179;	    WRBLK
 180;	 }

 181;	global
 182;	{
 183;	//CG0 statics
 184;	  Report:          #210
 185;	SSP: #211
 186;	  Ch:              #212
 187;	  OutA:            #214
 188;	  OutB:            #215
 189;	  bl1pptr:         #131
 190;	  bl1sptr:         #216
 191;	  bl2pptr:         #223
 192;	  bl2sptr:         #224
 193;	  Block2JFN:       #227
 194;	  flgstk:          #221         // stack to hold info about MACRO
 195;	MaxStack:#226
 196;	                                //-- resprocs...
 197;	                                // whether code has been generated by
 198;	                                //-- the args
 199;	  Arg1:            #132
 200;	  Arg2:            #133
 201;	  ConstV:          #100
 202;	  ConstP:          #101
 203;	  ConstL:          #103
 204;	  Svec:            #104
 205;	  SvecP:           #105
 206;	  SvecT:           #106
 207;	  StatV:           #107
 208;	  StatP:           #110
 209;	  TempV:           #112
 210;	  TempT:           #113
 211;	  P10regV:         #115
 212;	  MAXXRNUMBER:     #117
 213;	  globinfo:        #122
 214;	  Op:              #172
 215;	  Block1JFN:       #174         // JFN for temp file to hold impure
 216;	                                //-- code generated

 217;	// CG3 statics

 218;	  MacroJFN:        #222

 219;	// CG0 routines

 220;	  Readop:          #134
 221;	  ReadNM:          #135
 222;	  ReadL:           #136
 223;	  Initstack:       #116
 224;	Push:#114
 225;	StartStack:#120
 226;	Pop:#121
 227;	Elt:#123

 228;	// CG1 routine

 229;	  Scan:            #125

 230;	// CG2 routines

 231;	  LoadT:           #137
 232;	  NextP10reg:      #141
 233;	  Storein:         #142
 234;	  StoreI:          #143
 235;	  MovetoReg:       #146
 236;	  Lose1:           #151
 237;	  PairP10reg:      #152
 238;	  Stack:           #156
 239;	  MakeNUMSimple:   #163
 240;	  Store:           #165
 241;	  MoveNtoReg:      #175

 242;	// CG3 routines

 243;	  NoteGlobal:      #173
 244;	  WRDATA:          #170
 245;	  CompMAC:         #147
 246;	  WRLAB:           #130
 247;	  WRMAC:           #124

 248;	// CG4 routines

 249;	  CGscale:         #213
 250;	  Outconsts:       #126
 251;	  Outnumbs:        #127
 252;	  CGstring:        #140
 253;	  CGplus:          #153
 254;	  CGsubt:          #154
 255;	  CGrelVal:        #157
 256;	  CGrel:           #160
 257;	  CGshift:         #161
 258;	  CGlogop:         #162
 259;	  CGrv:            #164
 260;	  CGapply:         #166
 261;	  CGswitch:        #167
 262;	  storestring:     #171

 263;	//CG5 routines

 264;	  Addrble:         #144
 265;	  Makeaddrble:     #145
 266;	  Addr:            #150
 267;	  Iszero:          #155
 268;	  CGstindc:        #176
 269;	  CGrvcandrvcn:    #177
 270;	  CGcfgandcfgn:    #200
 271;	  CGspcandslc:     #201

 272;	 }
 273;	manifest                        // OCODE Constants
 274;	{ LOCAL  :=  1001
 275;	  LABEL  :=  1002
 276;	  NUMBER  := 1003
 277;	  Off  :=    2
 278;	 }

 279;	manifest
 280;	{ P10reg  :=   6
 281;	MAXAC := #17
 282;	  StackAC  :=  #16              // AC to use for the working stack
 283;	  RsltAC  :=   1                // AC in which results are passed
 284;	  JSPAC  :=    1                // AC for doing JSP to routines
 285;	  BlockA  :=   0
 286;	  BlockB  :=   1
 287;	  Tempsize  := 5
 288;	 }

 289;	static
 290;	{ V1:   vec 10
 291;	 }                              // Used in calls to Addr

 292;	get "<xbcpl>pdpops"             // Get the opcode definitions


		HEADLEX.BCP;5


 293;	// HEADLEX

 294;	global
 295;	{
 296;	// NLEX2 statics
 297;	 Ch:                #450
 298;	  NLPending:         #461
 299;	  ReadAhead:         #442
 300;	  ExtraSymb:         #446
 301;	  LastItem:          #463
 302;	  SWcontrol:         #466

 303;	// CAE0 statics

 304;	  GetV:              #434
 305;	  GetP:              #435
 306;	  LineV:             #436
 307;	  LineP:             #437
 308;	  B:                 #443
 309;	  WUPFLG:            #444
 310;	  Symb:              #431       // Scalar (in CAE0.B) into which
 311;	                                //-- Nextsymb puts its output.
 312;	  V:                 #432       // Vector (in CAE0.B) into which
 313;	                                //-- Nextsymb puts some data.
 314;	  Chkind:            #451

 315;	//NLEX1 routines
 316;	  Nextsymb:          #430
 317;	  LinePtr:           #460
 318;	  Rch:               #452
 319;	  OpenSource:        #465
 320;	  DoGet:             #441
 321;	  DoControl:         #467
 322;	  DictionaryEntry:   #470


 323;	//CAE0 routines
 324;	  CAEreport:         #433
 325;	 }

 326;	external
 327;	{ JSETUP
 328;	    JRch
 329;	    JRFPTR
 330;	    JNDRD
 331;	 }

 332;	manifest                        // Sizes of various tables.
 333;	{ LineT  :=        120          // Input line for Rch and CAEreport.
 334;	  Vmax  :=         512          // Maximum length string, name, number,
 335;	                                //-- etc.
 336;	  GetT  :=         10           // Maximum nesting depth of "get"
 337;	                                //-- files.
 338;	  BRACKETLABEL  := 20           // Length of the label on a labelled
 339;	                                //-- section bracket.
 340;	  DictOffset  :=   #260000      // start of the hash coded dictionary.
 341;	                                // initially, zeroth word is a relative
 342;	                                //-- ptr to
 343;	                                // next free location. AE-tree grows
 344;	                                //-- down from
 345;	                                // here.

 346;	 }



		HEADLEXCON.BCP;1

 347;	//  BCPL Compiler -- Declarations for the Lexemes for the
 348;	//            Lexical Analyzer.

 349;	manifest   //  Declarations for lexemes.
 350;	 {
 351;	    RNAMECODE_233
 352;	    GET          _  #000000 ,, #001001	//    1   get
 353;	    RESERVE      _  #000000 ,, #775001	//    2   reserve
 354;	    SYNONYM      _  #000000 ,, #774001	//    3   synonym
 355;	    UNRESERVE    _  #000000 ,, #773001	//    4   unreserve
 356;	REQUEST_#000000,,#653001
 357;	REQUIRE_#000000,,#652001
 358;	IFDEBUG_#000000,,#651001
 359;	CSIZE_#000004,,#654001	//83	csize
 360;	    NUMBER       _  #000005 ,, #020001	//   16
 361;	    NAME         _  #000005 ,, #021001	//   17
 362;	    STRINGCONST  _  #000005 ,, #022001	//   18
 363;	    ASCIZCONST	_	#000005,,#362001
 364;	    CHARCONST    _  #000005 ,, #023001	//   19
 365;	    TRUE         _  #000001 ,, #024001	//   20   true
 366;	    FALSE        _  #000001 ,, #025001	//   21   false
 367;	    NIL          _  #000001 ,, #026001	//   22   nil
 368;	    LV           _  #000000 ,, #027001	//   23   lv
 369;	    RV           _  #000004 ,, #030001	//   24   rv
 370;	    NOT          _  #000004 ,, #032001	//   26   not
 371;	    RH           _  #000004 ,, #033001	//   27   rh
 372;	    LH           _  #000004 ,, #034001	//   28   lh
 373;	    Q1           _  #000004 ,, #035001	//   29   q1
 374;	    Q2           _  #000004 ,, #036001	//   30   q2
 375;	    Q3           _  #000004 ,, #037001	//   31   q3
 376;	    Q4           _  #000004 ,, #040001	//   32   q4
 377;	    LHZ           _  #000004 ,, #354001
 378;	    RHZ           _  #000004 ,, #355001
 379;	    Q1Z           _  #000004 ,, #356001
 380;	    Q2Z           _  #000004 ,, #357001
 381;	    Q3Z           _  #000004 ,, #360001
 382;	    Q4Z           _  #000004 ,, #361001
 383;	    SIZE         _  #000004 ,, #041001	//   33   size
 384;	    OFFSET       _  #000004 ,, #735001	//   34   offset
 385;	    FPLUS        _  #000000 ,, #043001	//   35
 386;	    FMINUS       _  #000000 ,, #044001	//   36
 387;	    FMULT        _  #000000 ,, #045001	//   37
 388;	    FDIV         _  #000000 ,, #046001	//   38
 389;	    FGR          _  #000000 ,, #050001	//   40
 390;	    FEQ          _  #000000 ,, #051001	//   41
 391;	    FLS          _  #000000 ,, #052001	//   42
 392;	    PLUS         _  #000000 ,, #053001	//   43
 393;	    MINUS        _  #000000 ,, #054001	//   44
 394;	    MULT         _  #000000 ,, #055001	//   45
 395;	    DIV          _  #000000 ,, #056001	//   46
 396;	    REM          _  #000000 ,, #057001	//   47   rem
 397;	    LOGAND       _  #000000 ,, #060001	//   48   logand
 398;	    LOGOR        _  #000000 ,, #061001	//   49   logor
 399;	    EQ           _  #000000 ,, #062001	//   50   eq
 400;	    NE           _  #000000 ,, #063001	//   51   ne
 401;	    LS           _  #000000 ,, #064001	//   52   ls
 402;	    LE           _  #000000 ,, #065001	//   53   le
 403;	    GE           _  #000000 ,, #066001	//   54   ge
 404;	    GR           _  #000000 ,, #067001	//   55   gr
 405;	    EQV          _  #000000 ,, #070001	//   56   eqv
 406;	    NEQV         _  #000000 ,, #071001	//   57   neqv
 407;	    EQUIV        _  #000000 ,, #072001	//   58
 408;	    NEQUIV       _  #000000 ,, #073001	//   59
 409;	    LSHIFT       _  #000000 ,, #074001	//   60   lshift
 410;	    RSHIFT       _  #000000 ,, #075001	//   61   rshift
 411;	    LSCALE       _  #000000 ,, #701001	//   62   lscale
 412;	    RSCALE       _  #000000 ,, #700001	//   63   rscale
 413;	    VECAP        _  #000000 ,, #100001	//   64
 414;	    RIGHTLUMP    _  #000000 ,, #101001	//   65
 415;	    LEFTLUMP     _  #000000 ,, #102001	//   66
 416;	    COMCOM       _  #000000 ,, #103001	//   67
 417;	    COMMA        _  #000000 ,, #104001	//   68
 418;	    COND         _  #000000 ,, #105001	//   69
 419;	    ASS          _  #000000 ,, #106001	//   70
 420;	    UPLUMP       _  #000000 ,, #107001	//   71
 421;	    DOT          _  #000000 ,, #110001	//   72
 422;	    RBRA         _  #000004 ,, #111001	//   73
 423;	    RKET         _  #000001 ,, #112001	//   74
 424;	    TABLE        _  #000000 ,, #113001	//   75   table
 425;	    LIST         _  #000000 ,, #114001	//   76   list
 426;	    VALOF        _  #000004 ,, #115001	//   77   valof
 427;	    RESULTIS     _  #000010 ,, #116001	//   78   resultis
 428;	    REPNAME      _  #000000 ,, #117001	//   79   repname
 429;	    REPVAL       _  #000000 ,, #120001	//   80   repval
 430;	    NUMBARGS     _  #000005 ,, #656001	//   81   numbargs
 431;	    LEFTSIDE     _  #000005 ,, #655001	//   82   leftside
 432;	    SELECTON     _  #000004 ,, #133001	//   91   selecton
 433;	    STATIC       _  #000004 ,, #134001	//   92   static
 434;	    EXT          _  #000004 ,, #135001	//   93
 435;	    MANIFEST     _  #000004 ,, #136001	//   94   manifest
 436;	    INDEX        _  #000004 ,, #640001	//   95   index
 437;	    STRUCTURE    _  #000004 ,, #141001	//   97   structure
 438;	    LET          _  #000004 ,, #142001	//   98   let
 439;	    AND          _  #000000 ,, #143001	//   99   and
 440;	    BE           _  #000000 ,, #150001	//  104   be
 441;	    VEC          _  #000000 ,, #151001	//  105   vec
 442;	    SEMICOLON    _  #000000 ,, #154001	//  108
 443;	    END          _  #000000 ,, #155001	//  109
 444;	    GOTO         _  #000010 ,, #157001	//  111   goto
 445;	    COLON        _  #000000 ,, #160001	//  112
 446;	    TEST         _  #000010 ,, #161001	//  113   test
 447;	    IFSO         _  #000000 ,, #162001	//  114   ifso
 448;	    IFNOT        _  #000000 ,, #163001	//  115   ifnot
 449;	    DO           _  #000000 ,, #164001	//  116   do
 450;	    OR           _  #000000 ,, #165001	//  117   or
 451;	    IF           _  #000010 ,, #166001	//  118   if
 452;	    UNLESS       _  #000010 ,, #167001	//  119   unless
 453;	    UNTIL        _  #000010 ,, #170001	//  120   until
 454;	    WHILE        _  #000010 ,, #171001	//  121   while
 455;	    REPEAT       _  #000002 ,, #172001	//  122   repeat
 456;	    REPEATUNTIL  _  #000000 ,, #173001	//  123   repeatuntil
 457;	    REPEATWHILE  _  #000000 ,, #174001	//  124   repeatwhile
 458;	    FOR          _  #000010 ,, #175001	//  125   for
 459;	    TO           _  #000000 ,, #176001	//  126   to
 460;	    BY           _  #000000 ,, #177001	//  127   by
 461;	    SWITCHON     _  #000010 ,, #200001	//  128   switchon
 462;	    BRANCHON     _  #000010 ,, #201001	//  129   branchon
 463;	    INTO         _  #000000 ,, #202001	//  130   into
 464;	    CASE         _  #000010 ,, #203001	//  131   case
 465;	    DEFAULT      _  #000010 ,, #205001	//  133   default
 466;	    ENDCASE      _  #000012 ,, #206001	//  134   endcase
 467;	    BREAK        _  #000012 ,, #210001	//  136   break
 468;	    LOOP         _  #000012 ,, #211001	//  137   loop
 469;	    RETURN       _  #000012 ,, #212001	//  138   return
 470;	    FINISH       _  #000012 ,, #213001	//  139   finish
 471;	    ABORT        _  #000012 ,, #563001	//  140   abort
 472;	    ERROR        _  #000005 ,, #562001	//  141   error
 473;	    SECTBRA      _  #000004 ,, #216001	//  142
 474;	    SECTKET      _  #000001 ,, #217001	//  143
 475;	    OVERLAY      _  #000000 ,, #220001	//  144   overlay
 476;	    BIT          _  #000005 ,, #221001	//  145   bit
 477;	    BITB         _  #000005 ,, #222001	//  146   bitb
 478;	    BITN         _  #000005 ,, #223001	//  147   bitn
 479;	    BYTE         _  #000005 ,, #224001	//  148   byte
 480;	    BYTEN        _  #000005 ,, #225001	//  149   byten
 481;	    CHAR         _  #000005 ,, #226001	//  150   char
 482;	    FILL         _  #000005 ,, #227001	//  151   fill
 483;	    WORD         _  #000005 ,, #230001	//  152   word
 484;	  }

 485;	

		HEADSYMB.BCP;2


 486;	// Description of the BCPL Symbol Table.
 487;	// Last modified on Fri 14 Apr 72 1637.39 by   AE.

 488;	manifest
 489;	{ SymbVersion  := 3
 490;	 }                              // Symbol table version id.

 491;	structure
 492;	{ SThead                        // Symbol table header.
 493;	  { Length byte 2               // Pointer to last used register of
 494;	                                //-- this file.
 495;	    Version byte 2              // What sort of symbol table is it?
 496;	    Date word                   // Creation date of the symbol table.
 497;	    FDN byte 2                  // Source file descriptor length.
 498;	    FDB byte 2                  // Source file descriptor base.
 499;	    SDN byte 2                  // Symbol descriptor length.
 500;	    SDB byte 2                  // Symbol descriptor base.
 501;	    NameN byte 2                // Symbol names length.
 502;	    NameB byte 2                // Symbol names base.
 503;	    StructN byte 2              // Structure descriptors length.
 504;	    StructB byte 2              // Structure descriptors base.
 505;	    ComN byte 2                 // Command descriptors length.
 506;	    ComB byte 2                 // Command descriptors base.
 507;	    SlashUSW word               // /U switch was used
 508;	   }

 509;	// Structure definitions for symbol table descriptors.

 510;	  STsd                          // Symbol descriptor, word 1.
 511;	  { Type bit 4                  // The type of symbol.
 512;	    Data bit 7                  // Datum associated with the symbol --
 513;	                                //-- static and small values only.
 514;	    overlay SmallLocal bitn 7
 515;	    Name bit 12                 // Points to BCPL string that is the
 516;	                                //-- symbol name, wrt symbol block.
 517;	    ILCA bit 13                 // Offset in block A where symbol
 518;	                                //-- starts its scope.

 519;	    SType bit 9                 // Variable, routine, function or
 520;	                                //-- label.
 521;	    Args bit 9                  // For function or routine, number of
 522;	                                //-- arguments.
 523;	    bit 5
 524;	    ILCB bit 13                 // Offset in block B where item is
 525;	                                //-- stored.
 526;	   }

 527;	  STcdYYYYc                     // Command descriptor -- start command.
 528;	  { Type bit 1                  // 0, for command descriptor.
 529;	    SFD bit 4                   // Source file descriptor.
 530;	    ILCA bit 13                 // Block A location of the command.
 531;	    Word bit 18                 // Byte # in the source file.
 532;	   }

 533;	  STcdYYYYs                     // Command descriptor -- change stack
 534;	                                //-- offset.
 535;	  { Type bit 1                  // 1, for a CDs
 536;	    bit 4
 537;	    ILCA bit 13                 // Block A location of command.
 538;	    bit 1
 539;	    Offset bit 17               // New stack offset.
 540;	   }
 541;	 }

 542;	manifest                        // Types for symbol descriptors.
 543;	{ STmanifestYYYYbig  := 0       // Manifest constant, value too big.
 544;	  STlocalYYYYbig  :=    1       // Local with large stack offset.
 545;	  STglobalYYYYbig  :=   2       // Global, with offset too big for
 546;	                                //-- field.
 547;	  STstatic  :=          4       // Static.
 548;	  STstructure  :=       5       // Structure.
 549;	  STmanifest  :=        8       // Manifest constant.
 550;	  STlocal  :=           9       // Local with small stack offset.
 551;	  STglobal  :=          10      // Global, small value.
 552;	  STparam  :=           12      // Formal parameter of a function or
 553;	                                //-- routine.
 554;	  STindex  :=           13      // Index register.
 555;	  STsectket  :=         14      // End of a section.
 556;	  STfill  :=            15      // For unused words.

 557;	// Sub-types for static data items.

 558;	  STstaticYYYYvar  :=   0       // Static variable.
 559;	  STstaticYYYYfunction  :=
 560;	                        1       // A static which is a function.
 561;	  STstaticYYYYroutine  :=
 562;	                        2       // A static which is a routine.
 563;	  STstaticYYYYlabel  := 3       // A static which is a label.

 564;	// Types for the command block.

 565;	  STcdYYYYcommand  :=   0       // Command descriptor -- command start.
 566;	  STcdYYYYstack  :=     1       // Command descriptor -- stack change.
 567;	 }

 568;	manifest
 569;	{ STYYYYMaxDatum  :=
 570;	    (1 lshift size STsd.Data) - 1
 571;	                                // Max datum in SD1.Data field.
 572;	  STYYYYSymbHeaderN  :=
 573;	    (size SThead) / Bitsperword // Length of symbol table header, in
 574;	                                //-- words.
 575;	 }



		HEADTRN.BCP;4


 576;	// Declarations for the BCPL Compiler -- Trans.

 577;	get "<XBCPL>headbcpl"           // Compiler declarations.
 578;	get "<XBCPL>headtrncon"         // Manifests for AE-tree nodes and
 579;	                                //-- OCODE items.

 580;	manifest
 581;	{ BlockA  := 0
 582;	  BlockB  := 1
 583;	  IntExt  := 3
 584;	 }

 585;	global
 586;	{ ERRORNAME:        #400        // copy of entry in HEADCAE.BCP

 587;	// TRN0 statics

 588;	  SSP:              #720
 589;	  Dvec:             #610
 590;	  DvecS:            #611
 591;	  DvecE:            #612
 592;	  DvecP:            #613
 593;	  PDRMAXSSP:        #721
 594;	  CURFNM:           #722
 595;	  Casetable:        #616
 596;	  CaseP:            #620
 597;	  ZERONODE:         #621
 598;	  RoutineBody:      #622
 599;	  FunctionBody:     #623
 600;	  ValofBlock:       #624
 601;	  SwitchBlock:      #625
 602;	  RepeatBlock:      #626
 603;	  Breaklabel:       #627
 604;	  Resultlabel:      #630
 605;	  Defaultlabel:     #631
 606;	  Endcaselabel:     #632
 607;	  Looplabel:        #633
 608;	  VecSSP:           #634

 609;	// TRN6 statics

 610;	  Constant:         #635

 611;	// TRN7 statics

 612;	  BlockIn:          #636
 613;	  BlockWanted:      #637

 614;	// TRN0 routines

 615;	  TransReport:      #640
 616;	  EnterSymbol:      #641
 617;	  EnterEnd:         #642
 618;	  SaveStaticItem:   #643

 619;	// TRN1 routine

 620;	  Trans:            #644

 621;	// TRN2 routines

 622;	  TransLET:         #645        // TRN2.B
 623;	  DeclStat:         #646
 624;	  EnterExt:         #647
 625;	  DeclExtList:      #650        // TRN2.B
 626;	  AddName:          #651

 627;	// /////
 628;	// Hand coded in HANDCD.MAC

 629;	  CellWithName:     #652
 630;	  CheckDistinct:    #653

 631;	// /////////

 632;	  ListLength:       #654

 633;	// TRN3 routines

 634;	  Decllabels:       #655
 635;	  Jumpcond:         #656
 636;	  Loadlist:         #657

 637;	// TRN4 routines

 638;	  Transswitch:      #660
 639;	  Assign:           #661

 640;	// TRN5 routines

 641;	  Load:             #662
 642;	  LoadLV:           #663

 643;	// TRN6 routines

 644;	  EvalConst:        #664
 645;	  Lookat:           #665

 646;	// TRN7 routines

 647;	  Pures:            #666
 648;	  Impures:          #667
 649;	  Complab:          #670
 650;	  Compentry:        #671
 651;	  Compdatalab:      #672
 652;	  Compjump:         #673
 653;	  Out1:             #674
 654;	  Out2:             #675
 655;	  Out2P:            #676
 656;	  Out3P:            #677
 657;	  Out1C:            #700
 658;	  OutN:             #701
 659;	  OutL:             #702
 660;	  OutC:             #703

 661;	// TRN8 routines

 662;	  DoQualName:       #704
 663;	  EvalSize:         #705

 664;	// TRN9 routines

 665;	  TransStructDecl:  #706
 666;	 }

 667;	manifest                        // Types for items in Dvec
 668;	{ LOCAL  := 1001
 669;	  LABEL  := 1002
 670;	 }

 671;	structure
 672;	{ QN                            // The datum returned by DoQualName.
 673;	  { W bit 6                     // Width.
 674;	    T bit 2                     // Access type.
 675;	    M bit 2                     // Mode of loaded value.
 676;	    N bitn 26                   // Numeric part of the offset.
 677;	   }
 678;	 }

 679;	manifest                        // Various parameters.
 680;	{ DvecN  :=      2              // Length of a Dvec entry.
 681;	  CaseN  :=      3              // ditto case table.

 682;	// Sizes of various tables.

 683;	  DvecT  :=      1000 * DvecN   // Dynamic names.
 684;	  CaseT  :=      CaseMax * CaseN
 685;	                                // Case table.
 686;	  Savespacesize  :=
 687;	                 2
 688;	  StringMaxOb  :=
 689;	                 511

 690;	// object machine parameters

 691;	  ByteSizeOb  := 9
 692;	  WordSizeOb  := 36
 693;	 }



		HEADTRNCON.BCP;5

 694;	// Declarations for the BCPL Compiler 
 695;	// Manifests for AE.Tree and OCODE.

 696;	manifest
 697;	 {
 698;	  NUMBER_ 16;     NAME_ 17;            STRINGCONST_ 18
 699;	             CHARCONST_ 19;     TRUE_ 20;    FALSE_ 21;      NIL_ 22
 700;	      LV_ 23;       RV_ 24;      NEG_ 25;      NOT_ 26;       RH_ 27
 701;	      LH_ 28;       Q1_ 29;       Q2_ 30;       Q3_ 31;       Q4_ 32
 702;	    SIZE_ 33;   OFFSET_ 34;    FPLUS_ 35;   FMINUS_ 36;    FMULT_ 37
 703;	    FDIV_ 38;     FNEG_ 39;      FGR_ 40;      FEQ_ 41;      FLS_ 42
 704;	    PLUS_ 43;    MINUS_ 44;     MULT_ 45;      DIV_ 46;      REM_ 47
 705;	  LOGAND_ 48;    LOGOR_ 49;       EQ_ 50;       NE_ 51;       LS_ 52
 706;	      LE_ 53;       GE_ 54;       GR_ 55;      EQV_ 56;     NEQV_ 57
 707;	   EQUIV_ 58;   NEQUIV_ 59;   LSHIFT_ 60;   RSHIFT_ 61;   LSCALE_ 62
 708;	  RSCALE_ 63;    VECAP_ 64;              RIGHTLUMP_ 65; LEFTLUMP_ 66
 709;	  COMCOM_ 67;    COMMA_ 68;     COND_ 69;      ASS_ 70;   UPLUMP_ 71
 710;	     DOT_ 72;    TABLE_ 75;     LIST_ 76;    VALOF_ 77; RESULTIS_ 78
 711;	 REPNAME_ 79;   REPVAL_ 80; NUMBARGS_ 81; LEFTSIDE_ 82;   STATIC_ 92
 712;	     EXT_ 93; MANIFEST_ 94;    INDEX_ 95;              STRUCTURE_ 97
 713;	     LET_ 98;      AND_ 99;   VALDEF_100; CONSTDEF_101;    FNDEF_102
 714;	   RTDEF_103;      VEC_105;     FNAP_106;     RTAP_107;      END_109
 715;	     SEQ_110;     GOTO_111;    COLON_112;     TEST_113;       IF_118
 716;	  UNLESS_119;    UNTIL_120;    WHILE_121;   REPEAT_122
 717;	           REPEATUNTIL_123;            REPEATWHILE_124;      FOR_125
 718;	SWITCHON_128; BRANCHON_129;     CASE_131;   CASETO_132;  DEFAULT_133
 719;	 ENDCASE_134;     LINE_135;    BREAK_136;     LOOP_137;   RETURN_138
 720;	  FINISH_139;    ABORT_140;    ERROR_141;  OVERLAY_144;      BIT_145
 721;	    BITB_146;     BITN_147;     BYTE_148;    BYTEN_149;     CHAR_150
 722;	    FILL_151;     WORD_152;       SD_153;   SDATOM_154;      REP_155
 723;	  GLOBAL_156;    STORE_157;     FNRN_158;     RTRN_159;  STINDRH_160
 724;	 STINDLH_161;  STINDQ1_162;  STINDQ2_163;  STINDQ3_164;  STINDQ4_165
 725;	    CFGB_166;     RVCB_167;       LP_168;       LN_169;      LLP_170
 726;	      LX_173;       SP_174;    STACK_175;   RSTACK_176;     SAVE_177
 727;	    SPRH_178;    ITEMN_179;     SPLH_180;     SPQ1_181;     SPQ2_182
 728;	    SPQ3_183;     SPQ4_184;       SX_186;     SXQ1_187;     SXQ2_188
 729;	  LVRTAP_189;       LL_190;      LLL_191;     SLRH_192;     SLLH_193
 730;	    SLQ1_194;     SLQ2_195;     SLQ3_196;     SLQ4_197;       SL_198
 731;	    JUMP_199;       JT_200;       JF_201;      RES_202;    ITEML_203
 732;	  ITEMNL_204;      LAB_205;  DATALAB_206;     LSTR_207;      INT_208
 733;	   ENTRY_209;    BLOCK_210;   STINDC_211;      RVC_212;     RVCN_213
 734;	     CFG_214;     CFGN_215;      SPC_216;      SLC_218;       LC_219
 735;	    DECL_220;    STIND_221;       SG_222;      SGC_223;       LG_224
 736;	     LLG_225;     SGRH_226;     SGLH_227;     SGQ1_228;     SGQ2_229
 737;	    SGQ3_230;     SGQ4_231;   RVPLUS_232;    RNAME_233;    RFNAP_234
 738;	   RRTAP_235;      LHZ_236;      RHZ_237;      Q1Z_238;      Q2Z_239
 739;	     Q3Z_240;      Q4Z_241;             ASCIZCONST_242;     LZTR_243
 740;	   SPRHZ_244;    SPLHZ_245;    SGRHZ_246;    SGLHZ_247;    SLRHZ_248
 741;	   SLLHZ_249; STINDRHZ_250; STINDLHZ_251;              DYNVECDEC_252
 742;	STACKABS_253;   MODIFY_254
 743;	CSIZE_83 ; ENDEF_84
 744;	  }



		NLEX1.BCP;3


 745;	// BCPL Compiler -- Lexical Analyzer, Part 1.

 746;	// Nextsymb Read the next lexical token and store it into Symb.
 747;	// *LexOut  Output a lexeme, inserting SEMICOLON or DO as needed.
 748;	// *Kind  Return a constant describing what sort of thing a character
 749;	//-- is.
 750;	// *Numinp  Convert an unpacked string into a fpt number using the FLIN
 751;	//-- JSYS.
 752;	// * local to this file.

 753;	get "<BCPL>utilhead"
 754;	get "<BCPL>head"
 755;	get "<XBCPL>headlex"            // Communication in LEX and CAE.
 756;	get "<XBCPL>headbcpl"           // BCPL compiler library declarations.
 757;	get "<XBCPL>headlexcon"         // Declarations of the values of the
 758;	                                //-- lexemes.

 759;	manifest                        // Values returned by Kind to be stored
 760;	                                //-- into Chkind.
 761;	{ Empty :=       0
 762;	                 Simple :=
 763;	                 1
 764;	                 Ignorable :=
 765;	                 2
 766;	                 Digit :=
 767;	                 4
 768;	                 Capital :=
 769;	                 5
 770;	                 Small :=
 771;	                 6
 772;	 }

 773;	// The following routine is the lexical processor for BCPL.  Calling it
 774;	//-- causes the next lexeme
 775;	// to be read from the input stream and the appropriate canonic symbol
 776;	//-- to be stored into Symb.
 777;	// In addition, there may be data in the V-vector, as follows...
 778;	// NUMBER  value
 779;	// CHARCONST value
 780;	// NAME  location
 781;	// STRINGCONST n  n words of the string, packed 4 chars/word as usual.
 782;	// SECTBRA  n  the label, as a packed string n words long
 783;	// SECTKET  n  ditto
 784;	// For a name, the datum in V|0 is the absolute address of the name in
 785;	//-- the symbol table.

 786;	// This routine also handles the preprocessor rules regarding insertion
 787;	//-- of SEMICOLON and DO
 788;	// where needed.

 789;	let Nextsymb() be
 790;	{ WUPFLG:=false
 791;	  if ReadAhead do               // Do we already have a symbol in hand?
 792;	  { Symb, ReadAhead := ExtraSymb, false
 793;	                                // Yes, so return it.
 794;	    return
 795;	   }

 796;	  Curline:=JRFPTR(INPUT)	//update the char ptr to the current command before each symbol is read.

 797;	  let Vp := 0; V|0 := 0         // Counter of characters read.
 798;	  unless Chkind eq Empty goto M

 799;	Next:                           // Come here to read next character.
 800;	  Rch()

 801;	L:
 802;	  Chkind := Kind(Ch)
 803;	M:
 804;	  switchon Chkind into          // What sort of character is it?
 805;	  { case Ignorable:
 806;	       Rch() repeatwhile Ch eq $*s \ Ch eq $*t
 807;	                                // Skip spaces and such.
 808;	       goto L

 809;	    case Digit:
 810;	       { let SWdot := false     // No decimal point has been read.
 811;	         { switchon Ch into     // What sort of character is it?
 812;	           { default:           // Not part of a number, so jump out.
 813;	               break

 814;	             case $E:
 815;	             case $e:
 816;	               test SWdot then
 817;	               { if Ch=$e then Ch:=$E ; endcase
 818;	                }
 819;	               or break
 820;	             case $+:
 821;	             case $-:
 822;	               test SWdot & (V|Vp=$e \ V|Vp=$E) then endcase
 823;	               or break
 824;	             case $.:           // A decimal point.
 825;	               if SWdot break   // The second one, so it"s not part of
 826;	                                //-- a number.
 827;	               Rch()            // Read the next character.
 828;	               unless $0 le Ch le $9 do
 829;	                                        // If next not digit, dot is
 830;	                                        //-- not part of number.
 831;	               { ReadAhead, ExtraSymb := true, q2 DOT; break
 832;	                }
 833;	               Vp := Vp + 1; V|Vp := $.
 834;	               SWdot := true    // Remember that we saw it.
 835;	             case $0 to $9:     // A digit.
 836;	            }
 837;	           Vp := Vp + 1; V|Vp := Ch
 838;	                                // Store the character.
 839;	           Rch()                // And read another.
 840;	          }
 841;	         repeat

 842;	         test SWdot             // Is it a floating-point number?
 843;	         ifso { V|0 := Vp; V|0 := Numinp(V) }
 844;	                                // Yes, so convert it.
 845;	         ifnot
 846;	         { let n := 0
 847;	           for k := 1 to Vp do n := 10*n + (#17 & V|k)
 848;	           V|0 := n
 849;	          }
 850;	         LexOut(NUMBER)
 851;	         Chkind := Kind(Ch)
 852;	         return
 853;	        }

 854;	    case Capital:
 855;	    case Small:
 856;	       {
 857;	         { switchon Chkind into
 858;	           { default:           // Not a character that is in
 859;	                                //-- identifiers.
 860;	               break

 861;	             case Capital:
 862;	             case Digit:
 863;	             case Small:
 864;	               if Vp ge Vmax break
 865;	                                // Name too long.
 866;	               Vp := Vp + 1; V|Vp := Ch
 867;	                                // Store the character.
 868;	               Rch(); Chkind := Kind(Ch)
 869;	                                // Read the next one.
 870;	            }
 871;	          }
 872;	         repeat
 873;	         if Vp > NAMELENGTH do { CAEreport(2,,9); Vp := NAMELENGTH }

 874;	// The identifier has been scanned.

 875;	         let Name := vec NAMELENGTH/Bytesperword
 876;	                                // A place for a packed name.
 877;	         V|0 := Vp; Packstring(V, Name)
 878;	                                // Pack the name there.
 879;	         let T := DictionaryEntry(Name)
 880;	                                // Look up the name in the dictionary.
 881;	         if (~ SWcontrol) & rv T eq GET do
 882;	                                           // The GET directive.
 883;	         { let OldLI := LastItem; LastItem := 0
 884;	                                // Don"t insert a SEMICOLON here.
 885;	           Nextsymb()           // Read the file name.
 886;	           unless Symb eq q2 STRINGCONST do CAEreport(-10,,91)
 887;	           DoGet(V+1)           // Do the GET.
 888;	           LastItem, NLPending := OldLI, true
 889;	           Nextsymb()           // Read the first lexeme of the new
 890;	                                //-- file.
 891;	           return
 892;	          }
 893;	         if q2 rv T = RNAMECODE do { V|0:=T ; LexOut(rv T) ; return }
 894;	         test q2 rv T > 0       // Is it a reserved word?
 895;	         ifso LexOut(rv T)      // Yes, so output it.
 896;	         ifnot { V|0 := T+1; LexOut(NAME) }
 897;	                                // No, output a name.
 898;	         return
 899;	        }

 900;	    default:                    // It"s nothing simple, so branch on
 901;	                                //-- the character rather than the
 902;	                                //-- type.
 903;	   }

 904;	  Chkind := Empty               // Mark the character as having been
 905;	                                //-- used.
 906;	  switchon Ch into
 907;	  { case $#:                    // An octal number.
 908;	              { let n := 0
 909;	                Rch()
 910;	              l:
 911;	                while $0 le Ch le $7 do
 912;	                { n := (n lshift 3) + (#17 & Ch); Rch()
 913;	                 }

 914;	// check for 8 or 9
 915;	                if Ch=$8 \ Ch=$9 do { CAEreport(35) ; Ch:=$7 ; goto l}
 916;	                V|0 := n; LexOut(NUMBER)
 917;	                Chkind := Kind(Ch)
 918;	                return
 919;	               }

 920;	    case ${:
 921;	    case $[:
 922;	    case $]:
 923;	    case $}:
 924;	              { let x := Ch     // Remember what it was.
 925;	                and VV := vec BRACKETLABEL
 926;	                { Rch()
 927;	                  Chkind := Kind(Ch)
 928;	                  unless Chkind ge Digit break
 929;	                  Vp := Vp + 1
 930;	                  if Vp > BRACKETLABEL do
 931;	                  { CAEreport(2,,92); Vp := BRACKETLABEL; break
 932;	                   }
 933;	                  VV|Vp := Ch
 934;	                 }
 935;	                repeat
 936;	                VV|0 := Vp; Packstring(VV, lv V|1)
 937;	                                // Pack the label starting at V|1
 938;	                V|0 := 1 + Vp/Bytesperword
 939;	                                // Number of words in the packed label.
 940;	                LexOut(((x eq ${)\(x=$[)) => SECTBRA, SECTKET)
 941;	                return
 942;	               }

 943;	    case $.:  LexOut(DOT)
 944;	              return

 945;	    case $%:  Rch()
 946;	              switchon Ch into
 947;	              { default: CAEreport(93); goto Next

 948;	                case $+: LexOut(FPLUS) ; return

 949;	                case $-: LexOut(FMINUS) ; return

 950;	                case $**:
 951;	                         LexOut(FMULT) ; return

 952;	                case $/: LexOut(FDIV) ; return

 953;	                case $_: LexOut(FEQ) ; return

 954;	                case $>: LexOut(FGR) ; return

 955;	                case $<: LexOut(FLS) ; return
 956;	               }

 957;	    case $(:  LexOut(RBRA); return

 958;	    case $):  LexOut(RKET); return

 959;	    case $+:  LexOut(PLUS); return

 960;	    case $,:  Rch()
 961;	              test Ch eq $,
 962;	              ifso LexOut(COMCOM)
 963;	              ifnot { LexOut(COMMA); Chkind := Kind(Ch) }
 964;	              return

 965;	    case $;:  LexOut(SEMICOLON); return

 966;	    case $&:  LexOut(LOGAND); return

 967;	    case $\:  LexOut(LOGOR); return

 968;	    case $=:  Rch()
 969;	              unless Ch eq $> do
 970;	              { LexOut(EQ); Chkind := Kind(Ch); return
 971;	               }
 972;	              LexOut(COND)
 973;	              return

 974;	    case $<:
 975;	              { Rch()
 976;	                test Ch eq $<
 977;	                ifso LexOut(LEFTLUMP)
 978;	                ifnot { LexOut(LS) ; Chkind:=Kind(Ch)}
 979;	               }
 980;	              return

 981;	    case $>:
 982;	              { Rch()
 983;	                test Ch eq $>
 984;	                ifso LexOut(RIGHTLUMP)
 985;	                ifnot { LexOut(GR) ; Chkind:=Kind(Ch)}
 986;	               }
 987;	              return

 988;	    case $_:  Rch()
 989;	              LexOut(ASS); Chkind := Kind(Ch); return

 990;	    case $~:  LexOut(NOT); return

 991;	    case $**: LexOut(MULT) ; return

 992;	    case $/:                    // Division or comment
 993;	              Rch()
 994;	              if Ch ne $/ do
 995;	              { LexOut(DIV); Chkind := Kind(Ch); return
 996;	               }                // Division.
 997;	              Rch() repeatuntil Ch eq $*n \ Ch eq $*e
 998;	                                // Skip a comment.
 999;	              if Ch eq $*e goto EOF
1000;	                                // End of file.

1001;	    case #12: case $*n: case #14:	//end of line
1002;	              Curline:=JRFPTR(INPUT)
1003;	              NLPending := true
1004;	              goto Next

1005;	    case $!:
1006;	    case $|:  LexOut(VECAP) ; return

1007;	    case $-:  Rch()
1008;	              unless Ch eq $> do
1009;	              { LexOut(MINUS)
1010;	                Chkind:=Kind(Ch)
1011;	                return
1012;	               }
1013;	              LexOut(COND)
1014;	              return

1015;	    case $::  Rch()
1016;	              if Ch eq $: do { DoControl(); Ch:=$*n ; goto L }
1017;	                                // Control line.
1018;	              if Ch=$= do { LexOut(ASS) ; return }
1019;	              Chkind := Kind(Ch)
1020;	              LexOut(COLON)
1021;	              return

1022;	    case $*^: LexOut( UPLUMP); return

1023;	    case $':                    // ASCIZ quote
1024;	    case $*":                   // String quote.
1025;	    case $$:                    // Character constant.
1026;	              { let Type := Ch  // Remember what it was.
1027;	                and VV := vec StringMaxOb
1028;	                                // A place to put the characters of the
1029;	                                //-- string.
1030;	                { Rch()
1031;	                  if (Ch eq Type eq $*")\(Ch=Type=$') do
1032;	                                                         // Just read
1033;	                                                         //-- the end
1034;	                                                         //-- of a
1035;	                                                         //-- string.
1036;	                  { VV|0 := Vp; Packstring(VV, V+1)
1037;	                                // Pack the string into V.
1038;	                    V|0 := 1 + Vp/Bytesperword
1039;	                                // Number of words to store the string.
1040;	                    LexOut((Ch=$')=>ASCIZCONST,STRINGCONST)
1041;	                    return
1042;	                   }
1043;	                  if Vp > StringMaxOb \ Ch eq $*e do
1044;	                  { CAEreport(95)
1045;	                    V|0, V|1 := 1, "$$"|0
1046;	                    LexOut(STRINGCONST)
1047;	                    return
1048;	                   }
1049;	                  if Ch eq $*n do CAEreport(4,,90)
1050;	                                  // Caution him that the string is
1051;	                                  //-- long.
1052;	                  if Ch eq $*^ do
1053;	                  { Rch()
1054;	                    if $a le Ch le $z do Ch:=Ch&#737
1055;	                                         // force upper case here
1056;	                    if $A le Ch le $_ do Ch:= Ch & #237
1057;	                   }
1058;	                  if Ch eq $**
1059;	                  do
1060;	                  { Rch()
1061;	                    Ch := valof
1062;	                    { if $A le Ch & Ch le $Z do Ch:=Ch+#40
1063;	                                                // force lower case
1064;	                                                //-- here
1065;	                      switchon Ch into
1066;	                      { default:
1067;	                          resultis Ch

1068;	                        case $t:
1069;	                          resultis $*t

1070;	                                // tab
1071;	                        case $s:
1072;	                          resultis $*s

1073;	                                // space
1074;	                        case $n:
1075;	                          resultis $*n

1076;	                                // new line
1077;	                        case $b:
1078;	                          resultis $*b

1079;	                                // backspace
1080;	                        case $p:
1081;	                          resultis #14

1082;	                                // new page (also read in)
1083;	                        case $e:
1084;	                          resultis #777

1085;	                                // end of stream
1086;	                        case $0:
1087;	                        case $1:
1088;	                        case $2:
1089;	                        case $3:
1090;	                                // Octal escape.
1091;	                        case $4:
1092;	                        case $5:
1093;	                        case $6:
1094;	                        case $7:
1095;	                          { let t := Ch&7
1096;	                            Rch()
1097;	                            t := (t lshift 3) + (Ch&7)
1098;	                            Rch()
1099;	                            t := (t lshift 3) + (Ch&7)
1100;	                            resultis t
1101;	                           }
1102;	                        case $f:
1103;	                          resultis #14

1104;	                                // form feed
1105;	                        case $c:
1106;	                          resultis #15

1107;	                                // carriage return
1108;	                        case $l:
1109;	                          resultis #12

1110;	                                // line feed
1111;	                        case $v:
1112;	                          resultis #13

1113;	                                // vertical tab
1114;	                        case $d:
1115;	                          resultis 0

1116;	                                // null character
1117;	                        case $r:
1118;	                          resultis #177

1119;	                                // rubout
1120;	                        case $a:
1121;	                          resultis #100

1122;	                                // @
1123;	                        case $$:
1124;	                          resultis $^[

1125;	                                // altmode
1126;	                       }
1127;	                     }
1128;	                   }

1129;	                  Vp := Vp + 1; VV|Vp := Ch
1130;	                                // Store the character.
1131;	                  if Type eq $*" loop
1132;	                                // Keep reading a string constant.
1133;	                  if Type eq $' loop
1134;	                                // Keep reading a string constant.
1135;	                  V|0 := Ch; LexOut(CHARCONST)
1136;	                  return
1137;	                 }
1138;	                repeat
1139;	               }

1140;	    case $^z: WriteS( "Input terminated by control-z*n")

1141;	    case $*e:                   // End of a file.
1142;	    EOF:      if GetP eq 1 do { LexOut(END); return }
1143;	                                // No nested "get" files.
1144;	              JNDRD(INPUT)
1145;	              GetP := GetP - 1
1146;	              INPUT := rh GetV|GetP
1147;	              Curfile, Curline := lh GetV|GetP,JRFPTR(INPUT)
1148;	              NLPending := true
1149;	              goto Next

1150;	    default:  CAEreport(2,,96)
1151;	              WriteS("The character is *""); WriteChar(Ch)
1152;	              WriteS("*" and has ascii code "); WriteOct(Ch)
1153;	              WriteS(" octal*n")
1154;	              goto Next

1155;	   }
1156;	 }

1157;	// The parameter Item of the following routine contains a lexeme and
1158;	//-- the data for insertion
1159;	// of SEMICOLON or DO, packed like this...
1160;	// q4 (0 => never, 1 => may, 2 => must) begin a command
1161;	// q3 (0 => never, 1 => may, 2 => must) end a command
1162;	// q2 the numeric lexeme itself.
1163;	// Two kinds of processing are done...
1164;	// 1. If last item may or must end a command and this item may begin a
1165;	//-- command and a NEWLINE
1166;	// has intervened between them, insert a SEMICOLON before this item.
1167;	// 2. If last item may end a command and this one must begin one,
1168;	//-- insert a DO before this one.

1169;	and LexOut(Item) be             // Include canonic symbol Item in the
1170;	                                //-- lexical stream.
1171;	{ let t4,t3:=Item&(#14,,0),LastItem&(3,,0)
1172;	  Symb := q2 Item               // The lexeme.
1173;	  if t4>0 & t3>0 & (NLPending \ (t4=(#10,,0) & t3=(1,,0))) do
1174;	  { ReadAhead, ExtraSymb := true, Symb
1175;	    Symb := NLPending => q2 SEMICOLON, q2 DO
1176;	   }
1177;	  LastItem := Item              // Remember this item.
1178;	  unless SWcontrol do NLPending := false
1179;	 }

1180;	and Kind(Ch) := selecton Ch into
1181;	{ case $a to $z:  Small

1182;	  case $A to $Z:  Capital

1183;	  case $0 to $9:  Digit

1184;	  case $*c:                     // cr. lf follows.

1185;	  case $*s:
1186;	  case $*t:
1187;	  case 0:         Ignorable

1188;	  default:        Simple
1189;	 }

1190;	and Numinp(v):=valof
1191;	{ let v1:=vec 40
1192;	  let v2:=vec 40
1193;	  Packstring(v,v1)
1194;	  StringToASCIZ(v1,v2)
1195;	  v1|1:=(-1),,v2
1196;	  unless JSYS(#232,v1)=2 do BCPLreport(9)
1197;	                                // FLIN
1198;	  resultis v1|2
1199;	 }



		NLEX2.BCP;5


1200;	// BCPL Compiler -- Lexical Analyzer, Part 2.

1201;	// Rch  Read the next character from stream INPUT into Ch.
1202;	// OpenSource Open a source stream.
1203;	// *JfnToString	Convert a jfn to a BCPL string having the file name
1204;	// DictionaryEntry Enter a name into the dictionary.
1205;	// DoControl Process a control line.
1206;	// *UPSToSixbit	Convert an unpacked string to a "sixbit" value
1207;	// *SeparateFN	Separate an unpacked file name string into fields
1208;	// *GetConnDir	Get the directory number of the connected directory
1209;	// LinePtr  Return packed pointer to the character currently under
1210;	//-- scan.
1211;	// DoGet  Process the GET compiler directive.
1212;	// DictGetFree Get space from free space, for the hash-table lookup
1213;	//-- routines.
1214;	// *lex2rw  used by DoControl to read a word on a control line
1215;	// * => local to this file only

1216;	get "<BCPL>utilhead"
1217;	get "<BCPL>head"
1218;	get "<BCPL>dicthead"
1219;	get "<XBCPL>headbcpl"
1220;	get "<XBCPL>headlex"            // For communication in LEX and CAE.
1221;	get "<XBCPL>headcaecon"         // Lexemes.

1222;	//Home base for the following statics
1223;	static                          // Scalars used by LEX.
1224;	{ ReadAhead :   false           // true implies a token has been read
1225;	                                //-- ahead, and is in ExtraSymb.
1226;	  ExtraSymb :   nil             // Holds a token that has been read
1227;	                                //-- ahead, if any.
1228;	  LastItem :    0               // Last item processed by LexOut.
1229;	  NLPending :   false           // true if a new line has been
1230;	                                //-- encountered.
1231;	  Ch :          nil             // Each character read by Rch is stored
1232;	                                //-- here.
1233;	  SWcontrol :   false           // Set to true only when processing a
1234;	                                //-- control line.
1235;	  DictO :       nil             // * (local static) Here DictionaryEntry leaves a useful
1236;	                                //-- datum.
1237;	  RequireTable: vec RequireSize	// rel files to be loaded with this one
1238;	  RequestTable: vec RequestSize	//rel libraries to be searched when this is loaded
1239;	  DebugSW:      false	//used in conjunction with /d and ::ifdebug
1240;	   // *FixName	Ensure .BCP extension to source file name
1241;	 }

1242;	let Rch() be                    // Read the next character into Ch and
1243;	                                //-- its character pointer into
1244;	                                //-- CharPtr.
1245;	{ l:
1246;	  Ch:=JRch(INPUT)
1247;	  if SWupper & $A le Ch le $Z do Ch := Ch + #40
1248;	  if Ch eq #12 do Ch := $*n
1249;	  if Ch eq 0 do goto l
1250;	  if Ch eq #100 do
1251;	  { unless SWupper do goto l
1252;	    Ch:=JRch(INPUT)
1253;	    test Ch eq #100 then
1254;	    { WUPFLG:=true
1255;	      Ch:=JRch(INPUT)
1256;	     }
1257;	    or if $a le Ch le $z do Ch:=Ch&#737
1258;	   }
1259;	  if WUPFLG do if $a le Ch le $z do Ch:=Ch&#737
1260;	  LineP := LineP + 1
1261;	  if LineP > LineT do LineP := 0
1262;	  LineV|LineP := Ch
1263;	 }

1264;	and OpenSource( Name) be        // Open a file of source input.
1265;	{ GetV|GetP := Curfile ,, INPUT // Remember current input status.
1266;	  if GetP ge GetT do CAEreport(-10,,97)
1267;	                                // Excessive nesting of gets.
1268;	  GetP := GetP + 1
1269;	  INPUT := FindInput(Name)      // Yes, so just open the stream.
1270;	  if INPUT=0 do finish
1271;	  Curfile := GetnameP           // Index in GetnameV of the current
1272;	                                //-- file.
1273;	  if GetnameP ge GetFileMax do CAEreport(-10,,97)
1274;	                                // Too many files.
1275;	  JfnToString(INPUT,Name)
1276;	  INPUT:=JSETUP(INPUT)
1277;	  let V := 0
1278;	  unless Name eq 0 do
1279;	  { let t := ( q4 Name|0 ) / 4  // Number of words in the packed
1280;	                                //-- string.
1281;	    V := Newvec(t+1)            // The place to store the string.
1282;	    V|0:=1                      // for CHAIN in symbol table stuff
1283;	    V:=V+1
1284;	    for k := 0 to t do V|k := Name|k
1285;	                                // Copy the string.
1286;	   }
1287;	  GetnameV|GetnameP :=V
1288;	  GetnameP := GetnameP + 1
1289;	  Curline := JRFPTR(INPUT)
1290;	 }

1291;	and JfnToString(jfn,s):=valof
1292;	{ let v:=vec 20
1293;	  let str:=vec 30
1294;	  v|1:=-1,,str
1295;	  v|2:=jfn
1296;	  v|3:=#11110,,1
1297;	  JSYS(#30,v)                   // JFNS
1298;	  ASCIZToString(str,s)
1299;	  resultis s
1300;	 }

1301;	// The call    T _ DictionaryEntry(Name)    causes Name to be looked up
1302;	//-- in the dictionary.  The
1303;	// result is the address of the dictionary entry, so that the string is
1304;	//-- found at T+1.  If the name was
1305;	// not previously entered, it is put in with a datum of 1.  As a side
1306;	//-- effect, the global
1307;	// variable DictO gets the same value that is returned.

1308;	and DictionaryEntry(Name) := valof
1309;	{                               // external { Enter }   //  Joe
1310;	                                //-- Maleson"s dictionary routine.
1311;	  let Sw := Enter(Name, lv DictO, 1)
1312;	                                // Look up the name.
1313;	  DictO := DictO + DictOffset   // Un-relativize the result.
1314;	  unless Sw do rv DictO := 1
1315;	  resultis DictO
1316;	 }

1317;	and DoControl() be              // Process a control line.
1318;	{ let T := nil                  // A temp.
1319;	  let ch:=nil
1320;	  let v:=vec 20
1321;	  DictO := 0
1322;	  lex2rw(v,lv ch)
1323;	  DictionaryEntry(v)
1324;	  if DictO eq 0 do
1325;	  { CAEreport(2,,210); until Ch=$*n \ Ch=$*c \ Ch=$*l do Rch() ; return
1326;	   }                            // Improper control word.
1327;	  T := q2 rv DictO              // The lexeme itself.
1328;	  if T < 0 do T := ~ T          // It"s OK if it is currently
1329;	                                //-- unreserved.
1330;	unless T=IFDEBUG do
1331;	{
1332;	  DictO := 0                    // Read the parameter.
1333;	  lex2rw(v,lv ch)
1334;	}

1335;	  switchon T into
1336;	  { case REQUIRE:
1337;	                  {             // v has file name

1338;	// do it
1339;	// i.e. set up next (2 word) entry in RequireTable
1340;	// and increment RequireTable|0

1341;	                    let nnn:=vec 30
1342;	                    RequireTable|0:=RequireTable|0+1
1343;	                    let ups:=vec 30
1344;	                    Unpackstring(v,ups)
1345;	                    let dir:=vec 30
1346;	                    SeparateFN(ups,dir,nnn)
1347;	                    RequireTable|((RequireTable|0)*2-1):=
1348;	                      UPSToSixbit(nnn)
1349;	                    test dir|0=0 then ups|1:=GetConnDir()
1350;	                    or
1351;	                    { Packstring(dir,nnn)
1352;	                      StringToASCIZ(nnn,dir)
1353;	                      ups|1:=1
1354;	                      ups|2:=-1,,dir
1355;	                      ups|3:=0
1356;	                      unless JSYS(#40,ups)=3
1357;	                      do Help("Bad REQUIRE or REQUEST file directory name*n")
1358;	                     }
1359;	                    RequireTable|((RequireTable|0)*2):=0,,ups|1
1360;	                    if ch=$*n \ ch=$*c \ ch=$*l do break
1361;	                    lex2rw(v,lv ch)
1362;	                   }
1363;	                  repeat
1364;	                  return

1365;	    case REQUEST:
1366;	                  {             // v has file name

1367;	// do it
1368;	// i.e. set up next (2 word) entry in RequestTable
1369;	// and increment RequestTable|0

1370;	                    let nnn:=vec 30
1371;	                    RequestTable|0:=RequestTable|0+1
1372;	                    let ups:=vec 30
1373;	                    Unpackstring(v,ups)
1374;	                    let dir:=vec 30
1375;	                    SeparateFN(ups,dir,nnn)
1376;	                    RequestTable|((RequestTable|0)*2-1):=
1377;	                      UPSToSixbit(nnn)
1378;	                    test dir|0=0 then ups|1:=GetConnDir()
1379;	                    or
1380;	                    { Packstring(dir,nnn)
1381;	                      StringToASCIZ(nnn,dir)
1382;	                      ups|1:=1
1383;	                      ups|2:=-1,,dir
1384;	                      ups|3:=0
1385;	                      unless JSYS(#40,ups)=3
1386;	                      do Help("Bad REQUIRE or REQUEST file directory name*n")
1387;	                     }
1388;	                    RequestTable|((RequestTable|0)*2):=0,,ups|1
1389;	                    if ch=$*n \ ch=$*c \ ch=$*l do break
1390;	                    lex2rw(v,lv ch)
1391;	                   }
1392;	                  repeat
1393;	                  return

1394;	    case IFDEBUG:
1395;	                  { unless DebugSW do
1396;	                    {
1397;	                      { Rch()
1398;	                       }
1399;	                      repeatuntil Ch=$*n \ Ch=$*l \ Ch=$*c
1400;	                     }
1401;	                    return
1402;	                   }
1403;	    default:
1404;	   }
1405;	  DictionaryEntry(v)

1406;	  switchon T into
1407;	  { case RESERVE:
1408;	                    { if DictO eq 0 do { CAEreport(2,,212); endcase }
1409;	                      let T := q2 rv DictO
1410;	                      if T < 0 do q2 rv DictO := ~ T
1411;	                      if T eq 0 do CAEreport(2,,212)
1412;	                                   // It never was a reserved word.
1413;	                      if ch=$*n \ ch=$*c \ ch=$*l do break
1414;	                      DictO := 0
1415;	                      unless lex2rw(v,lv ch) do break
1416;	                      DictionaryEntry(v)
1417;	                     }
1418;	                    repeat
1419;	                    endcase

1420;	    case UNRESERVE:
1421;	                    { if DictO eq 0 do { CAEreport(2,,212); endcase }
1422;	                      let T := q2 rv DictO
1423;	                      if T > 0 do q2 rv DictO := ~ T
1424;	                      if T eq 0 do CAEreport(2,,212)
1425;	                      if ch=$*n \ ch=$*c \ ch=$*l do break
1426;	                      DictO := 0
1427;	                      unless lex2rw(v,lv ch) do break
1428;	                      DictionaryEntry(v)
1429;	                     }
1430;	                    repeat
1431;	                    endcase

1432;	    case SYNONYM:
1433;	                    { if DictO eq 0 do { CAEreport(2,,213); endcase }
1434;	                      let T := DictO
1435;	                      DictO:=0
1436;	                      lex2rw(v,lv ch)
1437;	                      DictionaryEntry(v)
1438;	                      let v := q2 rv DictO
1439;	                      if v < 0 do v := ~ v
1440;	                      if v eq 0 do { CAEreport(2,,213); endcase }
1441;	                      lh rv T := lh rv DictO
1442;	                      q2 rv T := v
1443;	                      endcase
1444;	                     }

1445;	    default:        CAEreport(2,,210)
1446;	   }
1447;	 }

1448;	and UPSToSixbit(ups):=valof
1449;	{ let x:=0
1450;	  for i:=1 to ups|0 do x:=((((ups|i)&#137)+#40)&#77)+(x lshift 6)
1451;	  resultis x lshift ((6-ups|0)*6)
1452;	 }

1453;	and SeparateFN(bigups,dirups,restups) be
1454;	{ dirups|0:=0
1455;	  let j:=1
1456;	let k_1
1457;	if bigups|k=$*" do k_k+1
1458;	  restups|0:=0
1459;	  if bigups|k=$<
1460;	  do for i:=k+1 to bigups|0 do
1461;	     { if bigups|i=$> do { j:=i+1 ; break }
1462;	       dirups|0:=dirups|0+1
1463;	       dirups|(dirups|0):=bigups|i
1464;	      }
1465;	  for i:=j to bigups|0 do
1466;	  { if bigups|i=$. \ bigups|i=$*" do break
1467;	    restups|0:=restups|0+1
1468;	    restups|(restups|0):=bigups|i
1469;	   }
1470;	 }

1471;	and GetConnDir():=valof
1472;	{ let v:=vec 20
1473;	  JSYS(#13,v)                   // GJINF
1474;	  resultis (0,,v|2)
1475;	 }

1476;	and LinePtr() := Curfile ,, Curline

1477;	and DoGet(Name) be              // Process the GET compiler directive.
1478;	{ FixName(Name)                 // Insure that the name ends in ".B".
1479;	  LastItem := 0                 // No insertion of SEMICOLON or DO.
1480;	  OpenSource(Name)              // Open the next input stream.
1481;	 }

1482;	// This routine is called from only Enter, the dictionary-lookup
1483;	//-- package.

1484;	and DictGetFree(n) :=           // Return the address of a block of n
1485;	                                //-- words.
1486;	Newvec(n-1) - DictOffset

1487;	and lex2rw(strng,chlv) :=valof
1488;	{ let v:=vec 100
1489;	  v|0:=0
1490;	  { Rch()
1491;	   }
1492;	  repeatwhile Ch=$*s \ Ch=$*t \ Ch=$,
1493;	  if Ch=$*n \ Ch=$*c \ Ch=$*l do resultis false
1494;	  { v|0:=v|0+1
1495;	    v|(v|0):=Ch
1496;	    Rch()
1497;	    if Ch=$*n \ Ch=$*s \ Ch=$*l \ Ch=$*c \ Ch=$*t \ Ch=$, do break
1498;	   }
1499;	  repeat
1500;	  Packstring(v,strng)
1501;	  rv chlv:=Ch
1502;	  resultis true
1503;	 }

1504;	and FixName(X) be
1505;	{ let QQ := vec 50
1506;	  Unpackstring(X,QQ)
1507;	  let Num := QQ|0
1508;	  for i := 1 to Num
1509;	  do if QQ|i = $. do return
1510;	  QQ|0, QQ|(Num+1), QQ|(Num+2), QQ|(Num+3), QQ|(Num+4) :=
1511;	    Num+4, $., $B,$C,$P
1512;	  Packstring(QQ,X)
1513;	 }



		NMAIN1.BCP;6

1514;	// The BCPL Compiler -- Main Program.

1515;	// Start The Main Program
1516;	// Abort
1517;	// *RSclck
1518;	// *getargs
1519;	// *upperstuff
1520;	// *upperpull
1521;	// *isdot
1522;	// DictRetFree	//dummy definition for the dictionary package
1523;	// *Wrtime	print elapsed time
1524;	// Newvec	Return n+1 locations from free space

1525;	get "<bcpl>utilhead"
1526;	get "<bcpl>dicthead"
1527;	get "<bcpl>head"
1528;	get "<XBCPL>headbcpl"
1529;	get "<XBCPL>headlex"

1530;	structure                       // Option switches local to this file
1531;	                                //-- only.
1532;	{ SWlocal
1533;	  { byte 2                      // Skip over global switches.
1534;	    Tree bitb                   // Produce listing of the AE-tree, as
1535;	                                //-- produced by CAE.
1536;	    Tree2 bitb                  // Produce listing of the optimized
1537;	                                //-- AE-tree after Trans.
1538;	    Nocg bitb                   // Terminate compilation after Trans,
1539;	                                //-- before Code Generation.
1540;	    File bitb                   // Compiler output to the file
1541;	                                //-- ".name.m".
1542;	   }
1543;	 }

1544;	external
1545;	{ lslide                        // routine to overlay loader for CCL
1546;	                                //-- LOADER! cmd
1547;	 }

1548;	manifest
1549;	{ Empty  := 0                   // one of the values returned by Kind
1550;	                                //-- in LEX.
1551;	// used here to initialize Chkind
1552;	SWInit_#402000,,0	//initial (default) settings for compiler switches
1553;	 }

1554;	//home base for statics, all of which are local
1555;	static
1556;	{ TreeStream:  0                // if tree output is desired, the
1557;	                                //-- stream
1558;	  cclbool:     false            // set true for subsequent times thru,
1559;	                                //-- if ccl
1560;	  cmdinstream: 0                // primary input  (command) stream

1561;	// for it goes here

1562;	  Greeting:    "***s"           // Prompt string
1563;	  upperpptr:   #441100400000    // byte pointer for OCODE input
1564;	  uppersptr:   #441100400000    // byte pointer for OCODE output
1565;	  RealTime:    0
1566;	  RunTime:     0
1567;	  FreelistP:   0
1568;	  FreelistT:   0
1569;	  FreelistC:   0
1570;	  FreelistL:   0
1571;	  rootname:    0
1572;	  listingname: 0
1573;	  relname:     0
1574;	  sourcename:  0
1575;	  ocodename:   0
1576;	  treename:    0
1577;	  messagename: 0
1578;	 }

1579;	let Start(Entrance) be
1580;	{main

1581;	restart:

1582;	// Initialize global statics for MAIN

1583;	  let v:=vec 220
1584;	  rootname:=v
1585;	  listingname:=v+100
1586;	  relname:=v+120
1587;	  sourcename:=v+140
1588;	  ocodename:=v+160
1589;	  treename:=v+180
1590;	  messagename:=v+200
1591;	  upperpptr:=#441100400000      // byte pointer for OCODE input
1592;	  uppersptr:=#441100400000      // byte pointer for OCODE output
1593;	  jimtbptr:=lv jimtbl
1594;	  jimbytptr:=POINT(7,#400000)
1595;	  Warns:=0
1596;	  Cautions:=0
1597;	  Reportcount:=0
1598;	  GetnameP:=0
1599;	  StaticN:=0
1600;	  NextParameter:=0
1601;	  rootname|0:=0
1602;	  listingname|0:=0
1603;	  relname|0:=0
1604;	  sourcename|0:=0
1605;	  ocodename|0:=0
1606;	  treename|0:=0
1607;	  messagename|0:=0
1608;	  RequireTable|0:=0             // number of 2-word entries
1609;	  RequestTable|0:=0             // ditto

1610;	  let cclnm:="000BCP.TMP"
1611;	  test Entrance=0 then cclnm:=0
1612;	  or
1613;	  { static
1614;	    { v: vec 20
1615;	     }
1616;	    JSYS(#13,v)                 // GJINF
1617;	    let x:=v|3
1618;	    for i:=0 to 5 do v|i:=0
1619;	    let stf(bs,ch) be
1620;	    { v|0:=v|0+1
1621;	      v|(v|0):=ch
1622;	     }
1623;	    let jf:=CreateOutput(-stf)
1624;	    WriteN(jf,x)
1625;	    EndWrite(jf)
1626;	    x:=0
1627;	    for i:=1 to v|0 do x:=(x lshift 9)\v|i
1628;	    cclnm|0:=(cclnm|0 & (#777000,,0)) \ x \ #60060060
1629;	   }

1630;	  unless cclbool do cmdinstream:=FindInput(cclnm)
1631;	  INPUT:=cmdinstream

1632;	  { let v:=vec 20
1633;	    static
1634;	    { cdn: 0
1635;	     }
1636;	    unless cdn=0 do EndRead(cdn)
1637;	    v|1:=#100001,,0
1638;	    v|2:=-1,,'<bcpl>compdict.sav'
1639;	    unless JSYS(#20,v)=2
1640;	    do Help("BCPL: can't find <bcpl>compdict.sav*n")
1641;	    cdn:=rh v|1
1642;	    v|1:=#400000,,rh v|1
1643;	    JSYS(#200,v)                // get
1644;	   }

1645;	  RestoreDict(#400,DictOffset,1)
1646;	  let FREELISTSTART:=DictOffset|0+DictOffset

1647;	// init LEX variables

1648;	  ReadAhead:=false
1649;	  LastItem:=0
1650;	  SWcontrol:=false

1651;	  B:=false
1652;	  LineP:=0
1653;	  Chkind:=Empty
1654;	  NLPending:=false
1655;	  FreelistP:=FREELISTSTART

1656;	// Pointer to free storage list for tree

1657;	  FreelistT:=FREELISTSTART+#77777

1658;	// Top of the free storage list for tree

1659;	  FreelistC:=FREELISTSTART

1660;	// Bottom of free storage list for tree

1661;	  FreelistL:=0
1662;	  ConsoleStream := CreateOutput(0)
1663;	                                // Stream to console.
1664;	  OUTPUT := ConsoleStream

1665;	  SWupper:=false

1666;	// Find out what the user wants.

1667;	  getargs(Entrance=1)           // makes rootname, sourcename, relname,
1668;	                                //-- listingname, and SWbits
1669;	  if Entrance=1 do SWbits<<SWlocal.File:=true

1670;	// Open a stream for compiler comments and error messages.

1671;	  MONITOR :=SWbits << SWlocal.File => valof
1672;	  { let filechars:=rootname|0
1673;	    rootname|(filechars+1):=$.
1674;	    rootname|(filechars+2) := $g
1675;	    rootname|(filechars+3) := $;
1676;	    rootname|(filechars+4) := $T
1677;	    rootname|0 := filechars+4
1678;	    Packstring(rootname,messagename)
1679;	    rootname|0:=filechars
1680;	    resultis CreateOutput(messagename)
1681;	   }
1682;	  , ConsoleStream

1683;	  WriteS("[BCPL:*s")
1684;	  WriteS(sourcename)
1685;	  WriteS("]*n")

1686;	  OUTPUT := MONITOR

1687;	  if SWbits << SW.Synrep do SWbits << SWlocal.Tree2 := false
1688;	  if SWbits << SW.Help do Help("About to start compiling. End of readparameters in Main1")

1689;	  let v := vec ExtDeclT
1690;	  ExtDecl, ExtDeclS := v, 0     // External declarations.

1691;	  let v := vec GetnameT
1692;	  GetnameV := v                 // Names of files included in the
1693;	                                //-- compilation.
1694;	  for k := 0 to GetnameT do GetnameV|k := 0
1695;	                                // Clear the names.

1696;	Compile:                        // Come here to start compiling.
1697;	  { let Tree := Newvec(0)       // The AE-tree goes here when it has
1698;	                                //-- been constructed.

1699;	    if SWbits << SW.Debug do
1700;	    { WriteS("Tree starts at ")
1701;	      WriteOct(Tree)
1702;	      PBOUT($*n)
1703;	     }
1704;	    WriteS("CAE:  ")
1705;	    RSclck()
1706;	    ConstructTree(Tree,sourcename)
1707;	                                // DO THE WORK.

1708;	    if SWbits << SW.Debug do
1709;	    { WriteS("*nAE-Tree size _ ")
1710;	      WriteN(FreelistL + FreelistP - FreelistC)
1711;	      WriteS("[Decimal], from ")
1712;	      WriteOct(Tree)
1713;	      WriteS(" to ")
1714;	      WriteOct(FreelistP)
1715;	      PBOUT($*n)
1716;	     }
1717;	    Wrtime()
1718;	    if SWbits << SW.Pprep goto Terminate

1719;	    if SWbits << SWlocal.Tree \ SWbits << SWlocal.Tree2 do
1720;	                                                           // He wants
1721;	                                                           //-- a
1722;	                                                           //-- listing
1723;	                                                           //-- of the
1724;	                                                           //-- AE-tree.
1725;	    { treename:=Newvec(20)
1726;	      let t := rootname|0
1727;	      rootname|(t+1):=$.
1728;	      rootname|(t+2):=$y
1729;	      rootname|0:=t+2
1730;	      Packstring(rootname,treename)
1731;	      rootname|0:=t
1732;	      WriteS("AE-Tree to file ")
1733;	      WriteS(treename)
1734;	      PBOUT($*n)
1735;	      TreeStream := CreateOutput(treename)
1736;	      OUTPUT := TreeStream
1737;	      WriteS("*nAE-Tree for ")
1738;	      WriteS(sourcename)
1739;	      WriteS("*n*n")
1740;	      if SWbits << SWlocal.Tree do
1741;	      { Curfile := -1
1742;	        Plist(rv Tree, 0, 40)
1743;	        unless SWbits << SWlocal.Tree2 do
1744;	        { EndWrite(OUTPUT)
1745;	          TreeStream := 0
1746;	         }
1747;	       }
1748;	      OUTPUT := MONITOR
1749;	     }

1750;	    if SWbits << SW.Synrep do goto Compile

1751;	    if SWbits << SW.Symtab do SymtabInit(SWupper)
1752;	                                // Initialize the symbol table.
1753;	    unless Reportcount eq 0 do
1754;	    { Abort()
1755;	      test Entrance=1 then
1756;	      { cclbool:=true
1757;	        goto restart
1758;	       }
1759;	      or finish
1760;	     }
1761;	    WriteS("TRN:  ")
1762;	    { let t := rootname|0
1763;	      rootname|(t+1):=$.
1764;	      rootname|(t+2):=$o
1765;	      rootname|0:=t+2
1766;	      Packstring(rootname, ocodename)
1767;	      rootname|0:=t
1768;	     }

1769;	    Ocode:=
1770;	      (SWbits<<SW.Ocode)=>CreateOutput(ocodename,9),
1771;	      CreateOutput(-upperstuff,9)
1772;	    TranslateTree(rv Tree)      // DO THE WORK.

1773;	    if SWbits << SW.Debug do
1774;	    { WriteS("Total tree space = ")
1775;	      WriteN(FreelistL + FreelistP - FreelistC)
1776;	      WriteS(" words.*nOcode length = ")
1777;	      { let v:=vec 20
1778;	        v|1:=Ocode
1779;	        unless JSYS(#43,v)=2 do Help("RFPTR failed on Ocode file*n")
1780;	        WriteN(v|2/4)
1781;	       }
1782;	      WriteS(" words*n")
1783;	     }
1784;	    EndWrite(Ocode)
1785;	    Wrtime()
1786;	    if SWbits << SW.Symtab do SymtabTransEnd()

1787;	    if SWbits << SWlocal.Tree2 do
1788;	                                  // He wants the tree printed with
1789;	                                  //-- optimizations marked.
1790;	    { OUTPUT := TreeStream
1791;	      if SWbits << SWlocal.Tree do PBOUT($*p)
1792;	                                   // New page.
1793;	      WriteS("Optimized Tree.*n*n")
1794;	      Plist(rv Tree, 0, 40)
1795;	      EndWrite(OUTPUT)
1796;	      OUTPUT := MONITOR
1797;	      TreeStream := 0
1798;	     }
1799;	    unless Reportcount eq 0 do
1800;	    { Abort()
1801;	      test Entrance=1 then
1802;	      { cclbool:=true
1803;	        goto restart
1804;	       }
1805;	      or finish
1806;	     }
1807;	   }

1808;	  unless SWbits << SWlocal.Nocg do
1809;	  {codegenerate
1810;	    INPUT:=
1811;	      (SWbits<<SW.Ocode)=>FindInput(ocodename,9),
1812;	      FindInput(-upperpull,9)
1813;	    WriteS("CG:   ")
1814;	    if SWbits << SW.Help do Help("About to start Code Generator. Help call in Main1")
1815;	    { let snm:=vec 20
1816;	      Packstring(rootname,snm)
1817;	      Cg(snm,relname,listingname,rootname)
1818;	                                // do all of the work
1819;	     }

1820;	    EndRead(INPUT)

1821;	    Wrtime()
1822;	    unless Reportcount eq 0 do
1823;	    { Abort()
1824;	      test Entrance=1 then
1825;	      { cclbool:=true
1826;	        goto restart
1827;	       }
1828;	      or finish
1829;	     }
1830;	   }codegenerate

1831;	Terminate:
1832;	  if SWbits << SW.Symtab do
1833;	  { let symbtabname:=vec 20
1834;	    let t:=rootname|0
1835;	    rootname|(t+1):=$.
1836;	    rootname|(t+2):=$s
1837;	    rootname|0:=t+2
1838;	    Packstring(rootname,symbtabname)
1839;	    rootname|0:=t
1840;	    SymtabFinish(symbtabname)
1841;	   }
1842;	  unless OUTPUT eq ConsoleStream do
1843;	  { EndWrite(OUTPUT)
1844;	    OUTPUT := ConsoleStream
1845;	   }
1846;	  unless TreeStream eq 0 do EndWrite(TreeStream)

1847;	  if (Cautions > 0 \ Warns > 0) & SWbits << SWlocal.File
1848;	  do                            // Tell him he had warnings.
1849;	  { WriteS("Compilation of ")
1850;	    WriteS(sourcename)
1851;	    WriteS(" produced ")
1852;	    WriteS(Warns > 0 => "warnings", "cautions")
1853;	    PBOUT($*n)
1854;	    unless MONITOR=ConsoleStream do
1855;	    { WriteS("See file: ")
1856;	      WriteS(messagename)
1857;	      Writech($*n)
1858;	     }

1859;	   }
1860;	  if SWbits << SW.Help do Help("Normal Compiler Termination!!! Help in Main1")
1861;	  if Entrance=1 do
1862;	  { cclbool:=true
1863;	    goto restart
1864;	   }
1865;	  finish
1866;	 }main

1867;	and Abort() be
1868;	{ unless MONITOR eq ConsoleStream do EndWrite(MONITOR)
1869;	  unless TreeStream eq 0 do EndWrite(TreeStream)

1870;	  OUTPUT := ConsoleStream
1871;	  WriteS("Compilation of*s")
1872;	  WriteS(sourcename)
1873;	  WriteS("*saborted*n")
1874;	  if SWbits<<SWlocal.File do
1875;	  { WriteS("BCPL compiler messages were written in file: ")
1876;	    WriteS(messagename)
1877;	    Writech($*n)
1878;	   }
1879;	  if SWbits << SW.Help do Help("Help call before Aborting")
1880;	  rv #42:=rv #42+1
1881;	 }

1882;	and RSclck() be
1883;	{ let X_vec 20
1884;	 JSYS(#14,X)
1885;	  RealTime:=X|1
1886;	  X|1:=-5
1887;	  JSYS(#15,X)
1888;	  RunTime:=X|1
1889;	 }
1890;	// Computes rootname,sourcename, listingname, relname, and SWbits.

1891;	and getargs(cclsw) be
1892;	{ commands:
1893;	  unless cclsw do WriteS(Greeting)
1894;	  SWbits:=SWInit
1895;	  let v:=vec 100
1896;	  v|0:=0
1897;	  { Ch:=PBIN()
1898;	    if cclsw&EofFlg do Ch:=0
1899;	    switchon Ch into
1900;	    { default:  v|0:=v|0+1
1901;	                v|(v|0):=Ch
1902;	      case $*s:
1903;	      case $*t: endcase

1904;	      case $^a: test v|0 > 0 then
1905;	                { Writech($\)
1906;	                  Writech(v|(v|0))
1907;	                  v|0:=v|0-1
1908;	                  endcase
1909;	                 }
1910;	                or
1911;	                { Writech($^g)
1912;	                  endcase
1913;	                 }
1914;	      case $^q: v|0:=0
1915;	                WriteS("##*n")
1916;	                endcase

1917;	      case 0:
1918;	      case $^z: if cclsw do
1919;	                { let v:=vec 20
1920;	                  v|1:=INPUT
1921;	                  unless JSYS(#26,v)=2 do Help("DELF failed*n")
1922;	                 }
1923;	                finish
1924;	      l:
1925;	      case $?:  SWbits:=SWInit
1926;	                WriteS("*n[<rel name>[,<listing name>]_]<source name>[switches>]<cr>*n")
1927;	                WriteS("(Type HELP<cr> for more help)*n")
1928;	      case $^r: Writech($*n)
1929;	                WriteS(Greeting)
1930;	                for i:=1 to v|0 do Writech(v|i)
1931;	                endcase

1932;	      case $^[:
1933;	      case $*n:
1934;	      case $*c:
1935;	      case $*l: if v|0 > 0 do break
1936;	     }
1937;	   }
1938;	  repeat
1939;	  if cclsw & (v|(v|0)=$!) do
1940;	  { let v1:=vec 30
1941;	    let v2:=vec 20
1942;	    Unpackstring("<subsys>",v1)
1943;	    for i:=1 to v|0-1 do
1944;	    { v1|0:=v1|0+1
1945;	      v1|(v1|0):=v|i
1946;	     }
1947;	    v1|0:=v1|0+1
1948;	    v1|(v1|0):=$.
1949;	    v1|0:=v1|0+1
1950;	    v1|(v1|0):=$s
1951;	    v1|0:=v1|0+1
1952;	    v1|(v1|0):=$a
1953;	    v1|0:=v1|0+1
1954;	    v1|(v1|0):=$v
1955;	    Packstring(v1,v2)
1956;	    StringToASCIZ(v2,v1)
1957;	    v2|1:=#100001,,0
1958;	    v2|2:=-1,,v1
1959;	    unless JSYS(#20,v2)=2 do Help("GTJFN failed for loader*n")
1960;	    lslide(rh v2|1)
1961;	   }
1962;	  if v|0=4 &
1963;	     (v|1&#137)=$H &
1964;	     (v|2&#137)=$E &
1965;	     (v|3&#137)=$L &
1966;	     (v|4&#137)=$P
1967;	 do
1968;	  { WriteS("*n[<rel name>[,<listing name>]_]<source name>[switches>]<cr>*n*n")
1969;	    WriteS("Square brackets mean optional*n*n")
1970;	    WriteS("If unspecified, the source file name is assumed to have a .BCP extension*n*n")
1971;	    WriteS("If the rel name is missing, the output rel file will be named*n*s*s*s <source name>.REL*N*n")
1972;	    WriteS("if the listing name is given with no extension, the extension*nis assumed to be *"LST*"*n*n")
1973;	    WriteS("Switches:*n*t/u*tConvert each uppercase alphabetic character in the*n*t*tsource files to lowercase as it is read in, unless it is*n*t*tpreceded by the character *a, or the word it is in*n*t*tis preceded by two *a characters. This is useful for *n*t*tBCPL source files which are prepared on an all upper*n*t*tcase terminal.*n")
1974;	    WriteS("*t/c*tCause compilation to terminate before code generation.*n")
1975;	    WriteS("*t/d*tCompile lines that start with *"::ifdebug*"*n")
1976;	    WriteS("*t/f*tDivert compiler messages to a file named *n*t*t<source file name>.g;T*n*t/s*tDo not output a symbol table (binary) file as a side effect*n*t*tof this compilation. Normally, the file will be output and named*n*t*t<source file name>.s*n*n")
1977;	    goto commands
1978;	   }
1979;	  let snm:=vec 100
1980;	  snm|0:=0
1981;	  let lnm:=vec 100
1982;	  lnm|0:=0
1983;	  let rnm:=vec 100
1984;	  rnm|0:=0
1985;	  let nm:=rnm
1986;	  for i:=1 to v|0
1987;	  do
1988;	  { switchon v|i into
1989;	    { default:
1990;	         nm|0:=nm|0+1
1991;	         nm|(nm|0):=v|i
1992;	         loop

1993;	      case $,:
1994;	         { let t:=0
1995;	           for i:=1 to nm|0
1996;	           do test nm|i=$. then
1997;	              { t:=i-1
1998;	                break
1999;	               }
2000;	              or t:=i
2001;	           if t > 6
2002;	           do
2003;	           { WriteS("output file names must be less than 7 characters long*n")
2004;	             goto commands
2005;	            }
2006;	          }
2007;	         nm:=lnm
2008;	         loop

2009;	case $=:
2010;	      case $_:
2011;	         { nm:=snm
2012;	           loop
2013;	          }
2014;	      case $/:
2015;	         { if i=v|0 do goto l
2016;	           switchon v|(i+1)\#40 into
2017;	           { default: goto l

2018;	             case $u: SWupper:=true
2019;	                      endcase

2020;	             case $s: SWbits<<SW.Symtab:=false
2021;	                      endcase

2022;	             case $d: DebugSW:=true ; endcase

2023;	             case $l: SWbits<<SW.SymtabLong:=false ; endcase
2024;	             case $w: SWbits<<SW.Debug:=true
2025;	                                // wizard
2026;	                      endcase

2027;	             case $h: SWbits<<SW.Help:=true
2028;	                      endcase

2029;	             case $f: SWbits<<SWlocal.File:=true
2030;	                      endcase

2031;	             case $o: SWbits<<SW.Ocode:=true
2032;	                      endcase

2033;	             case $y: SWbits<<SW.Synrep:=true
2034;	                      endcase

2035;	             case $p: SWbits<<SW.Pprep:=true
2036;	                      endcase

2037;	             case $e: SWbits<<SWlocal.Tree2:=true
2038;	                      endcase

2039;	             case $t: SWbits<<SWlocal.Tree:=true
2040;	                      endcase

2041;	             case $c: SWbits<<SWlocal.Nocg:=true
2042;	                      endcase
2043;	            }
2044;	           if i+1=v|0 do break
2045;	           i:=i+2
2046;	           unless v|i=$/ do goto l
2047;	           loop
2048;	          }
2049;	         repeat
2050;	         break
2051;	     }

2052;	   }
2053;	  if snm|0=0 & rnm|0 ne 0 & lnm|0 ne 0 do goto l
2054;	  if snm|0=0 & rnm|0=0 do
2055;	  { let t:=lnm
2056;	    lnm:=snm
2057;	    snm:=t
2058;	   }
2059;	  if snm|0=0 & rnm|0 ne 0 do
2060;	  { let t:=rnm
2061;	    rnm:=snm
2062;	    snm:=t
2063;	   }
2064;	  if rnm|0=0 do
2065;	  { for i:=1 to snm|0
2066;	    do test snm|i=$. then break
2067;	       or test snm|i=$> then rnm|0:=0
2068;	          or
2069;	          { rnm|0:=rnm|0+1
2070;	            rnm|(rnm|0):=snm|i
2071;	           }

2072;	   }
2073;	  unless isdot(snm) do
2074;	  { snm|(snm|0+1):=$.
2075;	    snm|(snm|0+2):=$B
2076;	    snm|(snm|0+3):=$C
2077;	    snm|(snm|0+4):=$P
2078;	    snm|0:=snm|0+4
2079;	   }
2080;	  unless (lnm|0 = 0) \ isdot(lnm) do
2081;	  { lnm|(lnm|0+1):=$.
2082;	    lnm|(lnm|0+2):=$L
2083;	    lnm|(lnm|0+3):=$S
2084;	    lnm|(lnm|0+4):=$T
2085;	    lnm|0:=lnm|0+4
2086;	   }
2087;	  unless isdot(rnm) do
2088;	  { rnm|(rnm|0+1):=$.
2089;	    rnm|(rnm|0+2):=$R
2090;	    rnm|(rnm|0+3):=$E
2091;	    rnm|(rnm|0+4):=$L
2092;	    rnm|0:=rnm|0+4
2093;	   }
2094;	  Packstring(snm,sourcename)
2095;	  Packstring(lnm,listingname)
2096;	  Packstring(rnm,relname)
2097;	  for i:=1 to snm|0
2098;	  do test snm|i=$. then break
2099;	     or test snm|i=$> then rootname|0:=0
2100;	        or
2101;	        { rootname|0:=rootname|0+1
2102;	          rootname|(rootname|0):=snm|i
2103;	         }
2104;	 }

2105;	// called for each ocode character output, if putting the ocode into
2106;	// high segment, rather than into a file

2107;	and upperstuff(bs,ch) be
2108;	{ IDPB(ch,lv uppersptr)
2109;	 }

2110;	// called by BIN for ocode which was put out to high seg.

2111;	and upperpull(bs):=valof
2112;	{ EofFlg:=false
2113;	  test upperpptr=uppersptr
2114;	  then
2115;	  { EofFlg:=true
2116;	    resultis $*e
2117;	   }
2118;	  or resultis ILDB(lv upperpptr)
2119;	 }

2120;	and isdot(v):=valof
2121;	{ for i:=1 to v|0
2122;	  do if v|i=$. do resultis true
2123;	  resultis false
2124;	 }

2125;	and DictRetFree() be Help("DictRetFree called*n")
2126;	and Wrtime() be                 // Print elapsed time.
2127;	{ let Run, Real := RunTime, RealTime
2128;	  RSclck()
2129;	  WriteN(RunTime-Run);WriteS(" ms in ")
2130;	  WriteN((RealTime-Real)/1000); WriteS(" secs*n")
2131;	 }

2132;	and Newvec(N) := valof
2133;	{ let X := FreelistP
2134;	  FreelistP := FreelistP + N + 1
2135;	  if FreelistP > FreelistT do
2136;	  { BCPLreport(240)
2137;	    finish                      // no room to expand
2138;	   }
2139;	  resultis X
2140;	 }


2141;	and ruppersptr()_SWbits<<SW.Ocode=>rfptr(Ocode),uppersptr

2142;	and suppersptr(p) be 
2143;	{ test SWbits<<SW.Ocode then sfptr(Ocode,p) or uppersptr_p
2144;	}



		NMAIN2.BCP;3

2145;	// NMAIN2.BCP  Routines used throughout the compiler.
2146;	// This file also provides storage for static quantities used
2147;	//-- throughout the compiler.

2148;	// NextParam Return the next parameter number.
2149;	// WriteChar Write a character as it might have been typed.
2150;	// Plist  Print a piece of the AE-tree.
2151;	// List1  Return an initialized node of length 1.
2152;	// List2  ditto 2
2153;	// List3, List4, List5, List6 ...
2154;	// Wfline  Write a line of source code.
2155;	// BCPLreport Error reporter for the compiler.

2156;	get "<XBCPL>headbcpl"           // Compiler declarations.
2157;	get "<bcpl>head"
2158;	get "<bcpl>utilhead"

2159;	// The file <XBCPL>TREE.BCP is also included in this compilation, in the routine
2160;	//-- Plist.

2161;	//Home base for the following global statics
2162;	static                          // Variables used throughout the
2163;	                                //-- compiler, and provided space here.
2164;	{ SWbits :        nil           // Compiler option switches.
2165;	  Reportcount :   0             // Count errors.
2166;	  MONITOR :       nil           // Stream for compiler output messages.
2167;	  GetnameV :      nil           // Names of files included in current
2168;	                                //-- compilation.
2169;	  GetnameP :      0             // Pointer through above.
2170;	  ExtDecl :       nil           // Names declared as externals.
2171;	  ExtDeclS :      0             // Counter through the above.
2172;	  StaticN :       0             // Count static locations used, in
2173;	                                //-- TRANS.
2174;	  NextParameter : 0             // Next value returned by NextParam.
2175;	  Ocode :         nil           // Stream to write ocode onto.
2176;	  Curline :       nil           // Pointer to the current line.
2177;	  Curfile :       nil           // The file currently being read -- the
2178;	                                //-- index into GetnameV.
2179;	  SWupper:        0
2180;	  ConsoleStream : nil           // A stream to the console.
2181;	  Warns :         0             // Count warning messages given.
2182;	  Cautions :      0             // Count cautions given.

2183;	 }

2184;	let NextParam(Type) := valof
2185;	{ NextParameter := NextParameter + #10
2186;	  resultis NextParameter + (Type&7)
2187;	 }

2188;	and WriteChar(x) be             // Write the character x as it might be
2189;	                                //-- typed.
2190;	{ let y := selecton x into
2191;	  { default:     x
2192;	    case $*t:    $t             // tab
2193;	    case $*n:    $n             // newline
2194;	    case $*b:    $b             // backspace
2195;	    case $*p:    $p             // new page (also, readin)
2196;	    case $*d:    $d             // line feed down
2197;	    case $*u:    $u             // line feed up
2198;	    case $*$:    $$             // stop
2199;	    case $*e:    $e             // end of stream
2200;	   }
2201;	  unless x eq y do Writech(OUTPUT, $**)
2202;	  Writech(OUTPUT, y)
2203;	 }

2204;	and Plist(x, n, d) be           // Print node x at depth n to maximum
2205;	                                //-- depth d.
2206;	{ manifest
2207;	  { MaxN  := 1023
2208;	   }                            // Print all numbers greater than this
2209;	                                //-- both decimal and octal.

2210;	  static
2211;	  { Line : -1                   // Pointer to the last line printed.
2212;	    C :    nil                  // First character on line.
2213;	   }

2214;	  let SkipTo(n) be              // Skip over an indent for level n,
2215;	                                //-- using tabs as appropriate.
2216;	  { while n > 3 do { PBOUT(C); PBOUT($*t); C := $|; n := n - 4 }
2217;	    PBOUT(C)
2218;	    switchon n into
2219;	    { case 3: WriteS(" . . . "); endcase

2220;	      case 2: WriteS(" . . " ); endcase

2221;	      case 1: WriteS(" . " ); endcase

2222;	      case 0: WriteS(" " )
2223;	     }
2224;	   }

2225;	  and Get(Node) :=              // Look up the type of a node.
2226;	  selecton Node into
2227;	  { default: -1 ,, "unknown operator "
2228;	    case 0:  1 ,, "0"
2229;	             get "<XBCPL>tree"  // The cases -- machine dependent.
2230;	   }

2231;	  C := lh x ne 0 => $>, $|      // If optimized start line with ">",
2232;	                                //-- else "|"
2233;	  x := rh x                     // The node.

2234;	  if x eq 0 do { SkipTo(n); WriteS( "Nil" ); return }
2235;	                                // Null sort of node.

2236;	  if n > d do { SkipTo(n); WriteS("etc"); return }
2237;	                                // Depth exceeded.

2238;	  if x < 1000 do                // x is a tree item rather than a
2239;	                                //-- pointer to one.
2240;	  { SkipTo(n)
2241;	    let Data := Get(x)
2242;	    unless lh Data eq 16 do WriteS("illegal tree ")
2243;	    WriteS(rh Data)
2244;	    return
2245;	   }

2246;	  let Data := Get(H1|x)
2247;	  if lh Data eq 11 do           // A LINE node.
2248;	  { if Line ne H2|x \ SWbits << SW.Debug do
2249;	    { Line := H2|x; Wfline(Line)
2250;	     }
2251;	    Plist(H3|x, n, d)
2252;	    return
2253;	   }

2254;	  SkipTo(n)
2255;	  switchon lh Data into
2256;	  { case 12:                    // NUMBER
2257;	      { WriteS("Number ")
2258;	        let N := H2|x           // The value.
2259;	        WriteN(N)               // Print it decimal.
2260;	        if N > MaxN \ N < -MaxN do { WriteS("     "); WriteOct(N) }
2261;	        return
2262;	       }

2263;	    case 13:                    // NAME
2264;	      WriteS("Name "); WriteS(H2|x); return

2265;	    case 14:                    // STRINGCONST
2266;	      { let v := vec StringLength
2267;	        WriteS("String *"")
2268;	        Unpackstring(x+1, v); for k := 1 to v|0 do WriteChar(v|k)
2269;	        PBOUT($*"); return
2270;	       }

2271;	    case 15:                    // Character constant.
2272;	      WriteS("Charconst $"); WriteChar(H2|x); return

2273;	    case 16:                    // Declarator for structures, such as
2274;	                                //-- BIT.
2275;	      WriteS("illegal tree "); WriteS(rh Data); return

2276;	    case -1:                    // Unrecognized operator.
2277;	      WriteS(rh Data); WriteOct(H1|x); return

2278;	    default:                    // It"s a sort of ordinairy node.
2279;	      WriteS(rh Data)
2280;	      if SWbits << SW.Debug do { WriteS("   "); WriteOct(x) }
2281;	      for k := 2 to lh Data do
2282;	      { PBOUT($*n); Plist( H1|(x+k-1), n+1, d )
2283;	       }
2284;	   }
2285;	 }

2286;	and List1(a) := valof
2287;	{ let V := Newvec(0)
2288;	  V|0 := a
2289;	  resultis V
2290;	 }

2291;	and List2(a, b) := valof
2292;	{ let V := Newvec(1)
2293;	  V|0, V|1 := a, b
2294;	  resultis V
2295;	 }

2296;	and List3(a, b, c) := valof
2297;	{ let V := Newvec(2)
2298;	  V|0, V|1, V|2 := a, b, c
2299;	  resultis V
2300;	 }

2301;	and List4(a, b, c, d) := valof
2302;	{ let V := Newvec(3)
2303;	  V|0, V|1, V|2, V|3 := a, b, c, d
2304;	  resultis V
2305;	 }

2306;	and List5(a, b, c, d, e) := valof
2307;	{ let V := Newvec(4)
2308;	  V|0, V|1, V|2, V|3, V|4 := a, b, c, d, e
2309;	  resultis V
2310;	 }

2311;	and List6(a, b, c, d, e, f) := valof
2312;	{ let V := Newvec(5)
2313;	  V|0, V|1, V|2, V|3, V|4, V|5 := a, b, c, d, e, f
2314;	  resultis V
2315;	 }
2316;	// The format of the parameter n of Wfline is as follows...
2317;	// 4.9 - 3.5   unused
2318;	// 3.4 - 3.1   file number -- index into GetnameV for the file
2319;	// rh: byte number
2320;	// Unused fields must be zero.

2321;	and Wfline(n,nl) be
2322;	{ if NumbArgs()=1 do nl:=1
2323;	  let t:=rh n
2324;	  let v:=vec 20
2325;	  let in:=FindInput(GetnameV|(lh n))
2326;	  let lst:=0
2327;	  { let v:=vec 20
2328;	    v|1:=in
2329;	    unless JSYS(#36,v)=2 do Help("SIZEF failed in Wfline*n")
2330;	    lst:=v|2
2331;	   }
2332;	  { v|1:=in
2333;	    v|3:=t
2334;	    if t ge lst do
2335;	    { WriteS("[[EOF]]")
2336;	      break
2337;	     }
2338;	    JSYS(#54,v)                 // RIN
2339;	    if (v|2=$*n)\(v|2=$*c) do
2340;	    { nl:=nl-1
2341;	      if nl=0 do break
2342;	     }
2343;	    Writech(v|2)
2344;	    t:=t+1
2345;	   }
2346;	  repeat
2347;	  Writech($*n)
2348;	  EndRead(in)
2349;	 }

2350;	// BCPLreport is called with a parameter of the form   Type,,N   where
2351;	//-- N is an error number and Type is
2352;	// 6 A note to the user.
2353;	// 4 A caution -- a possible error.
2354;	// 2 A warning -- a probable error.
2355;	// 0 An error.
2356;	// -1 A compiler bug -- like 0 but produces more output.
2357;	// -8 An error in a BCPL library routine. (N > 600).  These are fatal.
2358;	// -9 Fatal error.  Do a JED 44 and then abort.
2359;	// -10 Fatal error -- abort.
2360;	// -12 Fatal error.  Call Help and then abort.

2361;	and BCPLreport(Error, Ptr) be
2362;	{ let Type, N := lh Error, rh Error
2363;	                                // Error type, error number.
2364;	  if N < 0 do Type, N := -1, 203
2365;	                                // This should be removed sometime.
2366;	  if N > 600 do Type := -8      // Error in the libraries.

2367;	  if Type < -2 \ OUTPUT eq 0 do OUTPUT := ConsoleStream
2368;	  if Type eq -12 do SWbits << SW.Help := true
2369;	                                // Call Help before aborting.
2370;	  let Data := selecton Type into
2371;	  { case 6:  "NOTE" ,, 0
2372;	    case 4:  "CAUTION" ,, lv Cautions
2373;	    case 2:  "WARNING" ,, lv Warns
2374;	    case 0:  "ERROR" ,, lv Reportcount
2375;	    case -1: "COMPILER BUG" ,, lv Reportcount
2376;	    default: "FATAL ERROR" ,, 0
2377;	   }
2378;	  PBOUT($*n)
2379;	  unless N eq 0 do              // Print the error data.
2380;	  { WriteS(lh Data); PBOUT($*s) // Tell him what happened.
2381;	    if rh Data > 0 do rv rh Data := rv rh Data +1
2382;	                                // Step the proper counter.
2383;	    WriteN(N)
2384;	    PBOUT($*n)
2385;	    let BF := vec 100           // Room for error message if we get
2386;	                                //-- fancy.
2387;	    BF|0 := 0                   // We're not fancy
2388;	    { let errs:=FindInput("<bcpl>errmsgs.bin",36)
2389;	      sfptr(errs,N)
2390;	      let p:=BIN(errs)
2391;	      EndRead(errs)
2392;	      if p=0 do goto l
2393;	      errs:=FindInput("<bcpl>errmsgs.bin")
2394;	      sfptr(errs,p)
2395;	      let ch:=BIN(errs)
2396;	      until ch=$% do
2397;	      { BF|0:=BF|0+1
2398;	        BF|(BF|0):=ch
2399;	        ch:=BIN(errs)
2400;	       }
2401;	      EndRead(errs)
2402;	     }

2403;	  l:
2404;	    for i:=1 to BF|0 do Writech(BF|i)
2405;	    PBOUT($*n)
2406;	   }
2407;	  if SWbits << SW.Help do Help("Error report in BCPLreport")
2408;	  if Type < -1 do Abort()
2409;	 }


		NMAIN3.BCP;3


2410;	// The BCPL Compiler -- Main3 --  Routines for creation of the symbol
2411;	//-- table.

2412;	// SymtabInit  Initialize symbol table, store source file information.
2413;	// SymtabStoreSymbol Store a symbol descriptor, returning its offset.
2414;	// SymtabNextN  Return next symbol table location to be assigned.
2415;	// SymtabStoreEnd  Store block end info into symbol block.
2416;	// SymtabStoreArgs  Store number of arguments for a function or
2417;	//-- routine.
2418;	// SymtabTransEnd  Create symbol name block, structure block.
2419;	// SymtabStoreILC  Store instruction counter data for a symbol.
2420;	// SymtabStoreCommand Store command start information in the command
2421;	//-- block.
2422;	// SymtabStoreStack Store stack change data in the command block.
2423;	// SymtabFinish  Finish the symbol table and close the file.
2424;	// *Chain   Chain names together for name block.
2425;	// *Store   Store an item into the symbol table, stepping N.
2426;	// *Copy   Copy a structure definition table.
2427;	// *MakeEven  Store a fill word if necessary to cause N to be even.
2428;	// * local to this file.

2429;	get "<bcpl>head"
2430;	get "<BCPL>utilhead"
2431;	get "<XBCPL>headbcpl"           // Compiler declarations.
2432;	get "<XBCPL>headsymb"           // Structure and manifest declarations
2433;	                                //-- describing the symbol table.

2434;	//local statics
2435;	static
2436;	{ S:          -1                // Address of the base of the symbol
2437;	                                //-- table.
2438;	  N:          nil               // Next free location in the block
2439;	                                //-- currently being created.
2440;	  B:          nil               // Base of the block currently being
2441;	                                //-- created.
2442;	  SDB:        nil               // Base of the symbol descriptor block.
2443;	  BookEnd:    nil               // Last address of the book used for
2444;	                                //-- the symbol table.
2445;	  NameChain:  0                 // Head of the chain of names through
2446;	                                //-- the dictionary.
2447;	  LastName:   nil               // Address of the last name in the name
2448;	                                //-- chain.
2449;	  NextName:   0                 // Next free name location in the name
2450;	                                //-- block.
2451;	  FillWord:   0                 // Used for fill to even word in symbol
2452;	                                //-- descriptor block.
2453;	 }

2454;	structure
2455;	{ NC                            // Name chain words in the dictionary.
2456;	  { s bitb                      // true implies name already chained.
2457;	    c bit 17                    // Address of the next entry in the
2458;	                                //-- chain.
2459;	    n bit 5                     // Number of words in this name (less
2460;	                                //-- 1).
2461;	    f bit 13                    // Offset of name wrt NameB.
2462;	   }
2463;	 }

2464;	manifest { SYMTABSTART_#240000}
2465;	let SymtabInit(slu) be          // Create the symbol table and store
2466;	                                //-- file names into it.
2467;	{ S := SYMTABSTART              // The zero-th location of the symbol
2468;	                                //-- table.
2469;	  NameChain:=0
2470;	  NextName:=0
2471;	  FillWord:=0
2472;	  BookEnd := S + #17777         // Last location in the book.
2473;	  LastName := lv NameChain      // Pointer to last name in the name
2474;	                                //-- chain.

2475;	  N := S + STYYYYSymbHeaderN    // Skip over symbol table header.
2476;	  for k := S to N-1 do rv k := 0
2477;	                                // Initialize the symbol table header.

2478;	  S >> SThead.Version := SymbVersion
2479;	                                // The sort of symbol table described
2480;	                                //-- by the declaration used.
2481;	  S >> SThead.Date := Date()    // Creation date of the symbol table.

2482;	  S >> SThead.FDB := N - S      // Base of the source file descriptor
2483;	                                //-- block.
2484;	  S >> SThead.FDN := GetnameP   // Length of the source file descriptor
2485;	                                //-- block.
2486;	  S>>SThead.SlashUSW:=slu
2487;	  B := N                        // Base of the next block.

2488;	  for k := 0 to GetnameP-1 do   // Look at all source files used.
2489;	  { let x := GetnameV|k
2490;	    Store( Chain(rh x) )
2491;	   }
2492;	  MakeEven()                    // Skip to an even location.
2493;	  B := N                        // Base of the next block.
2494;	  SDB := B - S                  // Base of the symbol descriptor block.

2495;	  if SWbits << SW.Debug do
2496;	  { WriteS("Symbol table starts at "); WriteOct(S); PBOUT($*n)
2497;	   }

2498;	  FillWord << STsd.Type := STfill
2499;	 }

2500;	and SymtabStoreSymbol(Name, Type, Datum) := valof
2501;	                                // Store a symbol descriptor in the
2502;	                                //-- symbol block.
2503;	{ let v := list 0,
2504;	                Datum           // The two words of the entry.
2505;	  and Big := nil
2506;	  test Type=STlocal\Type=STparam
2507;	  ifso
2508;	  { let Size := (1 lshift (size STsd.Data-1))-1
2509;	    Big := (Datum<-Size) \ (Datum>Size)
2510;	    v >> STsd.SmallLocal := Datum
2511;	   }
2512;	  ifnot
2513;	  { Big := (Datum < 0) \ (Datum > STYYYYMaxDatum)
2514;	    v>>STsd.Data := Datum
2515;	   }

2516;	  switchon Type into            // What sort of symbol is being
2517;	                                //-- created?
2518;	  { default:          BCPLreport(-1)
2519;	                                // This shouldn"t happen.
2520;	                      resultis 0

2521;	    case STmanifest:            // A manifest constant.
2522;	                      unless SWbits << SW.SymtabLong resultis -1
2523;	                      if Big do Type := STmanifestYYYYbig
2524;	                      endcase

2525;	    case STlocal:     if Big do Type := STlocalYYYYbig
2526;	                      endcase

2527;	    case STstructure: unless SWbits << SW.SymtabLong resultis -1
2528;	                      Big := true
2529;	                                // This is always a two word item.
2530;	                      endcase

2531;	    case STglobal:    if Big do Type := STglobalYYYYbig
2532;	                      endcase

2533;	    case STparam:               // Formal parameter of a subroutine.
2534;	    case STindex:     Big := false
2535;	                      endcase

2536;	    case STstatic:    Big := true
2537;	                      v >> STsd.Data := rh Datum => 1, 0
2538;	                      v|1 := 0  // Clear the whole of the second word.
2539;	                      v >> STsd.SType := lh Datum
2540;	   }
2541;	  v >> STsd.Type := Type
2542;	  if Big & Type ne STstatic do v >> STsd.Data := 0

2543;	// Now store the new entry.

2544;	  if Big do MakeEven(FillWord)  // Two word entries must start at an
2545;	                                //-- even address.
2546;	  v >> STsd.Name := Chain(H2|Name)
2547;	                                // Enter the name into the name table.
2548;	  let n := N - S                // The offset where the entry goes, to
2549;	                                //-- be returned to the caller.
2550;	  if n eq 0 do n := 0           // -0 is a bore.
2551;	  Store(v|0); if Big do Store(v|1)
2552;	                                // Store the entry.
2553;	  resultis n
2554;	 }

2555;	and SymtabNextN() := N - S      // Return next free location in the
2556;	                                //-- symbol table, for STsectket.

2557;	and SymtabStoreEnd(SE) := valof // Store a section end in the symbol
2558;	                                //-- descriptor block.
2559;	{ let n := N - S; if n eq 0 do n := 0
2560;	  let t := 0
2561;	  t << STsd.Type := STsectket
2562;	  let Begin := SE - SDB; if Begin eq 0 do Begin := 0
2563;	  t << STsd.Name := Begin
2564;	  if t eq rv(N-1) resultis -1   // 2 adjacent entries identical.
2565;	  Store(t)
2566;	  resultis n
2567;	 }

2568;	and SymtabStoreArgs(Offset, Args) be
2569;	                                // Store the number of arguments of a
2570;	                                //-- function or routine.
2571;	(lv S|Offset) >> STsd.Args := Args eq 0 => 0, Args
2572;	                                // -0 is a bore.

2573;	and SymtabTransEnd() be         // Create symbol names block and
2574;	                                //-- structure block.
2575;	{ MakeEven(FillWord)            // Length of symbol descriptor block
2576;	                                //-- must be even.

2577;	  let SDN := N - B              // Length of the symbol descriptor
2578;	                                //-- block.
2579;	  S >> SThead.SDB := SDB
2580;	  S >> SThead.SDN := SDN
2581;	  B := N                        // Base of the next block.

2582;	// Scan through the symbol descriptor block processing structure
2583;	  //-- descriptors.
2584;	  for n := SDB step 2 to SDB + SDN - 2 do
2585;	                                          // Even locations only.
2586;	  { unless S|n << STsd.Type eq STstructure do loop

2587;	// Process only structure descriptors.

2588;	    let SDT := S|(n+1)          // The address of the structure
2589;	                                //-- definition table as stored in the
2590;	                                //-- AE-tree.
2591;	    let k := N - B; if k eq 0 do k := 0
2592;	                                 // Offset in the structure block where
2593;	                                 //-- the table will go.
2594;	    S|(n+1) := k                // Store it.
2595;	    Copy(SDT)                   // And finally, copy the table.
2596;	   }

2597;	  let StructN := N - B; if StructN eq 0 do StructN := 0
2598;	                                           // Length of structure
2599;	                                           //-- block.
2600;	  S >> SThead.StructB := B - S  // Base of the structure block.
2601;	  S >> SThead.StructN := StructN
2602;	                                // Its length.
2603;	  MakeEven(0)                   // Start the next table on an even
2604;	                                //-- word.  (Why??)
2605;	  B := N                        // The base of the next table.

2606;	// Copy the names into the name block, following the name chain through
2607;	  //-- the dictionary.

2608;	  let DE := NameChain << NC.c   // Address of the first name.
2609;	  until DE eq 0 do
2610;	  { for k := 1 to DE >> NC.n + 1 do Store(DE|k)
2611;	                                    // Copy the name.
2612;	    let OldDE := rv DE          // Save the old pointer.
2613;	    rv DE := 1                  // Restore the dictionary entry.
2614;	    DE := OldDE << NC.c         // Follow the chain.
2615;	   }
2616;	  unless N-B eq NextName do
2617;	  { BCPLreport(-1)
2618;	    Help("HELP!!! Trouble with Symbol Table. Help call in Main3")
2619;	   }                            // IMPOSSIBLE

2620;	  S >> SThead.NameB := B - S    // Base of the name block.
2621;	  S >> SThead.NameN := N - B    // Length of the name block.
2622;	  B := N
2623;	 }

2624;	and SymtabStoreILC(Offset, A, B) be
2625;	                                // Store blocka and blockb locations
2626;	                                //-- needed.
2627;	{ let P := S + Offset
2628;	  P >> STsd.ILCA := A           // Block A location of the beginning of
2629;	                                //-- the scope of the symbol.
2630;	  if P >> STsd.Type eq STstatic do P >> STsd.ILCB := B
2631;	 }

2632;	and SymtabStoreCommand(Line, A) be
2633;	{ structure
2634;	  { LineD                       // Descriptor of the datum in a LINE
2635;	                                //-- node in the tree.
2636;	    { bit 14
2637;	      SFD bit 4                 // Source file descriptor.  (Index in
2638;	                                //-- SFD.)
2639;	      Word bit 18               // Byte # in the source file.
2640;	     }
2641;	   }

2642;	  let t := 0                    // Create the entry here.
2643;	  t << STcdYYYYc.Type := STcdYYYYcommand
2644;	  t << STcdYYYYc.SFD := Line << LineD.SFD
2645;	                                // Offset of source file descriptor in
2646;	                                //-- SFD block.
2647;	  t << STcdYYYYc.Word := Line << LineD.Word
2648;	                                // Byte # in the source file...
2649;	  t << STcdYYYYc.ILCA := A      // Location in blocka where we enter
2650;	                                //-- command.
2651;	  Store(t)
2652;	 }

2653;	and SymtabStoreStack(Offset, ILCA) be
2654;	{ let t := 0                    // Build the entry here.
2655;	  t << STcdYYYYs.Type := STcdYYYYstack
2656;	  t << STcdYYYYs.Offset := Offset
2657;	  t << STcdYYYYs.ILCA := ILCA
2658;	  Store(t)
2659;	 }

2660;	and SymtabFinish(stn) be        // Close out the symbol table.
2661;	{                               // Declarations of manifests for file
2662;	                                //-- types, etc.

2663;	  if S < 0 return               // The file was never opened.

2664;	  S >> SThead.ComB := B - S     // Base of the command descriptor
2665;	                                //-- block.
2666;	  S >> SThead.ComN := N - B     // Its length.
2667;	  S >> SThead.Length := N - S   // Length of the symbol table.

2668;	  if SWbits << SW.Debug do
2669;	  { WriteS("Symbol table is "); WriteOct(N - S)
2670;	    WriteS(" words long.*n")
2671;	   }

2672;	  manifest
2673;	  { PageSize  := 512
2674;	   }                            // Clear to the next page boundary.
2675;	  until (N & (PageSize-1)) eq 0 do Store(0)

2676;	  { let t:=OUTPUT
2677;	    OUTPUT:=CreateOutput(stn,36)
2678;	    for i:=0 to N-1-S do PBOUT(S|i)
2679;	    EndWrite(OUTPUT)
2680;	    OUTPUT:=t
2681;	   }

2682;	 }

2683;	and Chain(Name) := valof        // Name is a word in the dictionary.
2684;	                                //-- Return its offset wrt NameB.
2685;	{ let DE := Name - 1            // The dictionary entry for the name.
2686;	  if DE >> NC.s do resultis DE >> NC.f

2687;	                                // Name already in NameB.

2688;	  let n := Name>>String.n / Bytesperword
2689;	                                // Number of words in the name, less 1.
2690;	  and f := NextName             // Current offset wrt NameB.
2691;	  NextName := NextName + n + 1
2692;	  LastName >> NC.c := DE        // Chain last name to this one.

2693;	  DE >> NC.s := true            // This entry is chained.
2694;	  DE >> NC.c := 0               // No chain yet.
2695;	  DE >> NC.n := n               // Number of words in the name.
2696;	  DE >> NC.f := f               // Offset wrt NameB.
2697;	  LastName := DE                // Remember where this is to chain it
2698;	                                //-- to the next entry.
2699;	  resultis f
2700;	 }

2701;	and Store(Word) be              // Store an entry in the next free
2702;	                                //-- location.
2703;	{ if N > BookEnd do
2704;	  { BCPLreport(240); SWbits << SW.Symtab := false; return
2705;	   }
2706;	  rv N := Word
2707;	  N := N + 1
2708;	 }

2709;	and Copy(SDT) be                // Copy a structure definition table.
2710;	{ let Length := 4 + q1 SDT|4    // Length of the node.
2711;	  and OldN := N                 // Keep track of where we are copying
2712;	                                //-- the thing.
2713;	  N := N + Length + 1           // Set N for recursive calls to Copy.
2714;	  if N > BookEnd do
2715;	  { let t:=SWbits
2716;	    BCPLreport(240); t << SW.Symtab := false; SWbits:=t ;return
2717;	   }
2718;	  OldN|0 := SDT|0 eq 0 => 0, Chain(SDT|0)
2719;	                                // The structure name.
2720;	  for k := 1 to 4 do OldN|k := SDT|k
2721;	                                // Store the first five words.
2722;	  for k := 5 to Length do { OldN|k := N-B; Copy(SDT|k) }

2723;	// Copy substructure nodes.
2724;	 }

2725;	and MakeEven(Fill) be           // Store a fill word if necessary to
2726;	                                //-- make N be even.
2727;	unless (N&1) eq 0 do Store(Fill)


		CAE0.BCP;4


2728;	// BCPL Compiler -- CAE Main Program.

2729;	// ConstructTree Construct the AE-tree.
2730;	// CAEreport Error report for CAE.

2731;	get "<xbcpl>headcae"
2732;	get "<bcpl>head"
2733;	get "<bcpl>utilhead"

2734;	//Home base for the following statics
2735;	static
2736;	{ Symb:      0
2737;	  B:         0
2738;	  Chkind:    0
2739;	  LineP:     0
2740;	  GetV:      0
2741;	  GetP:      0
2742;	  LineV:     0
2743;	  WUPFLG:    0
2744;	  NILNODE:   0
2745;	  V:         0
2746;	  ERRORNAME: 0
2747;	  TRUENODE:  0
2748;	  FALSENODE: 0
2749;	 }

2750;	//local static
2751;	static
2752;	{ LastCharPtr : -1
2753;	 }                              // Line pointer for last error message.

2754;	let ConstructTree(LvTree,fn) be // Translate the source code, storing
2755;	                                //-- the result into rv LvTree.
2756;	{ let v := vec LineT
2757;	  LastCharPtr:=-1
2758;	  GetP,GetV:=0,0
2759;	  LineV := v                    // Store each line here as it is read,
2760;	                                //-- for CAEreport.
2761;	  for n := 1 to LineT do LineV|n := 0
2762;	  LineV|0 := $*n

2763;	  let v := vec GetT; GetV := v  // Keep track of nested "get" files.
2764;	  let v := vec Vmax; V := v     // Nextsymb reads names and numbers
2765;	                                //-- here.

2766;	  TRUENODE := List2(TRUE,true)
2767;	  FALSENODE := List2(FALSE, false)
2768;	  NILNODE := List2(NIL, 0)
2769;	  ERRORNAME := List2(NAME, "ERRORNAME")
2770;	                                // Used to make a legal tree when a
2771;	                                //-- name is missing.

2772;	  if SWbits << SW.Help do Help("Stopped before first OpenSource (inside ConstructTree)*n")

2773;	  OpenSource(fn)                // Open the initial source file.
2774;	  Nextsymb()

2775;	  if SWbits << SW.Pprep do      // Repeat preprocessor.
2776;	  { PBOUT($*n)
2777;	    { WriteOct(Symb)
2778;	      switchon Symb into
2779;	      { case STRINGCONST:
2780;	        case SECTBRA:
2781;	        case SECTKET:     PBOUT($*t); WriteS(lv V|1); endcase

2782;	        case NUMBER:
2783;	        case CHARCONST:   PBOUT($*t); WriteN(V|0); endcase

2784;	        case NAME:        PBOUT($*t); WriteS(V|0); PBOUT($*t)
2785;	                          WriteOct(V|0)
2786;	        default:
2787;	       }
2788;	      PBOUT($*n)
2789;	      Nextsymb()
2790;	     }
2791;	    repeatuntil Symb eq END
2792;	    return
2793;	   }

2794;	l:
2795;	  rv LvTree := Readblockbody()  // DO THE WORK.

2796;	  unless Symb eq END do
2797;	  { if rv LvTree=0 do
2798;	    {
2799;	      { Nextsymb()
2800;	       }
2801;	      repeatuntil Symb=END \ Symb=AND
2802;	      if Symb=END do goto ll
2803;	      Symb:=LET
2804;	      goto l
2805;	     }
2806;	  ll:
2807;	    CAEreport(99)
2808;	    if Symb=AND do
2809;	    { CAEreport(36)
2810;	      Symb:=LET
2811;	      goto l
2812;	     }
2813;	   }
2814;	  JNDRD(INPUT)
2815;	 }

2816;	and CAEreport(n) be
2817;	{ BCPLreport(lh n < -1 => rh n, n)
2818;	  let CharPtr := LinePtr()
2819;	  test LineV|LineP eq $*e
2820;	  ifso WriteS(" at end of file*n*n")
2821;	  ifnot test CharPtr eq LastCharPtr
2822;	        ifso WriteS(" at same place*n")
2823;	        ifnot
2824;	        { LastCharPtr := CharPtr
2825;	                                // Remember where this error occurred.
2826;	          unless Curfile eq 0 do
2827;	                                 // Identify any file other than the
2828;	                                 //-- initial one.
2829;	          { WriteS(" in file "); WriteS(rh GetnameV|Curfile)
2830;	            PBOUT($*n)
2831;	           }
2832;	          let i, j := LineP, -1
2833;	          WriteS(" at*n")       // Skip up to next newline.
2834;	          { i := i+1
2835;	            if i > LineT do i := 0
2836;	            if LineV|i eq $*n do { j := i; LineV|i := 0; break }
2837;	            if i eq LineP do { WriteS("..."); break }
2838;	           }
2839;	          repeat                // Print last few lines.
2840;	          { i := i+1
2841;	            if i > LineT do i := 0
2842;	            PBOUT(LineV|i)
2843;	            if LineV|i eq $*n do { j := i; LineV|i := 0 }
2844;	           }
2845;	          repeatuntil i eq LineP
2846;	          unless j eq -1 do LineV|j := $*n
2847;	          PBOUT($*n)
2848;	         }
2849;	  if lh n < -1 do BCPLreport(lh n ,, 0)
2850;	 }


		CAE1.BCP;3


2851;	// BCPL Compiler -- CAE Part 1.

2852;	// Readblockbody   Read the body of a block.
2853;	// Rblock          Read a block.
2854;	// *Rextlist        Read external list.
2855;	// Rnamelist       Read a name list.
2856;	// EqVec           Test two vectors for equality.
2857;	// * => local to this file.

2858;	get "<xbcpl>headcae"
2859;	get "<bcpl>head"

2860;	let Readblockbody() := valof
2861;	{ let A, B, Cdefs, Op := 0, nil, 0, nil
2862;	  let Thisline := LinePtr()
2863;	  switchon Symb into
2864;	  { case MANIFEST:
2865;	    case STATIC:
2866;	    case INDEX:
2867;	    case GLOBAL:
2868;	                    { let V1 := vec BRACKETLABEL
2869;	                      Op := Symb
2870;	                      Nextsymb()
2871;	                      unless Symb eq SECTBRA do
2872;	                      { CAEreport(2); resultis 0
2873;	                       }
2874;	                      for k := 0 to V|0 do V1|k := V|k
2875;	                      { Nextsymb()
2876;	                        let TL := LinePtr()
2877;	                                // Pointer into source text.
2878;	                        test Symb eq NAME
2879;	                        ifso A := List2(NAME, V|0)
2880;	                        ifnot { CAEreport(1); A := ERRORNAME }
2881;	                        Nextsymb()
2882;	                        unless Symb eq ASS \ Symb eq COLON
2883;	                        do CAEreport(3)
2884;	                        Nextsymb()
2885;	                        B := Rexp(0)
2886;	                        Cdefs := List4(CONSTDEF, Cdefs, A, B)
2887;	                        Cdefs := List3(LINE, TL, Cdefs)
2888;	                       }
2889;	                      repeatwhile Symb eq SEMICOLON
2890;	                      unless Symb eq SECTKET do
2891;	                      { CAEreport(4); resultis 0
2892;	                       }
2893;	                      test EqVec(V1) then Nextsymb()
2894;	                      or CAEreport(4,,69)
2895;	                     }
2896;	                    A := Readblockbody()
2897;	                    A := List3(Op, Cdefs, A)
2898;	                    resultis List3(LINE, Thisline, A)

2899;	    case STRUCTURE:             // A structure declaration.
2900;	                    { let V1 := vec BRACKETLABEL
2901;	                      Nextsymb()
2902;	                      unless Symb eq SECTBRA do
2903;	                      { CAEreport(2); resultis 0
2904;	                       }
2905;	                      for k := 0 to V|0 do V1|k := V|k
2906;	                      Nextsymb()
2907;	                      A := Rstruct(0)
2908;	                                // Read the declaration.
2909;	                      unless Symb eq SECTKET do
2910;	                      { CAEreport(4); resultis 0
2911;	                       }
2912;	                      test EqVec(V1) then Nextsymb()
2913;	                      or CAEreport(4,,69)
2914;	                     }
2915;	                    B := Readblockbody()
2916;	                    A := List3(STRUCTURE, A, B)
2917;	                    resultis List3(LINE, Thisline, A)

2918;	    case LET:       Nextsymb()
2919;	                    A := Rdef()
2920;	                    B := Readblockbody()
2921;	                    A := List3(LET, A, B)
2922;	                    resultis List3(LINE, Thisline, A)

2923;	    case EXT:
2924;	                    { let V1 := vec BRACKETLABEL
2925;	                      Nextsymb()
2926;	                      unless Symb eq SECTBRA do
2927;	                      { CAEreport(2); resultis 0
2928;	                       }
2929;	                      for k := 0 to V|0 do V1|k := V|k
2930;	                      Nextsymb()
2931;	                      A := Rextlist()
2932;	                      unless Symb eq SECTKET do
2933;	                      { CAEreport(4); resultis 0
2934;	                       }
2935;	                      test EqVec(V1) then Nextsymb()
2936;	                      or CAEreport(4,,69)
2937;	                     }
2938;	                    B := Readblockbody()
2939;	                    A := List3(EXT, A, B)
2940;	                    resultis List3(LINE, Thisline, A)

2941;	    case SECTKET:
2942;	    case END:       resultis A

2943;	    case SEMICOLON: Nextsymb()
2944;	                    resultis Readblockbody()

2945;	    default:        A := Rcom(Readblockbody)
2946;	                    while Symb eq SEMICOLON do
2947;	                    { Nextsymb()
2948;	                      B := Readblockbody()
2949;	                      A := List3(SEQ, A, B)
2950;	                     }
2951;	                    resultis A
2952;	   }
2953;	 }

2954;	and Rblock() := valof
2955;	{ let V1 := vec BRACKETLABEL
2956;	  unless Symb eq SECTBRA do { CAEreport(6); resultis 0 }
2957;	  for k := 0 to V|0 do V1|k := V|k
2958;	  Nextsymb()
2959;	  let A := Readblockbody()
2960;	  unless Symb eq SECTKET do
2961;	  { CAEreport(Symb eq END => 98, 7)
2962;	    Nextsymb()
2963;	    resultis A
2964;	   }
2965;	  test EqVec(V1) then Nextsymb()
2966;	  or CAEreport(4,,69)
2967;	  resultis A
2968;	 }

2969;	and Rextlist() := valof
2970;	{ unless Symb eq NAME do
2971;	  { CAEreport(8)
2972;	    Nextsymb()
2973;	    resultis ERRORNAME
2974;	   }
2975;	  let A := List2(NAME, V|0)
2976;	  Nextsymb()
2977;	  unless Symb eq SEMICOLON resultis A
2978;	  Nextsymb()
2979;	  let B := Rextlist()
2980;	  resultis List3(COMMA, A, B)
2981;	 }

2982;	and Rnamelist() := valof
2983;	{ let A, B := nil, nil
2984;	  test Symb eq NIL
2985;	  then
2986;	  { A := NILNODE
2987;	    Nextsymb()
2988;	    if Symb eq REPNAME \ Symb eq REPVAL do
2989;	    { Nextsymb()
2990;	      B := Rexp(12)
2991;	      A := List3(REPNAME, A, B)
2992;	     }
2993;	   }
2994;	  or
2995;	  { unless Symb eq NAME do
2996;	    { CAEreport(8)
2997;	      Nextsymb()
2998;	      resultis ERRORNAME
2999;	     }
3000;	    A := List2(NAME, V|0)
3001;	    Nextsymb()
3002;	   }
3003;	  unless Symb eq COMMA resultis A
3004;	  Nextsymb()
3005;	  B := Rnamelist()
3006;	  resultis List3(COMMA, A, B)
3007;	 }

3008;	and EqVec(v) := valof
3009;	{ for k := 0 to v|0 if v|k ne V|k resultis false
3010;	  resultis true
3011;	 }



		CAE2.BCP;3


3012;	// BCPL Compiler -- Part 2 of CAE.

3013;	// Rexp The main expression reader.

3014;	get "<xbcpl>headcae"
3015;	get "<bcpl>head"

3016;	let Rexp(n) := valof
3017;	{ let A, B, C, Op := nil, nil, nil, nil

3018;	  if Symb=NAME \ Symb=RNAME do  // This is the usual case, so give it
3019;	                                //-- fast service.
3020;	  { A := List2(Symb, V|0); Nextsymb()
3021;	    goto L
3022;	   }

3023;	// Read the next operand, and store it into A.

3024;	  switchon Symb into            // Branch on the leading operand of the
3025;	                                //-- expression.
3026;	  { default:          CAEreport(32)
3027;	                      Nextsymb()
3028;	                      resultis List2(NUMBER, 0)

3029;	    case STRINGCONST:
3030;	    case ASCIZCONST:  A := Newvec(1 + V|0)
3031;	                      A|0 := Symb; for k := 1 to V|0 do A|k := V|k
3032;	                      Nextsymb()
3033;	                      endcase

3034;	    case CHARCONST:   A := List2(CHARCONST, V|0)
3035;	                      Nextsymb()
3036;	                      endcase

3037;	    case NUMBER:      A := List2(NUMBER, V|0)
3038;	                      Nextsymb()
3039;	                      endcase

3040;	    case NIL:         A := NILNODE; Nextsymb(); endcase

3041;	    case TRUE:        A := TRUENODE; Nextsymb(); endcase

3042;	    case FALSE:       A := FALSENODE; Nextsymb(); endcase

3043;	    case NUMBARGS:
3044;	    case LEFTSIDE:    unless SWbits << SW.Ncs do CAEreport(36)

3045;	    case ERROR:       A := List1(Symb)
3046;	                      Nextsymb()
3047;	                      endcase

3048;	    case RBRA:        Nextsymb()
3049;	                      A := Rexp(0)
3050;	                      unless Symb eq RKET do CAEreport(15)
3051;	                      Nextsymb()
3052;	                      endcase

3053;	    case VALOF:       Nextsymb()
3054;	                      A := Rcom(Rcom)
3055;	                      A := List2(VALOF, A)
3056;	                      endcase

3057;	    case SELECTON:
3058;	                      { Nextsymb()
3059;	                        A := Rexp(0)
3060;	                        unless Symb eq INTO do CAEreport(60)
3061;	                        Nextsymb()
3062;	                        unless Symb eq SECTBRA do
3063;	                        { CAEreport(66)
3064;	                          Nextsymb()
3065;	                          resultis List2(NUMBER, 0)
3066;	                         }
3067;	                        let V1 := vec BRACKETLABEL
3068;	                        for k := 0 to V|0 do V1|k := V|k
3069;	                        Nextsymb()
3070;	                        B := Rselect(false)
3071;	                        test Symb eq SECTKET
3072;	                        ifso test EqVec(V1) then Nextsymb()
3073;	                             or CAEreport(4,,69)
3074;	                        ifnot { CAEreport(67); Nextsymb() }
3075;	                        A := List3(SWITCHON, A, B)
3076;	                        A := List2(VALOF, A)
3077;	                        endcase
3078;	                       }

3079;	    case CSIZE:                 // number of address units in a
3080;	                                //-- structure item
3081;	    case SIZE:                  // Size of a structure item.
3082;	    case OFFSET:                // Offset of a structure item
3083;	                      Op := Symb
3084;	                      A := List2(Op, Rqualname())
3085;	                      endcase

3086;	    case LH:
3087;	    case RH:
3088;	    case Q1:
3089;	    case Q2:
3090;	    case Q3:
3091;	    case Q4:
3092;	    case LHZ:
3093;	    case RHZ:
3094;	    case Q1Z:
3095;	    case Q2Z:
3096;	    case Q3Z:
3097;	    case Q4Z:
3098;	    case LV:
3099;	    case RV:          Op := Symb
3100;	                      Nextsymb()
3101;	                      A := Rexp(35)
3102;	                      A := List2(Op, A)
3103;	                      endcase

3104;	    case PLUS:        Nextsymb()
3105;	                      A := Rexp(35)
3106;	                      endcase

3107;	    case MINUS:       Nextsymb()
3108;	                      A := Rexp(35)
3109;	                      A := List2(NEG, A)
3110;	                      endcase

3111;	    case VEC:         Nextsymb()
3112;	                      A := Rexp(30)
3113;	                      A := List2(VEC, A)
3114;	                      endcase

3115;	    case FPLUS:       Nextsymb()
3116;	                      A := Rexp(35)
3117;	                      endcase

3118;	    case FMINUS:      Nextsymb()
3119;	                      A := Rexp(35)
3120;	                      A := List2(FNEG, A)
3121;	                      endcase

3122;	    case NOT:         Nextsymb()
3123;	                      A := Rexp(25)
3124;	                      A := List2(NOT, A)
3125;	                      endcase

3126;	    case LIST:
3127;	    case TABLE:       Op := Symb
3128;	                      Nextsymb()
3129;	                      A := Rexp(11)
3130;	                      A := List2(Op, A)
3131;	                      endcase

3132;	   }

3133;	L:                              // An operand has been read.  Now look
3134;	                                //-- at the next operator.
3135;	  switchon Symb into
3136;	  { default:        resultis A

3137;	    case NAME:                  // Not legal BCPL, but a common error.
3138;	                    CAEreport(45)
3139;	                    B := List2(NAME, V|0)
3140;	                    Nextsymb()
3141;	                    resultis List3(FNAP, A, B)

3142;	    case RBRA:      Nextsymb()
3143;	                    test Symb eq RKET
3144;	                                // Have empty parentheses been scanned?
3145;	                    ifso B := 0 // Yes.
3146;	                    ifnot
3147;	                    { B := Rexp(0)
3148;	                      unless Symb eq RKET do CAEreport(19)
3149;	                     }          // No, so read parameters.
3150;	                    Nextsymb()
3151;	                    A := List3(FNAP, A, B)
3152;	                    goto L

3153;	    case VECAP:     if n ge 40 resultis A
3154;	                    Nextsymb()
3155;	                    B := Rexp(40)
3156;	                    A := List3(VECAP, A, B)
3157;	                    goto L

3158;	    case LEFTLUMP:
3159;	    case RIGHTLUMP: if n ge 38 resultis A
3160;	                    Op := Symb
3161;	                    B := Rqualname()
3162;	                    A := List3(Op, A, B)
3163;	                    goto L

3164;	    case DIV:
3165;	    case REM:
3166;	    case MULT:      if n ge 35 resultis A
3167;	                    Op := Symb
3168;	                    Nextsymb()
3169;	                    B := Rexp(34)
3170;	                    A := List3(Op, A, B)
3171;	                    goto L

3172;	    case PLUS:
3173;	    case MINUS:     if n ge 34 resultis A
3174;	                    Op := Symb
3175;	                    Nextsymb()
3176;	                    B := Rexp(34)
3177;	                    A := List3(Op, A, B)
3178;	                    goto L

3179;	    case FPLUS:
3180;	    case FMINUS:    if n ge 34 resultis A
3181;	                    Op := Symb
3182;	                    Nextsymb()
3183;	                    B := Rexp(34)
3184;	                    A := List3(Op, A, B)
3185;	                    goto L

3186;	    case FMULT:
3187;	    case FDIV:      if n ge 35 resultis A
3188;	                    Op := Symb
3189;	                    Nextsymb()
3190;	                    B := Rexp(34)
3191;	                    A := List3(Op, A, B)
3192;	                    goto L

3193;	    case FLS:
3194;	    case FEQ:
3195;	    case FGR:

3196;	    case EQ:
3197;	    case NE:
3198;	    case LS:
3199;	    case GR:
3200;	    case LE:
3201;	    case GE:        if n ge 30 resultis A
3202;	                    C := 0
3203;	                    { Op := Symb
3204;	                      Nextsymb()
3205;	                      B := Rexp(30)
3206;	                      A := List3(Op, A, B)
3207;	                      C := C eq 0 => A, List3(LOGAND, C, A)
3208;	                      switchon Symb into
3209;	                      { default:
3210;	                                // All done unless it"s an extended
3211;	                                //-- relation.
3212;	                          A := C
3213;	                          goto L

3214;	                        case EQ:
3215;	                        case NE:
3216;	                        case LS:
3217;	                                // It"s an extended relation.
3218;	                        case GR:
3219;	                        case LE:
3220;	                        case GE:
3221;	                        case FLS:
3222;	                        case FEQ:
3223;	                        case FGR:
3224;	                       }
3225;	                      A := B
3226;	                     }
3227;	                    repeat

3228;	    case LSHIFT:
3229;	    case LSCALE:
3230;	    case RSHIFT:
3231;	    case RSCALE:    if n ge 25 resultis A
3232;	                    Op := Symb
3233;	                    Nextsymb()
3234;	                    B := Rexp(30)
3235;	                    A := List3(Op, A, B)
3236;	                    goto L

3237;	    case LOGAND:    if n ge 24 resultis A
3238;	                    Nextsymb()
3239;	                    B := Rexp(23)
3240;	                    A := List3(LOGAND, A, B)
3241;	                    goto L

3242;	    case LOGOR:     if n ge 23 resultis A
3243;	                    Nextsymb()
3244;	                    B := Rexp(22)
3245;	                    A := List3(LOGOR, A, B)
3246;	                    goto L

3247;	    case EQV:
3248;	    case NEQV:
3249;	    case EQUIV:
3250;	    case NEQUIV:                // ::::::: ::::::: ::::::: :::::::
3251;	                    if n ge 22 resultis A
3252;	                    Op := Symb
3253;	                    Nextsymb()
3254;	                    B := Rexp(22)
3255;	                    A := List3(Op, A, B)
3256;	                    goto L

3257;	    case COND:      if n ge 13 resultis A
3258;	                    Nextsymb()
3259;	                    B := Rexp(12)
3260;	                    unless Symb eq COMMA do CAEreport(30)
3261;	                    Nextsymb()
3262;	                    C := Rexp(12)
3263;	                    A := List4(COND, A, B, C)
3264;	                    goto L

3265;	    case COMCOM:    if n ge 14 resultis A
3266;	                    Nextsymb()
3267;	                    B:=Rexp(13)
3268;	                    A:=List3(COMCOM,A,B)
3269;	                    goto L

3270;	    case REPNAME:
3271;	    case REPVAL:    if n ge 12 resultis A
3272;	                    Op := Symb
3273;	                    Nextsymb()
3274;	                    B := Rexp(12)
3275;	                    A := List3(Op, A, B)
3276;	                    goto L

3277;	    case COMMA:     if n ge 12 resultis A
3278;	                    Nextsymb()
3279;	                    B := Rexp(11)
3280;	                    A := List3(COMMA, A, B)
3281;	                    goto L
3282;	   }
3283;	 }


		CAE3.BCP;3


3284;	// BCPL Compiler -- Part 3 of CAE.

3285;	// Rdef  Read a definition, returning the node thus produced.
3286;	// Rcom  Read a command.
3287;	// Rselect  Read a switchon block.

3288;	get "<xbcpl>headcae"
3289;	get "<bcpl>head"

3290;	let Rdef() := valof
3291;	{ let A, B, Op := 0, nil, nil
3292;	  and Thisline := LinePtr()
3293;	  let N := Rnamelist()
3294;	  switchon Symb into            // What comes after the name list?
3295;	  { case RBRA:                  // A name.  It is a function or routine
3296;	                                //-- definition.
3297;	      Nextsymb()
3298;	      unless H1|N eq NAME do CAEreport(40)
3299;	                                // It is necessary that the name list
3300;	                                //-- was a name.
3301;	      if Symb eq NAME \ Symb eq NIL do A := Rnamelist()
3302;	                                       // Formal parameters.
3303;	      unless Symb eq RKET do CAEreport(41)
3304;	      Nextsymb()
3305;	      if Symb eq BE do          // It"s a routine definition.
3306;	      { Nextsymb()
3307;	        B := Rcom(Rcom)
3308;	        A := List5(RTDEF, N, A, B, 0)
3309;	                                // Last cell is used in Trans as a
3310;	                                //-- temp.
3311;	        endcase
3312;	       }
3313;	      if Symb eq ASS do         // It"s a function definition.
3314;	      { Nextsymb()
3315;	        B := Rexp(0)
3316;	        A := List5(FNDEF, N, A, B, 0)
3317;	                                // Last cell is used in Trans as a
3318;	                                //-- temp.
3319;	        endcase
3320;	       }
3321;	      CAEreport(42)
3322;	      A := List4(VALDEF, N, List2(NUMBER, 0), 0)
3323;	                                // Extra cell to hold count in Trans.
3324;	      endcase

3325;	    default:
3326;	      CAEreport(44)

3327;	    case ASS:
3328;	      Nextsymb()
3329;	      A := Rexp(0)
3330;	      A := List4(VALDEF, N, A, 0)
3331;	                                // Extra cell to hold count in Trans.

3332;	   }

3333;	  A := List3(LINE, Thisline, A)
3334;	  if Symb eq AND do
3335;	  { Nextsymb()
3336;	    if Symb eq LET do Nextsymb()
3337;	    B := Rdef()
3338;	    resultis List3(AND, A, B)
3339;	   }
3340;	  resultis A
3341;	 }

3342;	and Rcom(Nextfn) := valof
3343;	{ let A, B, C, Op := nil, nil, nil, nil
3344;	  let Thisline := LinePtr()

3345;	  switchon Symb into
3346;	  { default:          resultis 0

3347;	    case RNAME:
3348;	    case ASCIZCONST:
3349;	    case LHZ:
3350;	    case RHZ:
3351;	    case Q1Z:
3352;	    case Q2Z:
3353;	    case Q3Z:
3354;	    case Q4Z:
3355;	    case NAME:
3356;	    case NUMBER:
3357;	    case STRINGCONST:
3358;	    case CHARCONST:
3359;	    case FPLUS:
3360;	    case FMINUS:
3361;	    case LH:
3362;	    case RH:
3363;	    case Q1:
3364;	    case Q2:
3365;	    case Q3:
3366;	    case Q4:
3367;	    case NUMBARGS:
3368;	    case LEFTSIDE:
3369;	    case NOT:
3370;	    case SELECTON:
3371;	    case TRUE:
3372;	    case FALSE:
3373;	    case LV:
3374;	    case RV:
3375;	    case RBRA:
3376;	    case VALOF:
3377;	    case PLUS:
3378;	    case MINUS:
3379;	    case CSIZE:
3380;	    case SIZE:                  // These are all the symbols which can
3381;	                                //-- start an expression.
3382;	                      A := Rexp(0)
3383;	                      if Symb eq ASS do
3384;	                      { Nextsymb()
3385;	                        B := Rexp(0)
3386;	                        A := List3(ASS, A, B)
3387;	                        endcase
3388;	                       }
3389;	                      if Symb eq COLON do
3390;	                      { unless H1|A eq NAME do CAEreport(50)
3391;	                        Nextsymb()
3392;	                        B := Nextfn(Nextfn)
3393;	                        A := List4(COLON, A, B, 0)
3394;	                                // Last cell is used in Trans to hold a
3395;	                                //-- label.
3396;	                        endcase
3397;	                       }
3398;	                      if H1|A eq FNAP do { H1|A := RTAP; endcase }
3399;	                      CAEreport(51)
3400;	                      A := List3(ASS, ERRORNAME, A)
3401;	                      endcase

3402;	    case GOTO:
3403;	    case RESULTIS:    Op := Symb
3404;	                      Nextsymb()
3405;	                      A := Rexp(0)
3406;	                      A := List2(Op, A)
3407;	                      endcase

3408;	    case IF:
3409;	    case UNLESS:
3410;	    case WHILE:
3411;	    case UNTIL:       Op := Symb
3412;	                      Nextsymb()
3413;	                      A := Rexp(0)
3414;	                      if Op eq UNTIL \ Op eq WHILE
3415;	                      do A := List3(LINE, Thisline, A)
3416;	                      unless Symb eq DO do CAEreport(52)
3417;	                      Nextsymb()
3418;	                      B := Rcom(Rcom)
3419;	                      A := List3(Op, A, B)
3420;	                      endcase

3421;	    case TEST:        Nextsymb()
3422;	                      A := Rexp(0)
3423;	                      test Symb eq IFNOT
3424;	                      then
3425;	                      { Nextsymb()
3426;	                        C := Rcom(Rcom)
3427;	                        unless Symb eq IFSO do CAEreport(55)
3428;	                        Nextsymb()
3429;	                        B := Rcom(Rcom)
3430;	                       }
3431;	                      or
3432;	                      { unless Symb eq DO \ Symb eq IFSO
3433;	                        do CAEreport(53)
3434;	                        Nextsymb()
3435;	                        B := Rcom(Rcom)
3436;	                        unless Symb eq OR \ Symb eq IFNOT
3437;	                        do CAEreport(54)
3438;	                        Nextsymb()
3439;	                        C := Rcom(Rcom)
3440;	                       }
3441;	                      A := List4(TEST, A, B, C)
3442;	                      endcase

3443;	    case FOR:
3444;	                      { Nextsymb()
3445;	                        test Symb eq NAME
3446;	                        then A := List2(NAME, V|0)
3447;	                        or { CAEreport(64); A := ERRORNAME }
3448;	                        Nextsymb()
3449;	                        unless Symb eq ASS do CAEreport(57)
3450;	                        Nextsymb()
3451;	                        let L, U, S := nil, nil, 0
3452;	                                // Lower limit, upper limit, step size.
3453;	                        L := Rexp(0)
3454;	                        test Symb eq BY
3455;	                        then
3456;	                        { Nextsymb()
3457;	                          S := Rexp(0)
3458;	                          unless Symb eq TO do CAEreport(58)
3459;	                          Nextsymb()
3460;	                          U := Rexp(0)
3461;	                         }
3462;	                        or
3463;	                        { unless Symb eq TO do CAEreport(58)
3464;	                          Nextsymb()
3465;	                          U := Rexp(0)
3466;	                          if Symb eq BY do
3467;	                          { Nextsymb(); S := Rexp(0)
3468;	                           }
3469;	                         }
3470;	                        unless Symb eq DO do CAEreport(59)
3471;	                        Nextsymb()
3472;	                        B := Rcom(Rcom)
3473;	                        A := List6(FOR, A, L, U, S, B)
3474;	                        endcase
3475;	                       }

3476;	    case ENDCASE:
3477;	    case LOOP:
3478;	    case BREAK:
3479;	    case FINISH:
3480;	    case ABORT:
3481;	    case RETURN:      A := List1(Symb)
3482;	                      Nextsymb()
3483;	                      endcase

3484;	    case SWITCHON:
3485;	    case BRANCHON:    Op := Symb
3486;	                      Nextsymb()
3487;	                      A := List3(LINE, Thisline, Rexp(0))
3488;	                      unless Symb eq INTO do CAEreport(60)
3489;	                      Nextsymb()
3490;	                      B := Rblock()
3491;	                      A := List3(Op, A, B)
3492;	                      endcase

3493;	    case CASE:        Nextsymb()
3494;	                      A := Rexp(0)
3495;	                      test Symb eq TO
3496;	                                // Case label with limits?
3497;	                      then { Nextsymb(); C := Rexp(0) }
3498;	                      or C := 0
3499;	                      unless Symb eq COLON do CAEreport(61)
3500;	                      Nextsymb()
3501;	                      B := Nextfn(Nextfn)
3502;	                      A :=
3503;	                        C eq 0 => List4(CASE, A, B, Thisline),
3504;	                        List5(CASETO, A, C, B, Thisline)
3505;	                      endcase

3506;	    case DEFAULT:     Nextsymb()
3507;	                      unless Symb eq COLON do CAEreport(62)
3508;	                      Nextsymb()
3509;	                      A := Nextfn(Nextfn)
3510;	                      A := List2(DEFAULT, A)
3511;	                      endcase

3512;	    case SECTBRA:     A := Rblock()
3513;	   }

3514;	L:
3515;	  switchon Symb into
3516;	  { default:          resultis List3(LINE, Thisline, A)

3517;	    case REPEAT:      Nextsymb()
3518;	                      A := List2(REPEAT, A)
3519;	                      goto L

3520;	    case REPEATWHILE:
3521;	    case REPEATUNTIL:
3522;	                      { let LP := LinePtr()
3523;	                        Op := Symb
3524;	                        Nextsymb()
3525;	                        B := Rexp(0)
3526;	                        B := List3(LINE, LP, B)
3527;	                        A := List3(Op, A, B)
3528;	                        goto L
3529;	                       }
3530;	   }
3531;	 }

3532;	and Rselect(ExpOK) := valof
3533;	{ let a, b := nil, nil
3534;	  let ThisLine := LinePtr()
3535;	  if Symb eq DEFAULT do
3536;	  { Nextsymb()
3537;	    unless Symb eq COLON do CAEreport(62)
3538;	    Nextsymb()
3539;	    a := Rselect(true)
3540;	    resultis List3(LINE, ThisLine, List2(DEFAULT, a))
3541;	   }
3542;	  if Symb eq CASE do
3543;	  { let c := 0
3544;	    Nextsymb()
3545;	    a := Rexp(0)
3546;	    if Symb eq TO do { Nextsymb(); c := Rexp(0) }
3547;	                                // Case label with limits.
3548;	    unless Symb eq COLON do CAEreport(61)
3549;	    Nextsymb()
3550;	    b := Rselect(true)
3551;	    a :=
3552;	      c eq 0 => List4(CASE, a, b, ThisLine),
3553;	      List5(CASETO, a, c, b, ThisLine)
3554;	    resultis List3(LINE, ThisLine, a)
3555;	   }
3556;	  unless ExpOK do CAEreport(68)
3557;	  a := Rexp(0)
3558;	  a := List2(RESULTIS, a)
3559;	  unless Symb eq SEMICOLON resultis List3(LINE, ThisLine, a)
3560;	  Nextsymb()
3561;	  b := Rselect(false)
3562;	  a := List3(SEQ, a, b)
3563;	  resultis List3(LINE, ThisLine, a)
3564;	 }


		CAE4.BCP;3


3565;	// BCPL Compiler -- Part 4 of CAE.

3566;	// Rstruct       --  Read a structure declaration.
3567;	// Rqualname     --  Read a qualified name (a structure reference).
3568;	// *IsStructItem  --  Is parameter a structure declarator, such as BIT?
3569;	// * => local to this compilation only.

3570;	get "<xbcpl>headcae"
3571;	get "<bcpl>head"

3572;	// Read a structure declaration with precedence P.  If P _ 1, stop on
3573;	//-- encountering OVERLAY,
3574;	// while if P _ 0 keep reading to the next SECTKET.

3575;	let Rstruct(P) := valof
3576;	{ let ThisLine := LinePtr()
3577;	  let Name, Rep, Count := 0, 0, 0
3578;	  let A, B := nil, nil

3579;	  if Symb eq FILL do
3580;	  { Nextsymb()
3581;	    unless IsStructItem(Symb) do
3582;	    { CAEreport(167); A := List2(FILL, WORD); goto ReadMore
3583;	     }
3584;	    let SI := Symb
3585;	    Nextsymb()
3586;	    A := List2(FILL, SI)
3587;	    goto ReadMore
3588;	   }

3589;	  if Symb eq NAME do
3590;	  { Name := List2(NAME, V|0)
3591;	    Nextsymb()
3592;	    if Symb eq UPLUMP do
3593;	    { Nextsymb()
3594;	      let L := Rexp(0)          // Read the limit.
3595;	      test Symb eq UPLUMP       // Is there a second limit?
3596;	      then { Nextsymb(); Rep := List3(REP, L, Rexp(0)) }
3597;	                                // Yes, so read it.
3598;	      or Rep := List3(REP, 0, L)
3599;	                                // No.
3600;	     }
3601;	   }

3602;	  if IsStructItem(Symb) do
3603;	  { let SI := Symb
3604;	    Nextsymb()
3605;	    unless Symb eq SECTKET \ Symb eq OVERLAY \ Symb eq SEMICOLON
3606;	    do Count := Rexp(0)
3607;	    A := List5(SDATOM, Name, Rep, SI, Count)
3608;	    goto ReadMore
3609;	   }

3610;	  if Symb eq SEMICOLON do Nextsymb()
3611;	                                // Semicolon is optional here.
3612;	  unless Symb eq SECTBRA do { CAEreport(160); resultis 0 }

3613;	  { let V1 := vec BRACKETLABEL
3614;	    for k := 0 to V|0 do V1|k := V|k
3615;	    Nextsymb()
3616;	    A := Rstruct(0)
3617;	    test Symb eq SECTKET
3618;	    ifso test EqVec(V1) then Nextsymb()
3619;	         or CAEreport(4,,69)
3620;	    ifnot CAEreport(5)
3621;	    A := List4(SD, Name, Rep, A)
3622;	   }

3623;	ReadMore:                       // Come here to keep reading.
3624;	  switchon Symb into
3625;	  { case SEMICOLON:
3626;	                    { if P > 0 resultis A
3627;	                      Nextsymb()
3628;	                      let L := LinePtr()
3629;	                      B := Rstruct(0)
3630;	                      A := List3(SEQ, A, List3(LINE, L, B))
3631;	                      goto ReadMore
3632;	                     }

3633;	    case OVERLAY:
3634;	                    { if P > 0 resultis A
3635;	                      Nextsymb()
3636;	                      let L := LinePtr()
3637;	                      B := Rstruct(1)
3638;	                      A := List3(OVERLAY, A, List3(LINE, L, B))
3639;	                      goto ReadMore
3640;	                     }

3641;	    case SECTKET:   resultis List3(LINE, ThisLine, A)

3642;	    default:        CAEreport(161)
3643;	                                // CAN WE DO BETTER ABOUT
3644;	                                //-- THISAAAA?AAAA?AAAA?
3645;	                    resultis ERRORNAME

3646;	                                // I THINK WE WILL GET A BETTER MESSAGE
3647;	                                //-- LATER.
3648;	   }
3649;	 }

3650;	and Rqualname() := valof
3651;	{ let A := nil
3652;	  Nextsymb()
3653;	  unless Symb eq NAME do { CAEreport(168); resultis ERRORNAME }
3654;	  A := List2(NAME, V|0)
3655;	  Nextsymb()
3656;	  if Symb eq UPLUMP do { Nextsymb(); A := List3(UPLUMP, A, Rexp(37)) }
3657;	  if Symb eq DOT do A := List3(DOT, A, Rqualname())
3658;	  resultis A
3659;	 }

3660;	and IsStructItem(X) :=          // Is X a structure declarator?
3661;	selecton X into
3662;	{ case BIT:
3663;	  case BITN:
3664;	  case BITB:
3665;	  case BYTE:
3666;	  case BYTEN:
3667;	  case CHAR:
3668;	  case WORD:  true
3669;	  default:    false
3670;	 }



		TRN0.BCP;3


3671;	// BCPL Compiler -- Trans, Main Program.

3672;	// TranslateTree  The main program to translate AE-Tree to OCODE.
3673;	// EnterSymbol  Enter a name into the symbol table, and tell CG.
3674;	// EnterEnd  Enter a section end into the symbol table, and tell CG.
3675;	// TransReport  Report errors in Trans.
3676;	// SaveStaticItem  Save a static item to be output at the end.
3677;	// *ScanTable  Scan a table and store its elements into consecutive
3678;	//-- storage.
3679;	// *OutputTable  Output a table at the end.
3680;	// * local to this file.

3681;	get "<bcpl>head"
3682;	get "<bcpl>utilhead"
3683;	get "<xbcpl>headtrn"            // Declarations for TRANS.
3684;	get "<xbcpl>headsymb"           // Symbol table declarations.

3685;	static
3686;	{ Dvec :         nil            // Stack of identifiers currently
3687;	                                //-- declared.
3688;	  SSP:           0
3689;	  CURFNM:        nil            // current function name
3690;	  PDRMAXSSP:     0
3691;	  DvecS :        DvecN+DvecN    // Next free location in Dvec.
3692;	  DvecE :        DvecN+DvecN    // Last Dvec location currently
3693;	                                //-- declared.
3694;	  DvecP :        DvecN+DvecN    // Base in Dvec of current block body.
3695;	  Casetable :    nil            // Table of case entries.
3696;	  CaseP :        0              // Next free location in the case
3697;	                                //-- table.
3698;	  ZERONODE :     nil            // A tree node consisting of (NUMBER,
3699;	                                //-- 0)
3700;	  RoutineBody :  false          // Is ""return"" legal?
3701;	  FunctionBody : false          // Are we in a function body?
3702;	  ValofBlock :   false          // Is ""resultis"" legal?
3703;	  SwitchBlock :  false          // Are ""case"" and ""default"" legal?
3704;	  RepeatBlock :  false          // Are ""loop"" and ""break"" legal?
3705;	  Breaklabel :   nil            // Label to hop to on ""break"".
3706;	  Resultlabel :  nil            // ditto ""resultis"".
3707;	  Defaultlabel : nil            // ditto ""resultis"".
3708;	  Endcaselabel : 0              // ditto ""endcase"" -- and set
3709;	                                //-- non-zero if ""endcase"" is OK.
3710;	  Looplabel :    nil            // ditto ""loop"".
3711;	  VecSSP :       nil
3712;	  StatItemL :    nil            // *Linked list of static items to be
3713;	                                //-- output at the end.
3714;	  StatItemP :    nil            // *Pointer to the last item in the
3715;	                                //-- above list.
3716;	                                // *local to this file.
3717;	 }

3718;	let TranslateTree(x) be
3719;	{                               // init statics!!
3720;	  Constant:=false
3721;	  BlockIn:=0
3722;	  BlockWanted:=0
3723;	  CURFNM:="TOPLEVEL"
3724;	  PDRMAXSSP:=0
3725;	  DvecS := DvecN+DvecN          // Next free location in Dvec.
3726;	  DvecE := DvecN+DvecN          // Last Dvec location currently
3727;	                                //-- declared.
3728;	  DvecP := DvecN+DvecN          // Base in Dvec of current block body.
3729;	  CaseP := 0                    // Next free location in the case
3730;	                                //-- table.
3731;	  RoutineBody := false          // Is ""return"" legal?
3732;	  FunctionBody := false         // Are we in a function body?
3733;	  ValofBlock := false           // Is ""resultis"" legal?
3734;	  SwitchBlock := false          // Are ""case"" and ""default"" legal?
3735;	  RepeatBlock := false          // Are ""loop"" and ""break"" legal?
3736;	  Endcaselabel := 0             // ditto ""endcase"" -- and set
3737;	                                //-- non-zero if ""endcase"" is OK.
3738;	  let v := vec DvecT
3739;	  Dvec := v
3740;	  Dvec|0, Dvec|1 := 0, 0        // An used entry, for error return from
3741;	                                //-- CellWithName.
3742;	  Dvec|DvecN, Dvec|(DvecN+1) := (LABEL ,, H2|ERRORNAME), 0
3743;	                                // Declare "$$".

3744;	  let v := vec CaseT
3745;	  Casetable := v

3746;	  StatItemL := List2(0, nil); StatItemP := StatItemL
3747;	  if SWbits << SW.Debug do
3748;	  { WriteS("*nStatic item list starts at "); WriteOct(StatItemL)
3749;	    PBOUT($*n)
3750;	   }

3751;	  ZERONODE := List2(NUMBER, 0)

3752;	  Curfile, Curline := -1, 0
3753;	  SSP := 1
3754;	  if PDRMAXSSP < SSP do PDRMAXSSP := SSP
3755;	  Out2(STACK, SSP)
3756;	  if SWbits << SW.Help do Help("stopped before Decllabels*n")

3757;	  Decllabels(x)                 // DO THE WORK.
3758;	  Trans(x)

3759;	  Out1(FINISH)

3760;	  Curline := -1                 // No line printed for later Reports.

3761;	// CG now does this (in TENEX BCPL)
3762;	// for i _ 0 step 2 to GlobdeclS do { OutN(Globdecl|i);
3763;	  //-- OutL(Globdecl|(i+1)) }

3764;	// If printing OCODE for TX2 or compiling for BCOM, include the
3765;	  //-- externals.

3766;	  for i := 0 step ExtDeclN to ExtDeclS - ExtDeclN do
3767;	  { let v := vec NAMELENGTH
3768;	    Unpackstring(ExtDecl|i, v)  // The name of the external item.
3769;	    Out3P(lh ExtDecl|(i+1), v|0, rh ExtDecl|(i+1))
3770;	    for i := 1 to v|0 do OutC(v|i)
3771;	   }

3772;	  Impures()

3773;	// Output the static items saved during the compilation.

3774;	  StatItemP := StatItemL        // Start at the beginning of the linked
3775;	                                //-- list.
3776;	  until rv StatItemP eq 0 do
3777;	  { let L := lh StatItemP|1     // The label associated with this item.
3778;	    and x := rh StatItemP|1     // The associated node.
3779;	    switchon H1|x into
3780;	    { case VEC:
3781;	        Compdatalab(L)          // Place the label.
3782;	        Out2(VEC, 1+H2|x)
3783;	        endcase

3784;	      case TABLE:
3785;	        Compdatalab(L)          // Place the label.
3786;	        OutputTable(x)
3787;	        endcase

3788;	      case ASCIZCONST:
3789;	      case STRINGCONST:
3790;	        { let v := vec StringMaxOb
3791;	          Unpackstring(H2+x, v)
3792;	          Pures()
3793;	          Out3P(H1|x, v|0, L)
3794;	          for k := 1 to v|0 do OutC(v|k)
3795;	          Impures()
3796;	          endcase
3797;	         }
3798;	      default:
3799;	        TransReport(-1,,203, x, 0)
3800;	                                // Compiler bug.
3801;	     }
3802;	    StatItemP := rv StatItemP   // To the next item of the linked list.
3803;	   }

3804;	  Pures()                       // Any RC"s are to go into block A.

3805;	 }

3806;	and EnterSymbol(Name, Type, Datum) := valof
3807;	                                // Enter a name into the symbol table.
3808;	{ let Offset := SymtabStoreSymbol(Name, Type, Datum)
3809;	  unless Offset < 0 do Out2(DECL, Offset)
3810;	  resultis Offset
3811;	 }

3812;	and EnterEnd(ST) be             // Enter a section end into the symbol
3813;	                                //-- table.
3814;	{ if ST eq SymtabNextN() return // Nothing was declared.
3815;	  let Offset := SymtabStoreEnd(ST)
3816;	  unless Offset < 0 do Out2(DECL, Offset)
3817;	 }

3818;	// This routine reports errors detected in TRANS.  Its arguments...
3819;	// 1st error number, to be passed verbatim to BCPLreport (unless it
3820;	//-- is 0).
3821;	// 2nd piece of tree to print if debugging (unless it is zero).
3822;	// others other stuff to print, coded like this...
3823;	// > 0 print as a string
3824;	// -1 print next argument as a number
3825;	// -2 print next argument as a line
3826;	// 0 terminate argument list

3827;	and TransReport(N, Tree, nil repname 20) be
3828;	{ let a := OUTPUT; OUTPUT := MONITOR
3829;	  unless N eq 0 \ N=115 do
3830;	  { BCPLreport(N)
3831;	    test Curline > 0            // Is there a current line?
3832;	    ifso
3833;	    { WriteS("while compiling the line*n   "); Wfline(Curline,3)
3834;	     }
3835;	    ifnot if Curline < 0 do WriteS("after the end of compilation.*n")
3836;	   }

3837;	  if N=115 do
3838;	  { Reportcount:=Reportcount+1 ; WriteS("*nNot Declared: ")
3839;	   }
3840;	  let t := lv Tree              // One less than the address of the
3841;	                                //-- first optional parameter.
3842;	  { t := t + 1                  // Step to the next parameter.
3843;	    let s := rv t               // The next parameter.
3844;	    if s eq 0 break             // Last parameter.
3845;	    if s > 0 do { WriteS(s); loop }
3846;	                                // Parameter is a string.
3847;	    t := t + 1
3848;	    if s eq -1 do { WriteN(rv t); loop }
3849;	    if s eq -2 do { WriteS("*n   "); Wfline(rv t); loop }
3850;	   }
3851;	  repeat

3852;	  if N=115 do
3853;	  { WriteS("*s(used in ")
3854;	    WriteS(CURFNM)
3855;	    WriteS(")")
3856;	   }
3857;	  PBOUT($*n)
3858;	  if SWbits << SW.Debug & Tree ne 0 do
3859;	  { Plist(Tree, 0, 5); PBOUT($*n)
3860;	   }
3861;	  OUTPUT := a
3862;	 }

3863;	// This routine is called to save a static item to be output at the end
3864;	//-- of compilation.  It is
3865;	// called from Trans in case STATIC and from Load in case TABLE.

3866;	and SaveStaticItem(x, L) be     // The item x has label L.
3867;	{ switchon H1|x into
3868;	  { default:
3869;	      TransReport(-1,,203, x, 0)
3870;	                                // Compiler bug.
3871;	      return

3872;	    case VEC:
3873;	      x := List2(VEC, EvalConst(H2+x))
3874;	      StaticN := StaticN + H2|x + 1
3875;	                                // 1 + H2|x static cells for the
3876;	                                //-- vector.
3877;	      endcase

3878;	    case TABLE:
3879;	      { let n := ListLength(H2|x)
3880;	        StaticN := StaticN + n  // n static cells used.
3881;	        let t := Newvec(n+1)
3882;	        t|0, t|1 := TABLE, n
3883;	        unless ScanTable(H2|x, t+2) eq n do
3884;	        { TransReport(-1,,203, x, 0); return
3885;	         }                      // Compiler bug.
3886;	        x := t
3887;	       }
3888;	    case ASCIZCONST:
3889;	    case STRINGCONST:
3890;	   }

3891;	  let t := List2(0, nil)
3892;	  StatItemP|0, StatItemP|1 := t, L,,x
3893;	  StatItemP := t
3894;	 }

3895;	// This routine is called by SaveStaticItem and by itself.   X is a
3896;	//-- table and T is the address
3897;	// of a cell.  If X represents N cells, then T|0...T|(N-1) are stuffed
3898;	//-- with the cells and N
3899;	// is returned.  The only entries permitted are NUMBER, VEC,
3900;	//-- STRINGCONST and TABLE.

3901;	and ScanTable(X, T) := valof
3902;	{ let x := rh X
3903;	  switchon H1|x into
3904;	  { case COMMA:
3905;	                      { let k := ScanTable(H2|x, T)
3906;	                        resultis k + ScanTable(H3|x, T+k)
3907;	                       }
3908;	    case REPNAME:
3909;	    case REPVAL:
3910;	                      { let k := 0

3911;	// chek for reasonableness

3912;	                        let m:=EvalConst(H3+x)
3913;	                        unless 1 le m le 2000 do TransReport(37,x,0)
3914;	                        for n := 1 to m
3915;	                        do k := k + ScanTable(H2|x, T+k)
3916;	                        resultis k
3917;	                       }
3918;	    case TABLE:
3919;	                      { let n := ListLength(H2|x)
3920;	                        StaticN := StaticN + n
3921;	                        let t := Newvec(n+1)
3922;	                        t|0, t|1 := TABLE, n
3923;	                        unless ScanTable(H2|x, t+2) eq n
3924;	                        do TransReport(-1,,203, x, 0)
3925;	                        rv T := t
3926;	                        resultis 1
3927;	                       }
3928;	    case VEC:         x := EvalConst(H2+x)
3929;	                                // Length of the vector.
3930;	                      StaticN := StaticN + x + 1
3931;	                      rv T := List2(VEC, x)
3932;	                      resultis 1

3933;	    case ASCIZCONST:
3934;	    case STRINGCONST: rv T := x
3935;	                      resultis 1

3936;	    default:          rv T := List2(NUMBER, EvalConst(lv X))
3937;	                      resultis 1
3938;	   }
3939;	 }

3940;	and OutputTable(x) be           // Called at the end of Trn to output
3941;	                                //-- tables saved by SaveStaticItem.
3942;	{ for n := 2 to 1+x|1 do switchon H1|(x|n) into
3943;	  { case VEC:
3944;	    case STRINGCONST:
3945;	    case TABLE:
3946;	    case ASCIZCONST:
3947;	                      { let L :=
3948;	                          NextParam(((H1|(x|n) eq STRINGCONST)\
3949;	                                     (H1|(x|n)=ASCIZCONST)) =>
3950;	                                   BlockA,
3951;	                                   BlockB)
3952;	                        Out2P(ITEMNL, L)
3953;	                        lh x|n := L
3954;	                        loop
3955;	                       }
3956;	    default:          Out2(ITEMN, H2|(x|n))
3957;	   }

3958;	  for n := 2 to 1+x|1 do
3959;	  { let L := lh x|n             // The associated label.
3960;	    if L eq 0 loop              // Already processed, as a NUMBER or
3961;	                                //-- such.
3962;	    let y := rh x|n             // The associated node.
3963;	    switchon H1|y into
3964;	    { case VEC:         Compdatalab(L)
3965;	                        Out2(VEC, 1+H2|y)
3966;	                        loop

3967;	      case ASCIZCONST:
3968;	      case STRINGCONST:
3969;	                        { let v := vec StringMaxOb
3970;	                          Unpackstring(H2+y, v)
3971;	                          Pures()
3972;	                          Out3P(H1|y, v|0, L)
3973;	                          for k := 1 to v|0 do OutC(v|k)
3974;	                          Impures()
3975;	                          loop
3976;	                         }
3977;	      case TABLE:       Compdatalab(L)
3978;	                        OutputTable(y)
3979;	                        loop
3980;	      default:          TransReport(-1,,203, x, 0)
3981;	                                // Compiler bug.
3982;	     }
3983;	   }
3984;	 }


		TRN1.BCP;3


3985;	// BCPL Compiler -- Trans, Part 1.

3986;	// Trans  Translate a piece of AE-Tree into OCODE.
3987;	// *DeclareAll Translate a declaration (other than LET).
3988;	// *DeclareMIG Do the work for MANIFEST, INDEX or GLOBAL.
3989;	// *DeclareStatic Do the work for a STATIC declaration.
3990;	// *local to this file.

3991;	get "<XBCPL>headtrn"            // Declarations for Trans.
3992;	get "<XBCPL>headsymb"           // Symbol-table declarations.

3993;	let Trans(x) be
3994;	{ x := rh x
3995;	  if x eq 0 return
3996;	  switchon H1|x into
3997;	  { case LET:
3998;	      TransLET(x)
3999;	      return

4000;	    case EXT:
4001;	      DeclareAll(x, DeclExtList, nil)
4002;	      return

4003;	    case GLOBAL:
4004;	      DeclareAll(x, DeclareMIG, (table GLOBAL,
4005;	                                       STglobal))
4006;	      return

4007;	    case INDEX:
4008;	      DeclareAll(x, DeclareMIG, (table INDEX,
4009;	                                       STindex))
4010;	      return

4011;	    case MANIFEST:
4012;	      DeclareAll(x, DeclareMIG, (table NUMBER,
4013;	                                       STmanifest))
4014;	      return

4015;	    case STRUCTURE:
4016;	      DeclareAll(x, TransStructDecl, nil)
4017;	      return

4018;	    case STATIC:
4019;	      DeclareAll(x, DeclareStatic, nil)
4020;	      return

4021;	    case LINE:
4022;	      Curline := H2|x
4023;	      Out2(LINE, Curline)
4024;	      Trans(H3|x)
4025;	      return

4026;	    case ASS:
4027;	      { let S := SSP
4028;	        Lookat(H2+x); Lookat(H3+x)
4029;	        unless Assign(H2|x, H3|x, 0) eq 0 do TransReport(110, x, 0)
4030;	                                             // Expression list too
4031;	                                             //-- short.
4032;	        return
4033;	       }

4034;	    case RTAP:
4035;	      { if H1|(H2|x)=RNAME do
4036;	        { let S:=SSP
4037;	          Lookat(H3+x)
4038;	          Out1(RNAME)
4039;	          let ln:=(H3|x=0)=>0,ListLength(H3|x)
4040;	          Loadlist(H3|x)
4041;	          Out3P(RRTAP,(rv H2|(H2|x)) rshift 22,ln)
4042;	          SSP:=S
4043;	          return
4044;	         }
4045;	        let S := SSP
4046;	        SSP := SSP + Savespacesize
4047;	        if PDRMAXSSP < SSP do PDRMAXSSP := SSP
4048;	        Out2(STACK, SSP-1)
4049;	        Lookat(H2+x); Lookat(H3+x)
4050;	        Out2(NUMBARGS,(H3|x=0)=>0,ListLength(H3|x))
4051;	        Loadlist(H3|x)
4052;	        Load(H2|x)
4053;	        Out2(RTAP, S)
4054;	        SSP := S
4055;	        if PDRMAXSSP < SSP do PDRMAXSSP := SSP
4056;	        return
4057;	       }

4058;	    case GOTO:
4059;	      Lookat(H2+x); Load(H2|x)
4060;	      Out1(H1|x)
4061;	      SSP := SSP - 1
4062;	      return

4063;	    case COLON:
4064;	      Complab(H4|x)
4065;	      Out2(STACK, SSP)
4066;	      Trans(H3|x)
4067;	      return

4068;	    case IF:
4069;	    case UNLESS:
4070;	      { let Op := H1|x
4071;	        let L := NextParam(BlockA)
4072;	        Jumpcond(H2|x, Op eq UNLESS, L)
4073;	        Trans(H3|x)
4074;	        Complab(L)
4075;	        return
4076;	       }

4077;	    case TEST:
4078;	      { let L, M := NextParam(BlockA), NextParam(BlockA)
4079;	        Jumpcond(H2|x, false, L)
4080;	        Trans(H3|x)
4081;	        Compjump(M)
4082;	        Complab(L)
4083;	        Trans(H4|x)
4084;	        Complab(M)
4085;	        return
4086;	       }

4087;	    case BREAK:
4088;	      unless RepeatBlock do TransReport(180, x, 0)
4089;	      if Breaklabel eq 0 do Breaklabel := NextParam(BlockA)
4090;	      Compjump(Breaklabel)
4091;	      return

4092;	    case LOOP:
4093;	      unless RepeatBlock do TransReport(180, x, 0)
4094;	      if Looplabel eq 0 do Looplabel := NextParam(BlockA)
4095;	      Compjump(Looplabel)
4096;	      return

4097;	    case RETURN:
4098;	      unless RoutineBody do TransReport(181, x, 0)
4099;	      Out1(RTRN)
4100;	      return

4101;	    case FINISH:
4102;	    case ABORT:
4103;	      Out1(H1|x)
4104;	      return

4105;	    case RESULTIS:
4106;	      Lookat(H2+x); Load(H2|x)
4107;	      if Resultlabel eq 0 do TransReport(153, x, 0)
4108;	                                // Error report.
4109;	      Out2P(RES, Resultlabel)
4110;	      SSP := SSP - 1
4111;	      return

4112;	    case WHILE:
4113;	    case UNTIL:
4114;	      { let L := NextParam(BlockA)
4115;	                                // Label for the beginning of the
4116;	                                //-- block, to jump back to.
4117;	        let LL, BL := Looplabel, Breaklabel
4118;	        and RB := RepeatBlock
4119;	        RepeatBlock := true     // break and loop are now legal.
4120;	        Looplabel := NextParam(BlockA)
4121;	        Breaklabel := 0
4122;	        Compjump(Looplabel)     // Jump to the test.
4123;	        Complab(L)
4124;	        Trans(H3|x)
4125;	        Complab(Looplabel)
4126;	        let T := H2|x           // The boolean being tested.
4127;	        if H1|T eq LINE do
4128;	        { Curline := H2|T; Out2(LINE, Curline); T := H3|T
4129;	         }
4130;	        Jumpcond(T, H1|x eq WHILE, L)
4131;	        unless Breaklabel eq 0 do
4132;	        { Complab(Breaklabel); Out2(STACK, SSP)
4133;	         }
4134;	        Breaklabel, Looplabel := BL, LL
4135;	        RepeatBlock := RB
4136;	        return
4137;	       }

4138;	    case REPEAT:
4139;	    case REPEATWHILE:
4140;	    case REPEATUNTIL:
4141;	      { let L := NextParam(BlockA)
4142;	                                // Label for the beginning of the
4143;	                                //-- block.
4144;	        let LL, BL := Looplabel, Breaklabel
4145;	        and RB := RepeatBlock
4146;	        RepeatBlock := true
4147;	        Breaklabel := 0
4148;	        Looplabel := H1|x eq REPEAT => L, 0
4149;	        Complab(L)
4150;	        Trans(H2|x)
4151;	        test H1|x eq REPEAT
4152;	        ifso Compjump(L)
4153;	        ifnot
4154;	        { unless Looplabel eq 0 do Complab(Looplabel)
4155;	          let T := H3|x         // The expression.
4156;	          if H1|T eq LINE do
4157;	          { Curline := H2|T; Out2(LINE, Curline); T := H3|T
4158;	           }
4159;	          Jumpcond(T, H1|x eq REPEATWHILE, L)
4160;	         }
4161;	        unless Breaklabel eq 0 do
4162;	        { Complab(Breaklabel); Out2(STACK, SSP)
4163;	         }
4164;	        Looplabel, Breaklabel := LL, BL
4165;	        RepeatBlock := RB
4166;	        return
4167;	       }

4168;	    case CASE:
4169;	      { unless SwitchBlock do TransReport(182, x, 0)
4170;	        if CaseP + CaseN > CaseT do { TransReport(141, 0, 0); return }
4171;	                                // Too many cases.
4172;	        let L := NextParam(BlockA)
4173;	                                // The label for this piece of code.
4174;	        Casetable|CaseP := EvalConst(H2+x)
4175;	                                // The case constant.
4176;	        Casetable|(CaseP+1) := L
4177;	        Casetable|(CaseP+2) := H4|x
4178;	                                // The line number.
4179;	        CaseP := CaseP + CaseN
4180;	        Complab(L)              // Place the label.
4181;	        Trans(H3|x)
4182;	        return
4183;	       }

4184;	    case CASETO:                // Case label with limits.
4185;	      { unless SwitchBlock do TransReport(182, x, 0)
4186;	                                // Must be in a switch block.
4187;	        let M := NextParam(BlockA)
4188;	                                // The label the cases refer to.
4189;	        let L, U := EvalConst(H2+x), EvalConst(H3+x)
4190;	                                // The limits.
4191;	        let N := U - L + 1      // Number of cases to generate.
4192;	        unless N > 0 do { TransReport(145, x, 0); return }
4193;	                                // Oops.
4194;	        unless CaseP + CaseN*N le CaseT do
4195;	        { TransReport(141, 0, 0); return
4196;	         }
4197;	        for k := 0 to N-1 do    // Place the cases.
4198;	        { Casetable| CaseP := L + k
4199;	                                // The value.
4200;	          Casetable|(CaseP+1) := M
4201;	                                // The label.
4202;	          Casetable|(CaseP+2) := H5|x
4203;	                                // The line number.
4204;	          CaseP := CaseP + CaseN
4205;	         }
4206;	        Complab(M)              // Place the label.
4207;	        Trans(H4|x)
4208;	        return
4209;	       }

4210;	    case DEFAULT:
4211;	      unless SwitchBlock do TransReport(182, x, 0)
4212;	                                // Not in a switch block.
4213;	      unless Defaultlabel eq 0 do TransReport(101, x, 0)
4214;	                                  // default used twice.
4215;	      Defaultlabel := NextParam(BlockA)
4216;	      Complab(Defaultlabel)
4217;	      Trans(H2|x)
4218;	      return

4219;	    case ENDCASE:
4220;	      if Endcaselabel eq 0 do { TransReport(183, x, 0); return }
4221;	                                // Not in a switch block.
4222;	      Compjump(Endcaselabel)
4223;	      return

4224;	    case BRANCHON:
4225;	    case SWITCHON:
4226;	      Transswitch(x)
4227;	      return

4228;	    case FOR:
4229;	      { let E, S := DvecE, DvecS
4230;	                                // Prepare to do a declaration.
4231;	        and LL, BL := Looplabel, Breaklabel
4232;	        and RB, SB := RepeatBlock, SwitchBlock
4233;	        let ST := SymtabNextN() // For symbol table block end.
4234;	        Looplabel, Breaklabel := 0, 0
4235;	        RepeatBlock, SwitchBlock := true, false
4236;	        let L := NextParam(BlockA)
4237;	                                // Label for the test.
4238;	        and M := NextParam(BlockA)
4239;	                                // Label for the body.
4240;	        let S1 := SSP           // The stack position into which the
4241;	                                //-- controlled variable goes.
4242;	        Lookat(H3+x); Load(H3|x)
4243;	                                // Load the lower limit into the stack.
4244;	        let Stepsize := H5|x eq 0 => 1, EvalConst(H5+x)
4245;	                                // The increment.
4246;	        let S2 := SSP           // The stack position for the upper
4247;	                                //-- limit.
4248;	        and Limit := nil        // The value of the upper limit, if it
4249;	                                //-- is a constant.
4250;	        Lookat(H4+x)            // Optimize the upper limit.
4251;	        test #400000 > lh H4|x > 0
4252;	                                // Is its value known at compile time?
4253;	        ifso S2, Limit := -1, rv lh H4|x
4254;	                                // Yes, so set S2 < 0 as a switch.
4255;	        ifnot Load(H4|x)        // No, so load it into stack position
4256;	                                //-- S2.
4257;	        Out1(STORE)
4258;	        Compjump(L)             // Jump to the test.
4259;	        AddName(H2|x, LOCAL, S1)
4260;	                                // Declare the controlled variable.
4261;	        if SWbits << SW.Symtab do EnterSymbol(H2|x, STlocal, S1)
4262;	                                  // Symbol table entry.
4263;	        DvecE := DvecS          // Make it known.
4264;	        Complab(M)              // The label for the body.
4265;	        Decllabels(H6|x)        // Compile the body.
4266;	        Trans(H6|x)             // ...
4267;	        unless Looplabel eq 0 do Complab(Looplabel)
4268;	        Out2(LP, S1)            // Load the controlled variable.
4269;	        Out2(LN, Stepsize); Out1(PLUS); Out2(SP, S1)
4270;	                                // Add the step size and store back.
4271;	        Complab(L)              // Label the test.
4272;	        Out2(LP, S1)            // Load the controlled variable.
4273;	        test S2 > 0
4274;	        ifso Out2(LP, S2)
4275;	        ifnot Out2(LN, Limit)   // Load the upper limit.
4276;	        let Inc := Stepsize > 0
4277;	        Out1(Inc => LE, GE); Out2P(JT, M)
4278;	                                // The appropriate test.
4279;	        unless Breaklabel eq 0 do Complab(Breaklabel)
4280;	        SSP := S1               // Put it back.
4281;	        if PDRMAXSSP < SSP do PDRMAXSSP := SSP
4282;	        Out2(STACK, SSP)
4283;	        if SWbits << SW.Symtab do EnterEnd(ST)
4284;	        DvecE, DvecS := E, S
4285;	        Breaklabel, Looplabel := BL, LL
4286;	        RepeatBlock, SwitchBlock := RB, SB
4287;	        return
4288;	       }

4289;	    case SEQ:
4290;	      Trans(H2|x)
4291;	      Trans(H3|x)
4292;	      return

4293;	    default:
4294;	      TransReport(100, x, 0)    // Error report.
4295;	   }
4296;	 }

4297;	and DeclareAll(x, Function, Data) be
4298;	                                // Process a declaration.
4299;	{ let DE, DS := DvecE, DvecS    // Save pointers into Dvec.
4300;	  and S := SSP                  // Save the current simulated stack
4301;	                                //-- pointer.
4302;	  and ST := SymtabNextN()       // Where the first symbol table entry
4303;	                                //-- goes.
4304;	  let SB := SwitchBlock         // Were we in a switch block?
4305;	  SwitchBlock := false          // Now we aren"t.

4306;	  Function(H2|x, Data)          // Do all the work of the declarations.
4307;	  CheckDistinct(DS, DvecS)      // Be sure that all names declared are
4308;	                                //-- distinct.
4309;	  DvecE := DvecS                // Make the names known in the
4310;	                                //-- following block.

4311;	  Decllabels(H3|x)              // Declare possible labels in the
4312;	                                //-- following block.
4313;	  Trans(H3|x)                   // Translate the block.

4314;	  DvecE, DvecS := DE, DS        // Restore Dvec pointers...
4315;	  SSP := S                      // ...and SSP...
4316;	  if PDRMAXSSP < SSP do PDRMAXSSP := SSP
4317;	  SwitchBlock := SB             // ...and SwitchBlock.
4318;	  if SWbits << SW.Symtab do EnterEnd(ST)
4319;	                                // Enter section end into the symbol
4320;	                                //-- table.
4321;	 }

4322;	and DeclareMIG(x, Data) be      // Do the work for a MANIFEST, INDEX or
4323;	                                //-- GLOBAL declaration.
4324;	{ if H1|x eq LINE do { Curline := H2|x; x := H3|x }
4325;	  unless H2|x eq 0 do
4326;	  { let CL := Curline; DeclareMIG(H2|x, Data); Curline := CL
4327;	   }
4328;	  let N := EvalConst(H4+x)      // Evaluate the right side of the
4329;	                                //-- definition.
4330;	  if Data|0=GLOBAL
4331;	  do unless 0 le N le GlobNMax do
4332;	     { TransReport(401,x,0) ; N:=GlobNMax
4333;	      }
4334;	  if Data|0 eq INDEX do         // About to declare an index register.
4335;	  unless 0 le N le #77 do { TransReport(132, x, 0); N := #10 }
4336;	                                // Index register out of range.
4337;	  AddName(H3|x, Data|0, N)      // Declare the item.
4338;	  if SWbits << SW.Symtab do EnterSymbol(H3|x, Data|1, N)
4339;	                                // Enter the item into the symbol
4340;	                                //-- table.
4341;	  if Data|0 eq NUMBER do DvecE := DvecS
4342;	                                // Make this name known to subsequent
4343;	                                //-- expressions.
4344;	 }

4345;	and DeclareStatic(x) be         // Do the work for a STATIC
4346;	                                //-- declaration.
4347;	{ if H1|x eq LINE do { Curline := H2|x; x := H3|x }
4348;	  unless H2|x eq 0 do
4349;	  { let CL := Curline; DeclareStatic(H2|x); Curline := CL
4350;	   }
4351;	  DeclStat(H3|x, STstaticYYYYvar)
4352;	                                // Declare the item to be static.
4353;	  let t := H4|x                 // The value of the item.
4354;	  switchon H1|t into            // What sort of value is it?
4355;	  { case TABLE:
4356;	    case VEC:
4357;	    case STRINGCONST:
4358;	    case ASCIZCONST:
4359;	      { let L :=
4360;	          NextParam(((H1|t eq STRINGCONST)\(H1|t=ASCIZCONST)) => BlockA,
4361;	                    BlockB)
4362;	        Out2P(ITEMNL, L)        // The data label the item will have.
4363;	        SaveStaticItem(t, L)    // Remember to output this item at the
4364;	                                //-- end.
4365;	        endcase
4366;	       }
4367;	    default:                    // Anything else must be evaluable now.
4368;	      Out2(ITEMN, EvalConst(H4+x))
4369;	   }
4370;	 }



		TRN2.BCP;4


4371;	// BCPL Compiler -- Trans, Part 2.

4372;	// TransLET Translate the left son of a LET node.
4373;	// *Transdef1 Load the right sides of definitions other than VALDEFs.
4374;	// *TD1  Do the work for Transdef1
4375;	// *Transdef2 Load the right sides of VALDEFs that are LIST or VEC.
4376;	// *TD2  Do the work for Transdef2

4377;	// *DeclNames Declare names.
4378;	// *DeclDyn  Declare dynamic variables.
4379;	// DeclStat Declare a static item.
4380;	// EnterExt Enter an external name into ExtDecl.
4381;	// DeclExtList Declare a list of external names.

4382;	// AddName  Add a new name that has been declared.
4383;	//******The next two routines were hand-coded, and live in HANDCD.MAC
4384;	// CellWithName Return the Dvec entry of a cell with a given name.
4385;	// CheckDistinct Check that names declared in a block head are
4386;	//-- distinct.
4387;	//******

4388;	// ListLength Return the length of a list.
4389;	// *TableSpace Total amount of static space required by a table.
4390;	// * local to this file.

4391;	get "<XBCPL>headtrn"            // Declarations for Trans.
4392;	get "<XBCPL>headsymb"           // Symbol table stuff.

4393;	// Translate the left son of a LET node.

4394;	let TransLET(x) be
4395;	{ let DE, DS, S := DvecE, DvecS, SSP
4396;	  and V := VecSSP
4397;	  and SB := SwitchBlock
4398;	  and ST := SymtabNextN()
4399;	  SwitchBlock := false
4400;	  x := rh x
4401;	  let Def := rh H2|x            // The definition.
4402;	  while H1|Def eq LINE do
4403;	  { Curline := H2|Def; Out2(LINE, Curline); Def := rh H3|Def
4404;	   }
4405;	  DeclNames(Def)
4406;	  CheckDistinct(DS, DvecS)
4407;	  DvecE := DvecS
4408;	  VecSSP := SSP
4409;	  SSP := S
4410;	  if PDRMAXSSP < SSP do PDRMAXSSP := SSP
4411;	  Decllabels(H3|x)
4412;	  Transdef1(Def)
4413;	  { let OldVecSSP := VecSSP
4414;	    Transdef2(Def)
4415;	    VecSSP := OldVecSSP
4416;	   }
4417;	  SSP := VecSSP
4418;	  if PDRMAXSSP < SSP do PDRMAXSSP := SSP
4419;	  Out2(STACK, SSP)
4420;	  Out1(STORE)
4421;	  Trans(H3|x)
4422;	  VecSSP := V
4423;	  DvecE, DvecS, SSP := DE, DS, S
4424;	  if PDRMAXSSP < SSP do PDRMAXSSP := SSP
4425;	  SwitchBlock := SB
4426;	  if SWbits << SW.Symtab do EnterEnd(ST)
4427;	  Out2(STACK, SSP)
4428;	 }

4429;	and Transdef1(x) be             // Load right side(s) of a definition.
4430;	                                //-- Called from TransLET.
4431;	{ if x eq 0 return
4432;	  while H1|x eq LINE do
4433;	  { Curline := H2|x; Out2(LINE, Curline); x := rh H3|x; if x eq 0 return
4434;	   }
4435;	  switchon H1|x into
4436;	  { case AND:
4437;	       Transdef1(H2|x)
4438;	       Transdef1(H3|x)
4439;	       endcase

4440;	    case VALDEF:
4441;	       { let S := SSP
4442;	         Lookat(H3+x)
4443;	         TD1(H3|x)
4444;	         let n := (SSP - S) - H4|x
4445;	                                // Difference between number of names
4446;	                                //-- and of values.
4447;	         if n eq 0 endcase      // All is well if they are the same.
4448;	         TransReport(n > 0 => 130, 131, x, 0)
4449;	                                // Oops.
4450;	         endcase
4451;	        }

4452;	    case FNDEF:
4453;	    case RTDEF:                 // Function or routine definition.
4454;	       { let oldfnm:=CURFNM
4455;	         let oldmax:=PDRMAXSSP
4456;	         let L := 0
4457;	         let DE, DS, DP := DvecE, DvecS, DvecP
4458;	         let S := SSP
4459;	         let VB, SB, RB := ValofBlock, SwitchBlock, RepeatBlock
4460;	         ValofBlock, SwitchBlock, RepeatBlock := false, false, false
4461;	         let EL := Endcaselabel
4462;	         Endcaselabel := 0
4463;	         let FBody, RBody := FunctionBody, RoutineBody
4464;	         if FBody\RBody do
4465;	         { L := NextParam(BlockA)
4466;	           Compjump(L)          // Compile jump round body.
4467;	          }
4468;	         RoutineBody := H1|x eq RTDEF
4469;	         FunctionBody := RoutineBody => false,true
4470;	                                // Are we in a routine body?
4471;	                                // Compile the entry point.  H5|x was
4472;	                                //-- set in DeclNames to the label of
4473;	                                //-- this routine.
4474;	         CURFNM:=H2|(H2|x)
4475;	         Compentry(H2|x, H5|x)  // H2|x is the name.
4476;	         SSP := Savespacesize   // Start a new stack frame.
4477;	         PDRMAXSSP := SSP
4478;	         let ST := SymtabNextN()

4479;	         DvecP := DvecS
4480;	         DeclDyn(H3|x, STparam) // Declare the formal parameter list.
4481;	         if SWbits << SW.Symtab do SymtabStoreArgs(lh H5|x, SSP - Savespacesize)
4482;	         CheckDistinct(DS, DvecS)
4483;	                                // Two parameters with the same name?
4484;	         DvecE := DvecS         // Make the parameters known.

4485;	// change the ocode interpreter to expect another arg to SAVE
4486;	                                // Compile the body of the thing.
4487;	         Out2(SAVE, SSP)
4488;	// leave space for later stuffing of MAXSSP
4489;	let ocp_ruppersptr()
4490;	OutL(0)

4491;	         test RoutineBody
4492;	         ifso
4493;	         { let S := SSP
4494;	           Decllabels(H4|x); Trans(H4|x)
4495;	           Out1(RTRN)
4496;	          }
4497;	         ifnot { Lookat(H4+x); Load(H4|x); Out1(FNRN) }

4498;	// put out an ENDEF ocode item after stuffing MAXSSP

4499;	         SSP := S
4500;	         if PDRMAXSSP < SSP do PDRMAXSSP := SSP
4501;	         DvecE, DvecS, DvecP := DE, DS, DP
4502;	         if SWbits << SW.Symtab do EnterEnd(ST)
4503;	         Out2(STACK, SSP)

4504;	         if FBody\RBody do Complab(L)
4505;	let newocp_ruppersptr()
4506;	suppersptr(ocp)
4507;	OutL(PDRMAXSSP)
4508;	suppersptr(newocp)
4509;	Out1(ENDEF)
4510;	                                // The jump around the body.
4511;	         ValofBlock, RepeatBlock, SwitchBlock := VB, RB, SB
4512;	         Endcaselabel := EL
4513;	         FunctionBody, RoutineBody := FBody, RBody
4514;	         PDRMAXSSP:=oldmax
4515;	         CURFNM:=oldfnm
4516;	        }

4517;	    default:
4518;	   }
4519;	 }

4520;	// TD1 is called by
4521;	// Transdef, case VALDEF, to process the right side.
4522;	// TD2, case LIST, to process the list.
4523;	// In general, it loads the relevant value(s) into the stack, but VEC
4524;	//-- and LIST are special.
4525;	// For these only the label is loaded and VecSSP is incremented by the
4526;	//-- space needed.  The space
4527;	// for a VEC and the data for a LIST are provided later by TD2, after
4528;	//-- the entire right side
4529;	// of the VALDEF has been processed.

4530;	and TD1(x) be
4531;	{ let tt:=nil
4532;	  x := rh x
4533;	  switchon H1|x into
4534;	  { default:      Load(x)
4535;	                  endcase

4536;	    case VEC:     tt:=EvalConst(H2+x)
4537;	                  Out3P(DYNVECDEC, VecSSP,tt)
4538;	                  SSP := SSP + 1
4539;	                  if PDRMAXSSP < SSP do PDRMAXSSP := SSP
4540;	                  VecSSP := VecSSP + 1 + tt
4541;	                  endcase

4542;	    case LIST:    Out2(LLP, VecSSP)
4543;	                  SSP := SSP + 1
4544;	                  if PDRMAXSSP < SSP do PDRMAXSSP := SSP
4545;	                  VecSSP := VecSSP + TableSpace(H2|x)
4546;	                  endcase

4547;	    case COMMA:   TD1(H2|x)
4548;	                  TD1(H3|x)
4549;	                  endcase

4550;	    case REPVAL:  unless #400000 > lh H2|x > 0 do
4551;	                  { TransReport(127, x, 0); endcase
4552;	                   }
4553;	    case REPNAME: 
4554;	{ let m_EvalConst(H3+x)
4555;	unless 1 le m le 2000 do
4556;	{ TransReport(37,x,0) ; m_1}
4557;	for i := 1 to m do TD1(H2|x)
4558;	}
4559;	   }
4560;	 }

4561;	// Look through the right side of a definition for VALDEFs and call TD2
4562;	//-- to process them.
4563;	// Called from TransLET.

4564;	and Transdef2(x) be
4565;	{ x := rh x
4566;	  if x eq 0 return
4567;	  while H1|x eq LINE do
4568;	  { x := rh H3|x; if x eq 0 return
4569;	   }
4570;	  if H1|x eq AND do
4571;	  { Transdef2(H2|x)
4572;	    Transdef2(H3|x)
4573;	    return
4574;	   }
4575;	  if H1|x eq VALDEF do TD2(H3|x)
4576;	 }

4577;	// This routine is called from Transdef2, case VALDEF, to process LISTs
4578;	//-- and VECs.

4579;	and TD2(x) be
4580;	{ x := rh x
4581;	  switchon H1|x into
4582;	  { case VEC:     SSP := SSP + 1 + EvalConst(H2+x)
4583;	                  if PDRMAXSSP < SSP do PDRMAXSSP := SSP
4584;	                  Out2(STACK, SSP)
4585;	    default:      endcase

4586;	    case LIST:    VecSSP := SSP + ListLength(H2|x)
4587;	                  TD1(H2|x)
4588;	                  TD2(H2|x)
4589;	                  endcase

4590;	    case COMMA:   TD2(H2|x)
4591;	                  TD2(H3|x)
4592;	                  endcase

4593;	    case REPNAME: 
4594;	{ let m_EvalConst(H3+x)
4595;	unless 1 le m le 2000 do
4596;	{ TransReport(37,x,0) ; m_1}
4597;	for i := 1 to m do TD2(H2|x)
4598;	}
4599;	   }
4600;	 }

4601;	// Declare the names in a set of declarations.  Dynamic names (case
4602;	//-- VALDEF) are processed by
4603;	// DeclDyn, which steps SSP by the number of names declared.  Names of
4604;	//-- functions and routines
4605;	// are declared as static items by DeclStat.  Leave symbol table offset
4606;	//-- in FNDEF and RTDEF nodes.
4607;	// This routine is called only from TransLET.

4608;	and DeclNames(x) be
4609;	{ if x eq 0 return
4610;	  if H1|x eq LINE do
4611;	  { Curline := H2|x; Out2(LINE, Curline); x := H3|x
4612;	   }
4613;	  switchon H1|x into
4614;	  { case AND:
4615;	      DeclNames(H2|x)
4616;	      DeclNames(H3|x)
4617;	      endcase

4618;	    case VALDEF:
4619;	      { let S := SSP
4620;	        DeclDyn(H2|x, STlocal)
4621;	        H4|x := SSP - S         // Record number of names declared.
4622;	        endcase
4623;	       }

4624;	    case RTDEF:
4625;	    case FNDEF:
4626;	      { H5|x := NextParam(BlockA)
4627;	                                // The label to be associated with the
4628;	                                //-- function or routine.
4629;	        let STtype :=
4630;	          H1|x eq RTDEF => STstaticYYYYroutine, STstaticYYYYfunction
4631;	                                // Symbol table type.
4632;	        lh H5|x := DeclStat(H2|x, STtype)
4633;	                                // Declare name static, saving symbol
4634;	                                //-- table offset.
4635;	        Out2P(ITEML, rh H5|x)   // Store the label for it.
4636;	        endcase
4637;	       }

4638;	    default:
4639;	      TransReport(102, x, 0)    // Compiler error.
4640;	   }
4641;	 }

4642;	// Declare 1 or more dynamic names, in a formal parameter list or on
4643;	//-- the left side of a
4644;	// VALDEF.  Step SSP as appropriate.  This routine is called from
4645;	// DeclNames, case VALDEF, to process the names being declared.
4646;	// Transdef1, case FNDEF and RTDEF to process the formal parameters.
4647;	// In the former case Type is STlocal, and in the latter it is STparam.

4648;	and DeclDyn(x, Type) be
4649;	{ if x eq 0 return
4650;	  switchon H1|x into
4651;	  { case NAME:
4652;	      AddName(x, LOCAL, SSP)
4653;	      if SWbits << SW.Symtab do EnterSymbol(x, Type, SSP)
4654;	      SSP := SSP + 1
4655;	      if PDRMAXSSP < SSP do PDRMAXSSP := SSP
4656;	      endcase

4657;	    case NIL:
4658;	      SSP := SSP + 1
4659;	      if PDRMAXSSP < SSP do PDRMAXSSP := SSP
4660;	      endcase

4661;	    case COMMA:
4662;	      DeclDyn(H2|x, Type)
4663;	      DeclDyn(H3|x, Type)
4664;	      endcase

4665;	    case REPNAME:               // Look at left son??? ::::::: :::::::
4666;	      { let n := EvalConst(H3+x)
4667;	                                // The number of replications.
4668;	        unless 1 le n le 2000 do { TransReport(37, x, 0); endcase }
4669;	                                // Negative replictation count.
4670;	        SSP := SSP + n
4671;	        if PDRMAXSSP < SSP do PDRMAXSSP := SSP
4672;	        endcase
4673;	       }

4674;	    default:
4675;	      TransReport(103, x, 0)    // Compiler error.
4676;	   }
4677;	 }

4678;	// The call   F _ DeclStat(x, Type)   is used to declare  x  to be a
4679;	//-- static item of type Type,
4680;	// and get back its offset in the symbol table.  If x is not external,
4681;	//-- add it to Dvec
4682;	// with a new label, M.
4683;	// If x is external,
4684;	// if x is undefined and unused, add to ExtDecl with a new label, M,.
4685;	// if x is undefined but associated with a label, call it M,.
4686;	// if x is defined, error 142 (multiple use of a name).
4687;	// Output datalab M.
4688;	// The returned value is used for FNDEF and RTDEF so the number of
4689;	//-- arguments can be stored
4690;	// later into the symbol table.
4691;	// This routine is called from
4692;	// Trans, case STATIC, to declare the static item.
4693;	// DeclNames, to declare the name of a function or routine.
4694;	// Scanlabels, to declare a label.

4695;	and DeclStat(x, Type) := valof
4696;	{ Impures()                     // The data item goes into block B.
4697;	  StaticN := StaticN + 1        // Count static cells.
4698;	  let L := nil                  // To hold the label.
4699;	  let t := CellWithName(x)      // Look up the name in the symbol
4700;	                                //-- table.
4701;	  let SWext := lh Dvec|t eq EXT
4702;	                                // Is the name currently declared
4703;	                                //-- external?
4704;	  if FunctionBody\RoutineBody do SWext:=false
4705;	  test SWext
4706;	  ifnot                         // No, so declare it a simple static
4707;	                                //-- item with a new label.
4708;	  { L := NextParam(BlockB)
4709;	    AddName(x, LABEL, L)
4710;	    if (lh Dvec|t)=GLOBAL
4711;	    do unless FunctionBody\RoutineBody do Out3P(GLOBAL,Dvec|(t+1),L)
4712;	   }
4713;	  ifso                          // Yes, it is EXTERNAL.
4714;	  { let n := rh Dvec|(t+1)      // Pointer into ExtDecl.
4715;	    test n ge 0                 // Is the name yet in ExtDecl?
4716;	    ifso if lh ExtDecl|(n+1) eq INT do TransReport(142, x, 0)
4717;	                                       // Yes.
4718;	    ifnot n := EnterExt(t)      // No, so enter it there.
4719;	    lh ExtDecl|(n+1) := INT     // Mark it as an internal.
4720;	    L := rh ExtDecl|(n+1)       // The associated label.
4721;	   }
4722;	  Compdatalab(L)
4723;	  unless SWbits << SW.Symtab resultis 0
4724;	  let F := EnterSymbol(x, STstatic, (Type ,, SWext))
4725;	  resultis F
4726;	 }

4727;	// Enter the name in the Dvec cell at t into ExtDecl, with a new label.
4728;	// Make the Dvec cell point to the ExtDecl cell and return the ExtDecl
4729;	//-- cell.
4730;	// This routine is called from
4731;	// DeclStat if name is already in Dvec, and is marked EXT.
4732;	// Simpass  storing into a name marked in Dvec as EXT.
4733;	// name to left of LEFTLUMP marked as EXT.
4734;	// Load  fetching a name marked in Dvec as EXT.
4735;	// Loadlv  ditto.

4736;	and EnterExt(t) := valof
4737;	{ let S := ExtDeclS
4738;	  if S ge ExtDeclT do { TransReport(144, 0, 0); resultis S }
4739;	                                // Too many externals.
4740;	  Dvec|(t+1) := S               // Store into Dvec the pointer to the
4741;	                                //-- new ExtDecl cell.
4742;	  ExtDecl|S := rh Dvec|t        // The name.
4743;	  ExtDecl|(S+1) := EXT ,, NextParam(IntExt)
4744;	                                // Type ,, associated label.
4745;	  ExtDeclS := S + ExtDeclN
4746;	  resultis S
4747;	 }

4748;	and DeclExtList(x) be           // Called (only) from Trans for case
4749;	                                //-- EXT to
4750;	                                // declare the names external.
4751;	{ if H1|x eq COMMA do { DeclExtList(H2|x); DeclExtList(H3|x); return }
4752;	  let k := ExtDeclS
4753;	  { k := k - ExtDeclN
4754;	    if k le 0 do { k := -1; break }
4755;	   }
4756;	  repeatuntil ExtDecl|k eq x
4757;	  if (q4(H2|x)|0) > 6 do TransReport(2,,400,x,0)
4758;	  AddName(x, EXT, k)
4759;	 }

4760;	// The call   AddName(Name, Type, Datum)   adds the name Name to Dvec.
4761;	//-- Type indicates the type, and
4762;	// Datum is a datum.  The types and associated data are
4763;	// NUMBER  the value
4764;	// EXT  index in ExtDecl or -1
4765;	// LOCAL  the offset in the stack
4766;	// INDEX  the index register number --  TX-2 only.
4767;	// GLOBAL  the global number -- SEL only.
4768;	// LABEL  the subscript of the label, for static declarations.
4769;	// STRUCTURE the address of the structure definition table
4770;	// Called from, with associated values of Type.
4771;	// Trans, case GLOBAL  Type _ GLOBAL
4772;	// Trans, case INDEX  Type _ INDEX
4773;	// Trans, case MANIFEST  Type _ NUMBER
4774;	// Trans, case FOR   Type _ LOCAL, for the controlled variable.
4775;	// DeclDyn    Type _ LOCAL
4776;	// DeclStat   Type _ LABEL
4777;	// DeclExtList   Type _ EXT
4778;	// TransStructDecl   Type _ STRUCTURE

4779;	and AddName(Name, Type, Datum) be
4780;	{ if DvecS+DvecN > DvecT do { TransReport(143, 0, 0); return }
4781;	                                // Too many names.
4782;	  Dvec|DvecS := Type ,, H2|Name
4783;	                                // Type ,, location of name in
4784;	                                //-- dictionery.
4785;	  Dvec|(DvecS+1) := Datum       // The associated data item.
4786;	  DvecS := DvecS + DvecN
4787;	 }

4788;	// Return the length of a list made up of COMMA and REPNAME nodes.
4789;	//-- Called from
4790;	// TD2, case LIST
4791;	// SaveStaticItem, case TABLE
4792;	// ScanTable, case TABLE

4793;	and ListLength(x) := valof
4794;	{ x := rh x
4795;	  if H1|x eq COMMA do resultis ListLength(H2|x) + ListLength(H3|x)
4796;	  if H1|x eq REPNAME \ H1|x eq REPVAL
4797;	  do 
4798;	{ let m_EvalConst(H3+x)
4799;	unless 1 le m le 2000 do

4800;	{ TransReport(37,x,0) ; m_1}
4801;	 resultis m * ListLength(H2|x)}
4802;	  resultis 1
4803;	 }

4804;	// Return total amount of static space required for a table.  Called
4805;	//-- from TD1, case LIST.

4806;	and TableSpace(x) := valof
4807;	{ x := rh x
4808;	  switchon H1|x into
4809;	  { case COMMA:    resultis TableSpace(H2|x) + TableSpace(H3|x)

4810;	    case REPNAME:  { let m_EvalConst(H3+x)
4811;	unless 1 le m le 2000 do { TransReport(37,x,0); m_1}
4812;	resultis m * TableSpace(H2|x)}

4813;	    case VEC:      resultis 2 + EvalConst(H2+x)

4814;	    case LIST:     resultis 1 + TableSpace(H2|x)

4815;	    default:       resultis 1
4816;	   }
4817;	 }


		TRN3.BCP;3


4818;	// BCPL Compiler -- Trans, Part 3.

4819;	// Decllabels Declare all the labels at the top level in a block.
4820;	// *ScanLabels Do the work for Decllabels.
4821;	// Jumpcond Compile a conditional jump.
4822;	// Loadlist Load the R-values of a list of elements.
4823;	// * local to this file.

4824;	get "<XBCPL>headtrn"            // Declarations for Trans.
4825;	get "<XBCPL>headsymb"           // Symbol table declarations.

4826;	// This routine is called for all blocks to declare all labels
4827;	//-- reachable at the top level
4828;	// in the block.  It uses ScanLabels to do the work.

4829;	let Decllabels(x) be
4830;	{ let DS := DvecS
4831;	  Impures()
4832;	  let L := Curline
4833;	  ScanLabels(lv x)
4834;	  Pures()
4835;	  CheckDistinct(DS, DvecS)
4836;	  Curline := L
4837;	  DvecE := DvecS
4838;	 }

4839;	// This routine does the work for Decllabels just above.  All labels
4840;	//-- are declared.  The boolean arms
4841;	// of conditional commands are looked at to see if they can be
4842;	//-- evaluated at compile time.  If
4843;	// so, the appropriate optimizations are done.

4844;	and ScanLabels(LVX) be
4845;	{ let x := rv LVX
4846;	  if x eq 0 return

4847;	  let Op := H1|x
4848;	  and Node := 0                 // This variable holds the tree that is
4849;	                                //-- left after optimization.

4850;	  switchon Op into
4851;	  { default:          return

4852;	    case COLON:       H4|x := NextParam(BlockA)
4853;	                      DeclStat(H2|x, STstaticYYYYlabel)
4854;	                                // Declare the label static and compile
4855;	                                //-- DATALAB.
4856;	                      Out2P(ITEML, H4|x)
4857;	                                // Compile the label.
4858;	                      ScanLabels(H3+x)
4859;	                      return

4860;	    case IF:
4861;	    case UNLESS:      Lookat(H2+x)
4862;	                      unless lh H2|x > 0 do
4863;	                      { ScanLabels(H3+x); return
4864;	                       }
4865;	                      if (rv lh H2|x ne false) eqv (Op eq IF)
4866;	                      do Node := H3|x
4867;	                      endcase

4868;	    case UNTIL:
4869;	    case WHILE:
4870;	                      { let n := lv(H3|(H2|x))
4871;	                                // Skip the LINE node.
4872;	                        Lookat(n)
4873;	                        n := rv n
4874;	                        unless #400000 > lh n > 0 do
4875;	                        { ScanLabels(H3+x); return
4876;	                         }
4877;	                        if (rv lh n ne false) eqv (Op eq WHILE)
4878;	                        do Node := List2(REPEAT, H3|x)
4879;	                        endcase
4880;	                       }

4881;	    case REPEATWHILE:
4882;	    case REPEATUNTIL:
4883;	                      { let n := lv ( H3|(H3|x) )
4884;	                                // Skip the line node.
4885;	                        Lookat(n)
4886;	                        n := rv n
4887;	                        unless lh n > 0 do
4888;	                        { ScanLabels(H2+x); return
4889;	                         }
4890;	                        test (rv lh n ne false) eqv (Op eq REPEATWHILE) then Node :=
4891;	                                                                               List2(REPEAT,
4892;	                                                                                     H2|x)
4893;	                        or Node:=H2|x
4894;	                        endcase
4895;	                       }

4896;	    case TEST:        Lookat(H2+x)
4897;	                      unless #400000 > lh H2|x > 0 do
4898;	                      { ScanLabels(H3+x); ScanLabels(H4+x); return
4899;	                       }
4900;	                      Node := (rv lh H2|x => H3, H4)|x
4901;	                      endcase

4902;	    case LINE:        Curline := H2|x

4903;	    case SWITCHON:
4904;	    case BRANCHON:
4905;	    case CASE:        ScanLabels(H3+x)
4906;	                      return

4907;	    case CASETO:      ScanLabels(H4+x)
4908;	                      return

4909;	    case DEFAULT:
4910;	    case REPEAT:      ScanLabels(H2+x)
4911;	                      return

4912;	    case SEQ:         ScanLabels(H2+x)
4913;	                      ScanLabels(H3+x)
4914;	                      return
4915;	   }

4916;	// Executing "endcase" above leads here with something in Node.

4917;	  unless Node eq 0 do ScanLabels(lv Node)
4918;	  rv LVX := -1 ,, Node
4919;	 }

4920;	// Compile a jump to the label L if the expression  x  will have at run
4921;	//-- time the same
4922;	// truthvalue as does B now.

4923;	and Jumpcond(x, B, L) be
4924;	{ if #400000 > lh x > 0 do
4925;	  { if (rv lh x ne false) eqv B do Compjump(L)
4926;	    return
4927;	   }

4928;	  x := rh x
4929;	  switchon H1|x into
4930;	  { case NOT:    Jumpcond(H2|x, not B, L)
4931;	                 return

4932;	    case LOGAND: test B
4933;	                 then
4934;	                 { let M := NextParam(BlockA)
4935;	                   Jumpcond(H2|x, false, M)
4936;	                   Jumpcond(H3|x, true, L)
4937;	                   Complab(M)
4938;	                  }

4939;	                 or
4940;	                 { Jumpcond(H2|x, false, L)
4941;	                   Jumpcond(H3|x, false, L)
4942;	                  }
4943;	                 return

4944;	    case LOGOR:  test B then
4945;	                 { Jumpcond(H2|x, true, L)
4946;	                   Jumpcond(H3|x, true, L)
4947;	                  }

4948;	                 or
4949;	                 { let M := NextParam(BlockA)
4950;	                   Jumpcond(H2|x, true, M)
4951;	                   Jumpcond(H3|x, false, L)
4952;	                   Complab(M)
4953;	                  }
4954;	                 return

4955;	    case NEQV:   B:=~B
4956;	    case EQV:
4957;	                 { let M,N:=NextParam(BlockA),NextParam(BlockA)
4958;	                   Jumpcond(H2|x,B,M)
4959;	                   Jumpcond(H3|x,false,L)
4960;	                   Compjump(N)
4961;	                   Complab(M)
4962;	                   Jumpcond(H3|x,true,L)
4963;	                   Complab(N)
4964;	                   return
4965;	                  }

4966;	    case COND:
4967;	                 { let M, N := NextParam(BlockA), NextParam(BlockA)
4968;	                   Jumpcond(H2|x, false, M)
4969;	                   Jumpcond(H3|x, B, L)
4970;	                   Compjump(N)
4971;	                   Complab(M)
4972;	                   Jumpcond(H4|x, B, L)
4973;	                   Complab(N)
4974;	                   return
4975;	                  }

4976;	    default:     Load(x)
4977;	                 Out2P(B => JT, JF, L)
4978;	                 SSP := SSP - 1
4979;	                 return
4980;	   }
4981;	 }

4982;	// Load the R-values of a list of elements.  This routine is called
4983;	//-- from
4984;	// Trans, case RTAP
4985;	// Load, case FNAP
4986;	// in both cases to process the list of actual parameters.

4987;	and Loadlist(x) be
4988;	{ if x eq 0 return
4989;	  x := rh x
4990;	  if H1|x eq COMMA do
4991;	  { Loadlist(H2|x)
4992;	    Loadlist(H3|x)
4993;	    return
4994;	   }
4995;	  if H1|x eq REPNAME do
4996;	  { 
4997;	{ let m_EvalConst(H3+x)
4998;	unless 1 le m le 2000 do
4999;	{ TransReport(37,x,0) ; m_1}
5000;	for i := 1 to m do Loadlist(H2|x)
5001;	}
5002;	    return
5003;	   }
5004;	  Load(x)
5005;	 }


		TRN4.BCP;4


5006;	// BCPL Compiler -- Part 4 of Trans.

5007;	// Transswitch Translate a "switchon" or a "branchon".
5008;	// *Simpass  Process an individual assignment - called by Assign.
5009;	// Assign  Translate an assignment statement.
5010;	// * local to this file.

5011;	get "<XBCPL>headtrn"            // Declarations for TRANS.

5012;	let Transswitch(x) be
5013;	{ let P := CaseP                // Save the current pointer into the
5014;	                                //-- case table.
5015;	  and DL, EL := Defaultlabel, Endcaselabel
5016;	  and CL := Curline             // The line on which the switch starts.
5017;	  let SB := SwitchBlock         // Were we in a switch block?
5018;	  SwitchBlock := true           // Now we are.

5019;	  let L := NextParam(BlockA)    // Label for the switching code.
5020;	  Endcaselabel := NextParam(BlockA)
5021;	                                // Label for exiting from the whole
5022;	                                //-- thing.

5023;	  Compjump(L)                   // Jump to the switching code.
5024;	  Defaultlabel := 0             // There is as yet no default.
5025;	  Trans(H3|x)                   // Translate the body.
5026;	  Compjump(Endcaselabel)        // Jump to the next peice of code.
5027;	  Complab(L)                    // Place the label for the switch.
5028;	  SwitchBlock := false
5029;	  Lookat(H2+x); Load(H2|x)      // That on which we are about to
5030;	                                //-- switch.
5031;	                                // Provide a default label.  When
5032;	                                //-- "branchon" is implemented, this
5033;	                                //-- should not be done for it.
5034;	  if Defaultlabel eq 0 do Defaultlabel := Endcaselabel
5035;	  let C := (CaseP - P) / CaseN  // The number of case labels.
5036;	  if C eq 0 do { TransReport(154, x, 0); return }
5037;	                                // We can"t do switches without any
5038;	                                //-- cases.
5039;	  Out3P(SWITCHON, C, Defaultlabel)

5040;	// Now output the collected cases in descending order.

5041;	  let N, Max := P, Casetable|P  // First find the largest case.
5042;	  for k := P+CaseN step CaseN to CaseP-CaseN
5043;	  do if Casetable|k > Max do N, Max := k, Casetable|k
5044;	  until N < 0 do                // Output all the cases.
5045;	  { OutN(Max); OutL(Casetable|(N+1))
5046;	                                // Output the current case.
5047;	    let NewMax, NewN := nil, -1
5048;	    for n := P step CaseN to CaseP-CaseN do
5049;	                                            // Look for the largest
5050;	                                            //-- case less than Max.
5051;	    { let m := Casetable|n      // The next case.
5052;	      if (m eq Max) & (n ne N) do
5053;	                                  // Identical case labels.
5054;	      { let C := Curline; Curline := CL
5055;	                                // The line on which the switch starts.
5056;	        TransReport(155, x, "the value is ", -1, m,
5057;	                    " and the lines on which the labels appear are",
5058;	                    -2, Casetable|(n+2), " and", -2, Casetable|(N+2),
5059;	                    0)
5060;	        Curline := C
5061;	       }
5062;	      if m < Max & (NewN < 0 \ m > NewMax) do NewMax, NewN := m, n
5063;	                                              // A candidate.
5064;	     }
5065;	    Max, N := NewMax, NewN
5066;	   }
5067;	  SSP := SSP - 1
5068;	  Complab(Endcaselabel)         // Place the label to leave the whole
5069;	                                //-- thing.
5070;	  Endcaselabel, Defaultlabel := EL, DL
5071;	  SwitchBlock := SB
5072;	  CaseP := P
5073;	 }

5074;	and Simpass(x, y, Type) be      // Assign y to x, with part-word type
5075;	                                //-- Type.
5076;	{ x := rh x
5077;	  switchon H1|x into
5078;	  {                             // What sort of thing are we storing
5079;	                                //-- into?

5080;	    case FNAP:                  // The following code processes
5081;	                                //-- functions on the left side.
5082;	                { unless SWbits << SW.Ncs do TransReport(191, x, 0)
5083;	                                             // Only for new calling
5084;	                                             //-- sequence.
5085;	                  let s := SSP
5086;	                  unless Type eq 0 do TransReport(108, x, 0)
5087;	                  if y eq 0 do TransReport(190, x, 0)
5088;	                                // Function call in a left-side
5089;	                                //-- conditional.
5090;	                  SSP := SSP + Savespacesize
5091;	                  if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5092;	                  Out2(STACK, SSP)
5093;	                  Loadlist(H3|x)
5094;	                  Load(y)
5095;	                  Load(H2|x)
5096;	                  Out2(LVRTAP, s)
5097;	                  SSP := s
5098;	                  if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5099;	                  return
5100;	                 }

5101;	    case NAME:
5102;	                { let t := CellWithName(x)
5103;	                                // Find the Dvec entry of the name.
5104;	                  if t eq 0 do  // Name is not declared.  Complain, and
5105;	                                //-- then declare it.
5106;	                  { TransReport(115, 0, H2|x, 0)
5107;	                    t := DvecS  // The next symbol table entry.
5108;	                    AddName(x, LOCAL, 0); DvecE := DvecS
5109;	                                // Declare it as a fictitious local.
5110;	                   }
5111;	                  unless y eq 0 do { Load(y); SSP := SSP - 1 }
5112;	                                // Load the right side.
5113;	                  let N := Dvec|(t+1)
5114;	                                // The datum associated with the name.
5115;	                  switchon lh Dvec|t into
5116;	                                // What sort of name is it?
5117;	                  { default:
5118;	                      TransReport(122, 0, H2|x, 0)
5119;	                                // Bad sort of name.
5120;	                      AddName(x, LOCAL, 0); DvecE := DvecS
5121;	                                // Don"t get this message again.
5122;	                      return

5123;	                    case LOCAL:
5124;	                      if t < DvecP do TransReport(116, 0, H2|x, 0)
5125;	                                      // Dynamic free variable.
5126;	                      Out2( (table SP,
5127;	                                   SPRH,
5128;	                                   SPLH,
5129;	                                   SPQ1,
5130;	                                   SPQ2,
5131;	                                   SPQ3,
5132;	                                   SPQ4,
5133;	                                   SPRHZ,
5134;	                                   SPLHZ)|Type, N)
5135;	                      return

5136;	                    case GLOBAL:
5137;	                                // Storing into a global.
5138;	                      Out2( (table SG,
5139;	                                   SGRH,
5140;	                                   SGLH,
5141;	                                   SGQ1,
5142;	                                   SGQ2,
5143;	                                   SGQ3,
5144;	                                   SGQ4,
5145;	                                   SGRHZ,
5146;	                                   SGLHZ)|Type, N)
5147;	                      return

5148;	                    case EXT:   // Storing into an external.
5149;	                      N := rh N
5150;	                                // Offset in ExtDecl.
5151;	                      if N < 0 do N := EnterExt(t)
5152;	                                  // Not yet in ExtDecl, so insert it.
5153;	                      N := ExtDecl|(N+1)

5154;	                    case LABEL: // Storing into a label.
5155;	                      Out2P( (table SL,
5156;	                                    SLRH,
5157;	                                    SLLH,
5158;	                                    SLQ1,
5159;	                                    SLQ2,
5160;	                                    SLQ3,
5161;	                                    SLQ4,
5162;	                                    SLRHZ,
5163;	                                    SLLHZ)|Type, N)
5164;	                      return

5165;	                    case INDEX: // Storing into an index register.
5166;	                      { let Op := (table SX,
5167;	                                         -1,
5168;	                                         -1,
5169;	                                         SXQ1,
5170;	                                         SXQ2,
5171;	                                         -1,
5172;	                                         -1)|Type
5173;	                                // OCODE operator.
5174;	                        if Op < 0 do
5175;	                        { TransReport(121, x, 0); Op := SX
5176;	                         }
5177;	                        if N > #17 do TransReport(126, x, 0)
5178;	                        Out2(Op, N)
5179;	                        return
5180;	                       }

5181;	                   }
5182;	                 }              // end of case NAME

5183;	// Continue the branch on the principle operator on the left side.

5184;	    case LHZ:
5185;	    case RHZ:
5186;	    case LH:
5187;	    case RH:
5188;	    case Q1:
5189;	    case Q2:
5190;	    case Q3:
5191;	    case Q4:    unless Type eq 0 do TransReport(108, x, 0)
5192;	                Type := selecton H1|x into
5193;	                { case RH:  1
5194;	                  case LH:  2
5195;	                  case Q1:  3
5196;	                  case Q2:  4
5197;	                  case Q3:  5
5198;	                  case Q4:  6
5199;	                  case RHZ: 7
5200;	                  case LHZ: 8
5201;	                 }
5202;	                Assign(H2|x, y, Type)
5203;	                return

5204;	    case RV:
5205;	    case VECAP: unless y eq 0 do Load(y)
5206;	                LoadLV(x)
5207;	                Out1( (table STIND,
5208;	                             STINDRH,
5209;	                             STINDLH,
5210;	                             STINDQ1,
5211;	                             STINDQ2,
5212;	                             STINDQ3,
5213;	                             STINDQ4,
5214;	                             STINDRHZ,
5215;	                             STINDLHZ)|Type )
5216;	                SSP := SSP - (y eq 0 => 1, 2)
5217;	                return

5218;	    case COND:                  // A conditional on the left side.
5219;	                { let L, M := NextParam(BlockA), NextParam(BlockA)
5220;	                                // Label exit, false arm.
5221;	                  and S := SSP
5222;	                  unless y eq 0 do Load(y)
5223;	                  Jumpcond(H2|x, false, M)
5224;	                                // Jump if the boolean is false.
5225;	                  Simpass(H3|x, 0, Type)
5226;	                                // Compile the store for the true arm.
5227;	                  Compjump(L)   // Hop out.
5228;	                  SSP := y eq 0 => S, S+1
5229;	                  if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5230;	                  Complab(M)
5231;	                  Simpass(H4|x, 0, Type)
5232;	                                // The store for the false arm.
5233;	                  Complab(L)
5234;	                  SSP := S
5235;	                  if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5236;	                  return
5237;	                 }

5238;	    case RIGHTLUMP:             // P >> QN _ Y
5239;	                { unless Type eq 0 do TransReport(108, x, 0)
5240;	                                      // No subwords of structures,
5241;	                                      //-- please.
5242;	                  unless y eq 0 do Load(y)
5243;	                  Load(H2|x)    // Load P

5244;	                  let V := DoQualName(H3|x, false, false, false)
5245;	                                // Process the offset of QN.
5246;	                  let N := V << QN.N
5247;	                                // The constant part of the offset.

5248;	                  switchon V << QN.M into
5249;	                                // What sort of thing was loaded?
5250;	                  { case 1:     // Word offset loaded.
5251;	                      Out1(PLUS)
5252;	                                // Add it to the pointer P.
5253;	                    case 0:     // Nothing loaded.
5254;	                      Out2(LN, N)
5255;	                                // Load the number.
5256;	                      endcase

5257;	                    case 2:     // Bit offset loaded.
5258;	                      unless N eq 0 do { Out2(LN, N); Out1(PLUS) }
5259;	                                // Add N.
5260;	                   }
5261;	                  Out1C(STINDC, V << QN.W)
5262;	                                // The width.
5263;	                  SSP := SSP - (y eq 0 => 2, 3)
5264;	                  return
5265;	                 }

5266;	    case LEFTLUMP:              // Z << QN _ Y
5267;	                { unless Type eq 0 do TransReport(108, x, 0)
5268;	                                      // No subwords of structures,
5269;	                                      //-- please.
5270;	                  unless y eq 0 do Load(y)
5271;	                  let Z := H2|x // The place into which to store.
5272;	                  switchon H1|Z into
5273;	                                // What sort of place is it?
5274;	                  { default:    // Something mysterious.
5275;	                      TransReport(105, x, 0); return

5276;	                    case VECAP: // (A|B) << QN
5277;	                    case RV:    // (rv A) << QN
5278;	                    case COND:  // (P => A, B) << QN
5279;	                      { LoadLV(Z)
5280;	                                // Load the L-value of the place into
5281;	                                //-- which to store.
5282;	                        let V := DoQualName(H3|x, false, true, false)
5283;	                                // Process the offset - no M_1.
5284;	                        let N, W := V << QN.N, V << QN.W
5285;	                                // The constant part of the offset,
5286;	                                //-- width.
5287;	                        switchon V << QN.M into
5288;	                                // What sort of load was done?
5289;	                        { case 0:
5290;	                                // Nothing loaded.
5291;	                            unless 0 le N < WordSizeOb
5292;	                            do TransReport(2,,169, x, 0)
5293;	                            unless N+W le WordSizeOb
5294;	                            do TransReport(4,,193, x, 0)
5295;	                            Out2(LN, N)
5296;	                                // Load the constant.
5297;	                            endcase
5298;	                          case 2:
5299;	                                // Bit offset loaded.
5300;	                            unless N eq 0 do
5301;	                            { Out2(LN, N); Out1(PLUS)
5302;	                             }  // Add the offset.
5303;	                         }
5304;	                        Out1C(STINDC, W)
5305;	                                // Width.
5306;	                        SSP := SSP - (y eq 0 => 2, 3)
5307;	                        return
5308;	                       }
5309;	                    case NAME:  // Name << QN _ Y
5310;	                      { let Name := CellWithName(Z)
5311;	                                // What kind of name is it?
5312;	                        if Name eq 0 do
5313;	                                        // It is not defined.  Oops.
5314;	                        { TransReport(115, 0, H2|Z, 0)
5315;	                          Name := DvecS
5316;	                          AddName(Z, LOCAL, 0)
5317;	                          DvecE := DvecS
5318;	                                // Declare it.
5319;	                         }
5320;	                        let Datum := Dvec|(Name+1)
5321;	                                // The datum associated with the name.
5322;	                        and OcodeOp, OutFunction := nil, OutL
5323;	                        switchon lh Dvec|Name into
5324;	                                // What kind of name was it?
5325;	                        { default:
5326;	                            TransReport(114, x, 0); return

5327;	                          case LOCAL:
5328;	                            if Name < DvecP & Datum ne 0
5329;	                            do TransReport(116, x, H2|Z, 0)
5330;	                                // non-local free
5331;	                            OcodeOp, OutFunction := SPC, OutN
5332;	                            endcase

5333;	                          case GLOBAL:
5334;	                            OcodeOp, OutFunction := SGC, OutN
5335;	                            endcase

5336;	                          case EXT:
5337;	                            if Datum eq -1 do Datum := EnterExt(Name)
5338;	                            Datum := rh ExtDecl|(Datum+1)

5339;	                          case LABEL:
5340;	                            OcodeOp := SLC
5341;	                         }
5342;	                        let V := DoQualName(H3|x, false, true, false)
5343;	                                // Load the offset.
5344;	                        let N, W := V << QN.N, V << QN.W
5345;	                                // Constant offset, width.
5346;	                        switchon V << QN.M into
5347;	                                // What sort of load was done?
5348;	                        { case 0:
5349;	                                // Nothing loaded.
5350;	                            unless 0 le N < WordSizeOb
5351;	                            do TransReport(2,,169, x, 0)
5352;	                            unless N+W le WordSizeOb
5353;	                            do TransReport(4,,193, x, 0)
5354;	                            Out2(LN, N)
5355;	                            endcase

5356;	                          case 2:
5357;	                            unless N eq 0 do
5358;	                            { Out2(LN, N); Out1(PLUS)
5359;	                             }
5360;	                         }
5361;	                        Out1C(OcodeOp, W); OutFunction(Datum)
5362;	                        SSP := SSP - (y eq 0 => 1, 2)
5363;	                        return
5364;	                       }
5365;	                   }            // end switchon H1|Z
5366;	                 }              // If so, they must both be zero.

5367;	    default:    TransReport(109, x, 0)
5368;	   }
5369;	 }

5370;	and Assign(x, y, Type) := valof
5371;	{ if x eq 0 \ y eq 0 do
5372;	  { unless x eq 0 & y eq 0 do TransReport(110, 0, 0)
5373;	    resultis 0
5374;	   }
5375;	  x, y := rh x, rh y
5376;	  switchon H1|y into            // What sort of value is on the right?
5377;	  { case COMMA:   unless H1|x eq COMMA do
5378;	                  { TransReport(110, x, 0); resultis 0
5379;	                   }
5380;	                  resultis Assign(Assign(x, H2|y, Type), H3|y, Type)

5381;	    case REPVAL:  unless #400000 > lh H2|y > 0
5382;	                  do TransReport(127, x, 0)
5383;	    case REPNAME: { let m_EvalConst(H3+y)
5384;	unless 1 le m le 2000 do { TransReport(37,y,0) ; m_1}
5385;	for i := 1 to m
5386;	                  do x := Assign(x, H2|y, Type)
5387;	                  resultis x
5388;	}

5389;	    default:
5390;	   }

5391;	  if H1|x eq COMMA do { Simpass(H2|x, y, Type); resultis H3|x }
5392;	  Simpass(x, y, Type)
5393;	  resultis 0
5394;	 }



		TRN5.BCP;4


5395;	// BCPL Compiler -- Part 5 of Trans.

5396;	// Load  Load the value of an expression.
5397;	// *LoadFOP  Load a floating point arithmetic operation.
5398;	// LoadLV  Load the L-value of an expression.
5399;	// * local to this file.

5400;	get "<bcpl>head"
5401;	get "<XBCPL>headtrn"            // Declarations for TRANS.

5402;	let Load(x) be
5403;	{ if #400000 > lh x > 0 do      // An evaluated expression.
5404;	  { SSP := SSP + 1
5405;	    if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5406;	    test H1|rh x eq NIL         // Is it a NIL node?
5407;	    ifso Out2(STACK, SSP)       // Yes.  Tell CG.
5408;	    ifnot Out2(LN, rv lh x)     // No.  Load the number.
5409;	    return
5410;	   }
5411;	  x := rh x
5412;	  if x eq 0 do
5413;	  { TransReport(148, x, 0)
5414;	    SSP := SSP + 1
5415;	    if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5416;	    return
5417;	   }

5418;	  let Op := H1|x
5419;	  switchon Op into
5420;	  { default:          TransReport(147, x, 0)
5421;	                      SSP := SSP + 1
5422;	                      if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5423;	                      return

5424;	    case LINE:
5425;	                      { let CL := Curline; Curline := H2|x
5426;	                        Out2(LINE, Curline)
5427;	                        Load(H3|x)
5428;	                        Curline := CL
5429;	                        return
5430;	                       }

5431;	// Following are the non-commutative infix binary operators.

5432;	    case MINUS:
5433;	    case LS:
5434;	    case GR:
5435;	    case LE:
5436;	    case GE:
5437;	    case LSHIFT:
5438;	    case RSHIFT:
5439;	    case LSCALE:
5440;	    case RSCALE:
5441;	    case FMINUS:
5442;	    case FDIV:
5443;	    case FLS:
5444;	    case FGR:
5445;	    case DIV:
5446;	    case REM:
5447;	    case COMCOM:
5448;	                      Load(H2|x)
5449;	                      Load(H3|x)
5450;	                      Out1(Op)
5451;	                      SSP := SSP - 1
5452;	                      return

5453;	// Following are the commutative infix binary operators.

5454;	    case VECAP:
5455;	    case MULT:
5456;	    case PLUS:
5457;	    case EQ:
5458;	    case NE:
5459;	    case LOGAND:
5460;	    case LOGOR:
5461;	    case EQV:
5462;	    case NEQV:
5463;	    case EQUIV:
5464;	    case NEQUIV:
5465;	    case FPLUS:
5466;	    case FMULT:
5467;	    case FEQ:
5468;	                      { let A, B := rh H2|x, rh H3|x
5469;	                        if H1|A eq NAME \ H1|A eq NUMBER do
5470;	                                                            // Load the
5471;	                                                            //-- simple
5472;	                                                            //-- one
5473;	                                                            //-- first.
5474;	                        { let t := A; A := B; B := t
5475;	                         }
5476;	                        Load(A)
5477;	                        Load(B)
5478;	                        test Op eq VECAP then { Out1(PLUS); Out1(RV) }
5479;	                        or Out1(Op)
5480;	                        SSP := SSP - 1
5481;	                        return
5482;	                       }

5483;	    case RIGHTLUMP:
5484;	    case LEFTLUMP:
5485;	                      { let L := Op eq LEFTLUMP
5486;	                                // Which lump?
5487;	                        Load(H2|x)
5488;	                                // The pointer (>>) or the object (<<).
5489;	                        let V := DoQualName(H3|x, false, L, false)
5490;	                                // Process the offset - no M_1 if L.
5491;	                        let N := V << QN.N
5492;	                                // The constant part of the offset.
5493;	                        switchon V << QN.M into
5494;	                                // What sort of thing has been loaded?
5495;	                        { case 1:
5496;	                                // Word offset loaded.
5497;	                            Out1(PLUS)
5498;	                                // Add the offset to the pointer.
5499;	                          case 0:
5500;	                                // Nothing loaded.
5501;	                            Out2(LN, N)
5502;	                                // Load the constant offset.
5503;	                            endcase
5504;	                          case 2:
5505;	                                // Bit offset loaded.
5506;	                            unless N eq 0 do
5507;	                            { Out2(LN, N); Out1(PLUS)
5508;	                             }  // Add the constant part.
5509;	                         }
5510;	                        let T := V << QN.T
5511;	                                // The access type.
5512;	                        Out1( (L => (table CFG,
5513;	                                           CFGN,
5514;	                                           CFGB), (table RVC,
5515;	                                                         RVCN,
5516;	                                                         RVCB)) | T )
5517;	                        unless T eq 2 do OutC(V << QN.W)
5518;	                                         // Width, unless bitb.
5519;	                        SSP := SSP - 1
5520;	                        return
5521;	                       }

5522;	    case CSIZE:       Out2(LN,EvalSize(H2|x)/WordSizeOb+1)
5523;	                      SSP:=SSP+1
5524;	                      if PDRMAXSSP<SSP do PDRMAXSSP:=SSP
5525;	                      return

5526;	    case SIZE:        Out2(LN, EvalSize(H2|x))
5527;	                      SSP := SSP + 1
5528;	                      if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5529;	                      return

5530;	    case OFFSET:
5531;	                      { let V := DoQualName(H2|x, true, true, false)
5532;	                                // Process the offset -- wide OK, no
5533;	                                //-- M_1.
5534;	                        let N := V << QN.N
5535;	                                // The constant part of the offset.
5536;	                        switchon V << QN.M into
5537;	                                // What sort of thing was loaded?
5538;	                        { case 0:
5539;	                                // Nothing loaded.
5540;	                            Out2(LN, N); endcase

5541;	                                // Load N.
5542;	                          case 2:
5543;	                                // Bit offset loaded.
5544;	                            unless N eq 0 do
5545;	                            { Out2(LN, N); Out1(PLUS)
5546;	                             }  // Add N.
5547;	                         }
5548;	                        SSP := SSP + 1
5549;	                        if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5550;	                        return
5551;	                       }

5552;	    case NEG:
5553;	    case FNEG:
5554;	    case NOT:
5555;	    case RV:
5556;	    case RHZ:
5557;	    case LHZ:
5558;	    case Q1Z:
5559;	    case Q2Z:
5560;	    case Q3Z:
5561;	    case Q4Z:
5562;	    case RH:
5563;	    case LH:
5564;	    case Q1:
5565;	    case Q2:
5566;	    case Q3:
5567;	    case Q4:
5568;	                      Load(H2|x)
5569;	                      Out1(Op)
5570;	                      return

5571;	    case NUMBARGS:
5572;	    case LEFTSIDE:    unless FunctionBody \ RoutineBody
5573;	                      do TransReport(157, x, 0)

5574;	    case TRUE:
5575;	    case FALSE:       Out1(Op)
5576;	                      SSP := SSP + 1
5577;	                      if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5578;	                      return

5579;	    case NIL:         SSP := SSP + 1
5580;	                      if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5581;	                      Out2(STACK, SSP)
5582;	                      return

5583;	    case LV:          LoadLV(H2|x)
5584;	                      return

5585;	    case ERROR:                 // He evidently wants an error message
5586;	                                //-- in TRANS.
5587;	                      TransReport(2,,156, 0, 0)
5588;	                                // Oblige him.
5589;	                      return

5590;	    case NUMBER:      Out2(LN, H2|x)
5591;	                      SSP := SSP + 1
5592;	                      if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5593;	                      return

5594;	    case CHARCONST:   Out2(LC, H2|x)
5595;	                      SSP := SSP + 1
5596;	                      if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5597;	                      return

5598;	    case STRINGCONST:
5599;	    case ASCIZCONST:
5600;	                      { let v := vec StringMaxOb
5601;	                        Unpackstring(lv H2|x, v)
5602;	                        Out2((Op=ASCIZCONST)=> LZTR,LSTR, v|0)
5603;	                        for i := 1 to v|0 do OutC(v|i)
5604;	                        SSP := SSP + 1
5605;	                        if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5606;	                        return
5607;	                       }

5608;	    case NAME:
5609;	                      { let t := CellWithName(x)
5610;	                                // Location in the name table.
5611;	                        let N := Dvec|(t+1)
5612;	                                // The datum associated with the name.
5613;	                        SSP := SSP + 1
5614;	                        if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5615;	                        if t eq 0 do
5616;	                                     // The name has not been declared.
5617;	                        { TransReport(115, 0, H2|x, 0)
5618;	                                // Complain about it.
5619;	                          AddName(x, LOCAL, 0); DvecE := DvecS
5620;	                                // Declare it local so no more
5621;	                                //-- complaints.
5622;	                          return
5623;	                         }
5624;	                        switchon lh Dvec|t into
5625;	                                // What type of name is it?
5626;	                        { default:
5627;	                            TransReport(123, 0, H2|x, 0)
5628;	                            return

5629;	                          case NUMBER:
5630;	                            Out2(LN, N)
5631;	                            return

5632;	                          case EXT:
5633;	                            N := rh N
5634;	                                // The entry in ExtDecl.
5635;	                            if N eq -1 do N := EnterExt(t)
5636;	                                          // Not yet there, so enter
5637;	                                          //-- it.
5638;	                            Out2P(LL, rh ExtDecl|(N+1))
5639;	                                // Load the relevant label.
5640;	                            return

5641;	                          case LOCAL:
5642;	                            if t < DvecP & N ne 0
5643;	                            do TransReport(116, 0, H2|x, 0)
5644;	                                // Non-local dynamic.
5645;	                            Out2(LP, N); return

5646;	                          case INDEX:
5647;	                            Out2(LX, N)
5648;	                            return

5649;	                          case GLOBAL:
5650;	                            Out2(LG, N)
5651;	                            return

5652;	                          case LABEL:
5653;	                            Out2P(LL, N)
5654;	                            return
5655;	                         }
5656;	                       }

5657;	    case VALOF:
5658;	                      { let DS, DE := DvecS, DvecE
5659;	                        and RL := Resultlabel
5660;	                        and VB := ValofBlock
5661;	                        Resultlabel := NextParam(BlockA)
5662;	                        ValofBlock := true
5663;	                        Decllabels(H2|x)
5664;	                        Trans(H2|x)
5665;	                        Complab(Resultlabel)
5666;	                        Out2(RSTACK, SSP)
5667;	                        SSP := SSP + 1
5668;	                        if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5669;	                        DvecS, DvecE := DS, DE
5670;	                        Resultlabel := RL
5671;	                        ValofBlock := VB
5672;	                        return
5673;	                       }

5674;	    case FNAP:
5675;	                      { if H1|(H2|x)=RNAME do
5676;	                        { let S:=SSP
5677;	                          let ln:=(H3|x=0)=>0,ListLength(H3|x)
5678;	                          Out1(RNAME)
5679;	                          Loadlist(H3|x)
5680;	                          Out3P(RFNAP,(rv H2|(H2|x)) rshift 22,ln)
5681;	                          SSP:=S+1
5682;	                          if PDRMAXSSP < SSP do PDRMAXSSP:=SSP
5683;	                          return
5684;	                         }
5685;	                        let S := SSP
5686;	                        SSP := SSP + Savespacesize
5687;	                        if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5688;	                        Out2(STACK, SSP-1)
5689;	                        Out2(NUMBARGS,(H3|x=0)=>0,ListLength(H3|x))
5690;	                        Loadlist(H3|x)
5691;	                        Load(H2|x)
5692;	                        Out2(FNAP, S)
5693;	                        SSP := S + 1
5694;	                        if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5695;	                        return
5696;	                       }

5697;	    case COND:
5698;	                      { let L, M :=
5699;	                          NextParam(BlockA), NextParam(BlockA)
5700;	                        let S := SSP
5701;	                        Jumpcond(H2|x, false, M)
5702;	                        Load(H3|x)
5703;	                        Out2P(RES, L)
5704;	                        SSP := S
5705;	                        if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5706;	                        Complab(M)
5707;	                        Load(H4|x)
5708;	                        Out2P(RES, L)
5709;	                        Complab(L)
5710;	                        Out2(RSTACK, S)
5711;	                        SSP := S+1
5712;	                        if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5713;	                        return
5714;	                       }

5715;	    case TABLE:
5716;	                      { let M := NextParam(BlockB)
5717;	                        SaveStaticItem(x, M)
5718;	                        Out2P(LLL, M)
5719;	                        SSP := SSP + 1
5720;	                        if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5721;	                        return
5722;	                       }
5723;	   }
5724;	 }

5725;	// Load the L-value of a suitable expression.  This routine is called
5726;	//-- from
5727;	// Simpass, for RV, VECAP or LEFTLUMP to the left of an assignment
5728;	// Load, for case LV

5729;	and LoadLV(x) be
5730;	{ if x eq 0 do Err:
5731;	  { TransReport(113, x, 0)      // Error in operand of lv.
5732;	    SSP := SSP + 1
5733;	    if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5734;	    return
5735;	   }

5736;	  switchon H1|x into
5737;	  { default:
5738;	       goto Err

5739;	    case NAME:
5740;	       { let t := CellWithName(x)
5741;	                                // Location in name table.
5742;	         SSP := SSP + 1
5743;	         if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5744;	         if t eq 0 do           // The name has been used but not
5745;	                                //-- declared.
5746;	         { TransReport(115, 0, H2|x, 0)
5747;	                                // Complain.
5748;	           AddName(x, LOCAL, 0); DvecE := DvecS
5749;	                                // Declare it, so no more error
5750;	                                //-- messages.
5751;	           return
5752;	          }
5753;	         let N := Dvec|(t+1)    // The datum associated with the name.
5754;	         switchon lh Dvec|t into
5755;	                                // Branch on the type of name it is.
5756;	         { case LOCAL:
5757;	             if t < DvecP & N ne 0 do TransReport(116, 0, H2|x, 0)
5758;	                                      // Non-local dynamic.
5759;	             Out2(LLP, N)
5760;	             return

5761;	           case EXT:
5762;	             N := rh N          // The entry in ExtDecl.
5763;	             if N eq -1 do N := EnterExt(t)
5764;	                                // Not yet there, so enter it.
5765;	             Out2P(LLL, rh ExtDecl|(N+1))
5766;	             return

5767;	           case GLOBAL:
5768;	             Out2(LLG, N)
5769;	             return

5770;	           case LABEL:
5771;	             Out2P(LLL, N)
5772;	             return

5773;	           default:
5774;	             TransReport(122, x, H2|x, 0)
5775;	                                // Bad sort of name -- INDEX, NUMBER or
5776;	                                //-- STRUCTURE.
5777;	             return
5778;	          }
5779;	        }

5780;	    case RV:
5781;	       Load(H2|x)
5782;	       return

5783;	    case VECAP:
5784;	       { let A, B := H2|x, H3|x
5785;	         if H1|x eq NAME do A, B := H3|x, H2|x
5786;	         Load(A)
5787;	         Load(B)
5788;	         Out1(PLUS)
5789;	         SSP := SSP - 1
5790;	         return
5791;	        }

5792;	    case COND:                  // lv of a conditional expression.
5793;	       { let S := SSP
5794;	         and ResLabel, FalseArm :=
5795;	           NextParam(BlockA), NextParam(BlockA)
5796;	         Jumpcond(H2|x, false, FalseArm)
5797;	                                // Hop to the false arm if conditional
5798;	                                //-- is false.
5799;	         LoadLV(H3|x)           // Load the lv of the true arm
5800;	                                //-- expression.
5801;	         Out2P(RES, ResLabel)   // Hop to the RESlabel with the value
5802;	                                //-- in hand.
5803;	         SSP := S
5804;	         if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5805;	         Complab(FalseArm)      // Place the label for the false arm.
5806;	         LoadLV(H4|x)           // Load the lv of the false arm
5807;	                                //-- expression.
5808;	         Out2P(RES, ResLabel)   // Hop to the RESlabel with the value
5809;	                                //-- in hand.
5810;	         Complab(ResLabel)      // Place the RESlabel.
5811;	         Out2(RSTACK, S)        // Restore the code generator"s
5812;	                                //-- simulated stack pointer.
5813;	         SSP := S + 1
5814;	         if PDRMAXSSP < SSP do PDRMAXSSP := SSP
5815;	         return
5816;	        }

5817;	    case LEFTLUMP:              // lv (X << QN)   What does it mean?
5818;	       TransReport(2,,179, x, 0)
5819;	                                // Warn him.
5820;	       LoadLV(H2|x)             // Return the lv of X.
5821;	       return

5822;	    case RIGHTLUMP:             // lv (P >> QN)
5823;	       { Load(H2|x)             // Load the pointer P.
5824;	         let V := DoQualName(H3|x, true, false, false)
5825;	                                // Process the offset -- wide OK.
5826;	         let N := V << QN.N     // The constant part of the offset.
5827;	         switchon V << QN.M into
5828;	                                // What sort of thing was loaded?
5829;	         { case 1:              // Word offset loaded.
5830;	             Out1(PLUS)         // Add it to the pointer.
5831;	           case 0:              // Nothing loaded.
5832;	             N := N / WordSizeOb
5833;	                                // Number of words.
5834;	             unless N eq 0 do { Out2(LN, N); Out1(PLUS) }
5835;	                                // Add N.
5836;	             endcase

5837;	           case 2:              // Bit offset loaded.
5838;	             unless N eq 0 do { Out2(LN, N); Out1(PLUS) }
5839;	                                // Add N.
5840;	             Out2(LN, WordSizeOb); Out1(DIV)
5841;	                                // Divide to get number of words.
5842;	             Out1(PLUS)         // Add it to the pointer.
5843;	          }
5844;	         SSP := SSP - 1
5845;	        }
5846;	   }
5847;	 }


		TRN6.BCP;5


5848;	// BCPL Compiler -- Part 6 of Trans.

5849;	// Lookat  Attempt to evaluate a piece of tree at compile time.
5850;	// *TraceTable Apply a table to a constant subscript, at compile time.
5851;	// *EvalBinop Evaluate a binary operator, at compile time.
5852;	// *EvalUnop Evaluate a unary operator, at compile time.
5853;	// *SingleBit Does operand have only one non-zero bit, and if so,
5854;	//-- which one?
5855;	// *EvalQN  Do a structured access of a constant.
5856;	// *EvalStringAp Apply a string to a constant.
5857;	// EvalConst Evaluate a constant expression.
5858;	// * local to this compilation.

5859;	get "<XBCPL>headtrn"            // Declarations for TRANS.

5860;	static
5861;	{ Constant : false,,false
5862;	 }                              // Set to true when called from
5863;	                                //-- EvalConst, and false otherwise.

5864;	// Lookat is applied to the address of a tree node (i.e., with
5865;	//-- Lookat(H2+x)   ).
5866;	// Let LVX be Lookat"s argument, and let  x _ rv LVX .  There are three
5867;	//-- cases...
5868;	// 1. The node can be evaluated at compile time.  Then replace  rv LVX
5869;	//-- by  (LOC ,, NODE)  where
5870;	// LOC  is the address of a word containing the computed value, and
5871;	//-- NODE  is a usual tree node.
5872;	// 2. The node can be simplified, as for a  COND  with constant
5873;	//-- condition or a table subscripted
5874;	// by a constant.  Then replace  rv LVX  by the simpler node and recur.
5875;	//--  For convenience in
5876;	// debugging, set  lh rv LVX  to  -1  to indicate that a change has
5877;	//-- been made.
5878;	// 3. No simplification is possible.  Lookat has been applied
5879;	//-- recursively to all sons of
5880;	// the node that might be part of an expression.

5881;	let Lookat(LVX) be
5882;	{ let x := rv LVX               // The usual sort of node.
5883;	  if x eq 0 return              // Nothing to do.
5884;	  if lh x ne 0 return           // We have been here already.

5885;	  let Value := nil              // Put a computed value here if we get
5886;	                                //-- one.
5887;	  and Node := 0                 // Put a new node here if we get one.
5888;	  and Op := H1|x

5889;	  switchon Op into
5890;	  {                             // The following nodes already have a
5891;	                                //-- value, in the second word of the
5892;	                                //-- node.
5893;	    case NUMBER:
5894;	    case CHARCONST:
5895;	    case TRUE:
5896;	    case FALSE:
5897;	    case NIL: lh rv LVX := H2+x // The address of the relevant value.
5898;	              return

5899;	// The following are the infix binary operators.

5900;	    case PLUS:
5901;	    case MINUS:
5902;	    case MULT:
5903;	    case EQ:
5904;	    case NE:
5905;	    case GR:
5906;	    case LS:
5907;	    case GE:
5908;	    case LE:
5909;	    case LSHIFT:
5910;	    case RSHIFT:
5911;	    case LSCALE:
5912;	    case RSCALE:
5913;	    case LOGAND:
5914;	    case LOGOR:
5915;	    case EQV:
5916;	    case NEQV:
5917;	    case EQUIV:
5918;	    case NEQUIV:
5919;	    case DIV:
5920;	    case REM:
5921;	    case COMCOM:
5922;	    case FPLUS:
5923;	    case FMINUS:
5924;	    case FMULT:
5925;	    case FDIV:
5926;	    case FLS:
5927;	    case FEQ:
5928;	    case FGR:
5929;	              { Lookat(H2+x); Lookat(H3+x)
5930;	                                // Look at the two sons.
5931;	                let L, R := lh H2|x, lh H3|x
5932;	                                // The addresses of the simplified
5933;	                                //-- values.
5934;	                if (L&#400000) ne 0 do L:=L\#777777000000
5935;	                if (R&#400000) ne 0 do R:=R\#777777000000
5936;	                unless L > 0 \ R > 0 return
5937;	                                // Return if neither was evaluated.
5938;	                if L > 0 & R > 0 & Op ne DIV & Op ne FDIV &
5939;	                   Op ne FPLUS & Op ne FMINUS & Op ne FMULT &
5940;	                   Op ne FGR & Op ne FEQ & Op ne FLS
5941;	                do              // Both were evaluated.
5942;	                { Value := EvalBinop(Op, rv L, rv R)
5943;	                                // Compute the value.
5944;	                  endcase
5945;	                 }
5946;	                let LC, RC := L > 0, R > 0
5947;	                                // Switches for L and R being constant.
5948;	                and LX, RX := nil, nil
5949;	                                // For the values.
5950;	                and LAAAA0, LAAAA1, LT, LF, RAAAA0, RAAAA1, RT, RF :=
5951;	                  false repname 8
5952;	                                // Switches for zero, one, true, false.
5953;	                if LC do        // Left operand has been evaluated.
5954;	                { LX := rv L    // Value of the operand.
5955;	                  if LX eq 0 do LAAAA0 := true
5956;	                                // LAAAA0 is true if LX is +0 or -0
5957;	                  if LX eq 1 do LAAAA1 := true
5958;	                                // LX is 1
5959;	                  if LX = true do LT := true
5960;	                                  // LX is true
5961;	                  if LX = false do LF := true
5962;	                                   // LX is false
5963;	                 }
5964;	                if RC do        // Right operand has been evaluated.
5965;	                { RX := rv R    // The value of the operand.
5966;	                  if RX eq 0 do RAAAA0 := true
5967;	                                // RAAAA0 is true if RX is +0 or -0
5968;	                  if RX eq 1 do RAAAA1 := true
5969;	                  if RX = true do RT := true
5970;	                  if RX = false do RF := true
5971;	                 }

5972;	                switchon Op into
5973;	                { case PLUS:
5974;	                    if LAAAA0 do { Node := H3|x; endcase }
5975;	                                // 0+x => x
5976;	                    if RAAAA0 do { Node := H2|x; endcase }
5977;	                                // x+0 => x
5978;	                    return

5979;	                  case MINUS:
5980;	                    if LAAAA0 do { Node := List2(NEG, H3|x); endcase }
5981;	                                // 0-x => neg x
5982;	                    if RAAAA0 do { Node := H2|x; endcase }
5983;	                                // x-0 => x
5984;	                    return

5985;	                  case MULT:
5986;	                    { if LAAAA0 \ RAAAA0 do { Value := 0; endcase }
5987;	                                // 0*x => 0,. x*0 => 0
5988;	                      if LAAAA1 do { Node := H3|x; endcase }
5989;	                                // 1*x => x
5990;	                      if RAAAA1 do { Node := H2|x; endcase }
5991;	                                // x*1 => x
5992;	                      let n := SingleBit(LC => LX, RX)
5993;	                                // Is evaluated operand 2n?
5994;	                      if n < 0 return
5995;	                                // No.  Sigh.
5996;	                      Node :=
5997;	                        List3(LSCALE, (LC => H3, H2)|x,
5998;	                              List2(NUMBER, n))
5999;	                                // x*2n => x lscale n
6000;	                      endcase
6001;	                     }

6002;	                  case DIV:
6003;	                    { if RAAAA0 do
6004;	                      { TransReport(2,,133, x, 0); return
6005;	                       }        // x/0 => warning
6006;	                      if LC & RC do { Value := LX/RX; endcase }
6007;	                                // Both evaluated.
6008;	                      if RAAAA1 do { Node := H2|x; endcase }
6009;	                                // x/1 => x
6010;	                      if LAAAA0 do { Value := 0; endcase }
6011;	                                // 0/x => 0
6012;	                      unless RC return
6013;	                      let n := SingleBit(RX)
6014;	                                // Is denominator 2n?
6015;	                      if n < 0 return
6016;	                                // No.
6017;	                      Node := List3(RSCALE, H2|x, List2(NUMBER, n))
6018;	                                // x/2n => x rscale n
6019;	                      endcase
6020;	                     }

6021;	                  case LOGAND:
6022;	                    if LF \ RF do { Value := false; endcase }
6023;	                                // false&x => false,. x&false => false
6024;	                    if LT do { Node := H3|x; endcase }
6025;	                                // true&x => x
6026;	                    if RT do { Node := H2|x; endcase }
6027;	                                // x&true => x
6028;	                    return

6029;	                  case LOGOR:
6030;	                    if LT \ RT do { Value := true; endcase }
6031;	                                // true\x => true   x\true => true
6032;	                    if LF do { Node := H3|x; endcase }
6033;	                                // false\x => x
6034;	                    if RF do { Node := H2|x; endcase }
6035;	                                // x\false => x
6036;	                    return

6037;	                  case LSCALE:
6038;	                  case RSCALE:
6039;	                    if LAAAA0 do { Value := LX; endcase }
6040;	                                // XXXX_+0 scale x => XXXX_+0
6041;	                  case LSHIFT:
6042;	                  case RSHIFT:
6043;	                    if LF do { Value := 0; endcase }
6044;	                                // +0 shift x => +0
6045;	                    if RAAAA0 do { Node := H2|x; endcase }
6046;	                                // x shift 0 => x
6047;	                    return

6048;	                  case EQV:
6049;	                    if LF do { Node := List2(NOT, H3|x); endcase }
6050;	                                // false eqv x => ~x
6051;	                    if RF do { Node := List2(NOT, H2|x); endcase }
6052;	                                // x eqv false => ~x
6053;	                    if LT do { Node := H3|x; endcase }
6054;	                                // true eqv x => x
6055;	                    if RT do { Node := H2|x; endcase }
6056;	                                // x eqv true => x
6057;	                    return

6058;	                  case NEQV:
6059;	                    if LF do { Node := H3|x; endcase }
6060;	                                // false neqv x => x
6061;	                    if RF do { Node := H2|x; endcase }
6062;	                                // x neqv false => x
6063;	                    if LT do { Node := List2(NOT, H3|x); endcase }
6064;	                                // true neqv x => ~x
6065;	                    if RT do { Node := List2(NOT, H2|x); endcase }
6066;	                                // x neqv true => ~x
6067;	                    return

6068;	                  case COMCOM:
6069;	                    if LF do { Node := List2(RHZ, H3|x); endcase }
6070;	                                // false ,, x => rhz x
6071;	                    return

6072;	// case FPLUS: case FMINUS: case FMULT: case FDIV: case FLS: case FGR:
6073;	// {  LAAAA0, LAAAA1, RAAAA0, RAAAA1 _ false, false, false, false
6074;	// if LC do LAAAA0, LAAAA1 _ LX AAAAo_ 0.0, LX AAAAo_ 1.0
6075;	// if RC do RAAAA0, RAAAA1 _ RX AAAAo_ 0.0, RX AAAAo_ 1.0
6076;	// switchon Op into
6077;	// {  case FPLUS:
6078;	// if LAAAA0 do { Node _ H3|x; endcase }   //  0.0 AAAAo+ x => x
6079;	// if RAAAA0 do { Node _ H2|x; endcase }   //  x AAAAo+ 0.0 => x
6080;	// return
6081;	//
6082;	// case FMINUS:
6083;	// if LAAAA0 do { Node _ List2(FNEG, H3|x); endcase }   //  0.0 AAAAo-
6084;	                    //-- x => AAAAo- x
6085;	// if RAAAA0 do { Node _ H2|x; endcase }   //  x AAAAo- 0.0 => x
6086;	// return
6087;	//
6088;	// case FMULT:
6089;	// if LAAAA0 \ RAAAA0 do { Value _ 0.0; endcase }   //  0.0 AAAAo* x =>
6090;	                    //-- 0.0
6091;	// if LAAAA1 do { Node _ H3|x; endcase }   //  1.0 AAAAo* x => x
6092;	// if RAAAA1 do { Node _ H2|x; endcase }   //  x AAAAo* 1.0 => x
6093;	// return
6094;	//
6095;	// case FDIV:
6096;	// if RAAAA0 do TransReport(2,,133, x, 0)   //  x AAAAo/ 0.0 => warning
6097;	// /        if LC & RC do { Value _ LX AAAAo/ RX; endcase }   //  Both
6098;	                    //-- evaluated.
6099;	// if LAAAA0 do { Value _ 0.0; endcase }   //  0.0 AAAAo/ x => 0.0
6100;	// if RAAAA1 do { Node _ H2|x; endcase }   //  x AAAAo/ 1.0 => x
6101;	// return
6102;	//
6103;	// case FLS:   //  x AAAAo< 0.0  =>  x < 0
6104;	// if RAAAA0 do { Node _ List3(LS, H2|x, ZERONODE); endcase }
6105;	// return
6106;	//
6107;	// case FGR:   //  0.0 AAAAo> x  =>  0 > x
6108;	// if LAAAA0 do { Node _ List3(GR, ZERONODE, H3|x); endcase }
6109;	// return
6110;	// }
6111;	// endcase
6112;	// }

6113;	                  default:
6114;	                    return
6115;	                 }
6116;	                endcase         // Take all above "endcase"s to the end

6117;	                                //-- of this function.
6118;	               }

6119;	    case NEG:
6120;	    case NOT:
6121;	    case RHZ:
6122;	    case LHZ:
6123;	    case Q1Z:
6124;	    case Q2Z:
6125;	    case Q3Z:
6126;	    case Q4Z:
6127;	    case RH:
6128;	    case LH:
6129;	    case Q1:
6130;	    case Q2:
6131;	    case Q3:
6132;	    case Q4:                    // case FNEG:

6133;	              { Lookat(H2+x)    // Examine the son.
6134;	                let L := lh H2|x
6135;	                if (L&#400000) ne 0 do L:=L\#777777000000
6136;	                unless L > 0 return
6137;	                                // Done if not evaluated.
6138;	                Value := EvalUnop(Op, rv L)
6139;	                endcase
6140;	               }

6141;	    case NAME:
6142;	              { let t := CellWithName(x)
6143;	                if lh Dvec|t eq NUMBER do
6144;	                { Value := Dvec|(t+1); endcase
6145;	                 }              // Manifest constant name.
6146;	//***YUK
6147;	                unless (rh Constant)=-1 return
6148;	                                // All done, unless called from
6149;	                                //-- EvalConst.
6150;	                TransReport(119, 0, H2|x, 0)
6151;	                                // Complain.
6152;	                static
6153;	                { Value : 0
6154;	                 }              // Each value defined this way is
6155;	                                //-- different, for case constants.
6156;	                AddName(x, NUMBER, Value); DvecE := DvecS
6157;	                                // Declare it constant to avoid more
6158;	                                //-- messages.
6159;	                Value := Value + 1
6160;	                                // Get a new value next time.
6161;	                lh Constant := false
6162;	                return
6163;	               }

6164;	    case COND:
6165;	              { Lookat(H2+x)    // Examine the conditional arm.
6166;	                let B := lh H2|x
6167;	                if (B&#400000) ne 0 do B:=B\#777777000000
6168;	                unless B > 0 do { Lookat(H3+x); Lookat(H4+x); return }
6169;	                Node := (rv B => H3, H4)|x
6170;	                                // The selected arm.
6171;	                Lookat(lv Node)
6172;	                endcase
6173;	               }

6174;	    case VECAP:
6175;	              { Lookat(H2+x); Lookat(H3+x)
6176;	                                // Optimize the two sons.
6177;	                let A, B := H2|x, H3|x
6178;	                                // The two sons.
6179;	                if #400000 > lh A > 0 do
6180;	                { let t := A; A := B; B := t
6181;	                 }              // If either is constant it is B.
6182;	                unless #400000 > lh B > 0 return
6183;	                                // No hope if neither is a constant.
6184;	                B := rv lh B    // The value.
6185;	                let AR := rh A  // The tree node that is A.
6186;	                if H1|AR eq STRINGCONST do
6187;	                { Value := EvalStringAp(AR+1, B); endcase
6188;	                 }              // "xxxx"|n
6189;	                if H1|AR eq TABLE do
6190;	                { Node := TraceTable(H2|AR, B); endcase
6191;	                 }              // (table ...)|n
6192;	                if #400000 > lh A > 0 do
6193;	                { Node := List2(RV, List2(NUMBER, B + rv lh A)); endcase
6194;	                 }              // m|n => rv(m+n)
6195;	                if B eq 0 do { Node := List2(RV, A); endcase }
6196;	                                // x|0 => rv x
6197;	                return
6198;	               }

6199;	    case LV:
6200;	              { let y := H2|x
6201;	                if lh y ne 0 return
6202;	                if H1|y eq VECAP do
6203;	                { Node := List3(PLUS, H2|y, H3|y); Lookat(lv y); endcase
6204;	                 }              // lv(x|y) => x+y
6205;	                Lookat(H2+x)
6206;	                return
6207;	               }

6208;	    case RV:
6209;	              { let y := H2|x
6210;	                if lh y ne 0 return
6211;	                if H1|y eq LV do
6212;	                { Node := H2|y; Lookat(lv Node); endcase
6213;	                 }              // rv lv x => x
6214;	                if H1|y eq STRINGCONST do
6215;	                { Value := EvalStringAp(y+1, 0); endcase
6216;	                 }              // rv "xyz" => "xyz"|0
6217;	                if H1|y eq TABLE do
6218;	                { Node := TraceTable(H2|y, 0); Lookat(lv Node); endcase
6219;	                 }
6220;	                Lookat(H2+x)
6221;	                return
6222;	               }

6223;	    case CSIZE:
6224;	              Value:=EvalSize(H2|x)/WordSizeOb+1 ; endcase

6225;	    case SIZE:
6226;	              Value := EvalSize(H2|x); endcase

6227;	    case OFFSET:
6228;	              { let V := DoQualName(H2|x, true, nil, true)
6229;	                                // Process offset.  Wide OK, no load.
6230;	                unless V << QN.M eq 0 return
6231;	                                // Not a constant if something needed
6232;	                                //-- to be loaded.
6233;	                Value := V << QN.N; endcase

6234;	                                // Constant offset.
6235;	               }

6236;	    case LEFTLUMP:              // X << QN
6237;	              { Lookat(H2+x)    // Look at X.
6238;	                unless #400000 > lh H2|x > 0 return
6239;	                                // It"s not a constant.
6240;	                let V := DoQualName(H3|x, false, nil, true)
6241;	                                // Process QN.  No load.
6242;	                unless V << QN.M eq 0 return
6243;	                                // The offset is not a constant.
6244;	                Value := EvalQN(rv lh H2|x, V)
6245;	                                // Extract the desired value.
6246;	                endcase
6247;	               }

6248;	    case RIGHTLUMP:             // X >> QN.  Is X a table or a
6249;	                                //-- stringconstant?
6250;	              { Lookat(H2+x)    // Examine X.
6251;	                let Z := rh H2|x
6252;	                unless H1|Z eq TABLE \ H1|Z eq STRINGCONST return
6253;	                                // No hope except for these cases.
6254;	                let V := DoQualName(H3|x, false, nil, true)
6255;	                                // Process QN, with no load.
6256;	                unless V << QN.M eq 0 return
6257;	                                // Offset is not a constant.
6258;	                let N := V << QN.N
6259;	                                // The offset.
6260;	                V << QN.N := N rem WordSizeOb
6261;	                                // The offset in the word in question.
6262;	                N := N / WordSizeOb
6263;	                                // The number of words of offset.
6264;	                let A :=
6265;	                  H1|Z eq TABLE => TraceTable(H2|Z, N),
6266;	                  EvalStringAp(Z+1, N)
6267;	                                // The word in question.
6268;	                Value := EvalQN(A, V)
6269;	                                // Find the desired part of the word.
6270;	                endcase
6271;	               }

6272;	    case FNAP:
6273;	    case COMMA:
6274;	    case REPNAME:
6275;	    case REPVAL:
6276;	              Lookat(H3+x)

6277;	    case TABLE:
6278;	    case LIST:
6279;	    case VEC: Lookat(H2+x)

6280;	    case VALOF:
6281;	    case ASCIZCONST:
6282;	    case STRINGCONST:
6283;	    case NUMBARGS:
6284;	    case LEFTSIDE:
6285;	    case ERROR:
6286;	              return

6287;	    case LINE:
6288;	              Lookat(H3+x); return

6289;	    default:  TransReport(147, x, " in Lookat", 0)
6290;	              return
6291;	   }

6292;	// Come here for all the above ""endcase""s.

6293;	  if Node ne 0 do
6294;	  { if lh Node eq 0 do lh Node := -1
6295;	    rv LVX := Node
6296;	    return
6297;	   }
6298;	  Node := Value = 0 => ZERONODE, List2(NUMBER, Value)
6299;	  rv LVX := H2+Node ,, Node
6300;	 }

6301;	// TraceTable is applied to a table and a subscript.  It returns the
6302;	//-- relevant element of the table.

6303;	and TraceTable(X, N) := valof
6304;	{ static
6305;	  { n : nil
6306;	   }                            // A static location to hold N.

6307;	  let F(x) := valof
6308;	  { while H1|x eq COMMA do
6309;	    { let y := F(H2|x)
6310;	      if n < 0 resultis y
6311;	      x := H3|x
6312;	     }
6313;	    if H1|x eq REPNAME do
6314;	    { 
6315;	let m_EvalConst(H3+x)
6316;	unless 1 le m le 2000 do { TransReport(37,x,0) ; m_1}
6317;	for k := 1 to m do
6318;	      { let y := F(H2|x)
6319;	        if n < 0 resultis y
6320;	       }
6321;	      resultis 0                // Went too far.
6322;	     }
6323;	    n := n - 1
6324;	    resultis x
6325;	   }

6326;	  n := N
6327;	  resultis F(X)
6328;	 }

6329;	and EvalBinop(Op, a, b) := valof
6330;	switchon Op into
6331;	{ case PLUS:   resultis a + b

6332;	  case MINUS:  resultis a - b

6333;	  case EQ:     resultis a eq b

6334;	  case NE:     resultis a ne b

6335;	  case LS:     resultis a < b

6336;	  case GR:     resultis a > b

6337;	  case LE:     resultis a le b

6338;	  case GE:     resultis a ge b

6339;	  case MULT:   resultis a * b

6340;	  case DIV:    resultis a / b

6341;	  case REM:    resultis a rem b

6342;	  case FPLUS:  resultis a %+ b

6343;	  case FMINUS: resultis a %- b

6344;	  case FMULT:  resultis a %* b

6345;	  case FDIV:   resultis a %/ b

6346;	// case FGR: resultis a %> b
6347;	// case FEQ: resultis a %= b
6348;	// case FLS: resultis a %< b

6349;	  case COMCOM: resultis a ,, b

6350;	  case LSHIFT: resultis a lshift b

6351;	  case RSHIFT: resultis a rshift b
6352;	  case LSCALE: resultis a > 0 => a lshift b, -(-a lshift b)

6353;	                                // TO BE FIXED LATER
6354;	  case RSCALE: resultis a > 0 => a rshift b, -(-a rshift b)

6355;	                                // TO BE FIXED LATER
6356;	  case LOGAND: resultis a & b

6357;	  case LOGOR:  resultis a \ b

6358;	  case EQV:    resultis a eqv b

6359;	  case NEQV:   resultis a neqv b

6360;	  case EQUIV:  resultis a = b

6361;	  case NEQUIV: resultis a ne b
6362;	  default:     TransReport(-1,,203, 0, 0); resultis 0

6363;	                                // Compiler bug.
6364;	 }

6365;	and EvalUnop(Op, a) := valof
6366;	switchon Op into
6367;	{ case NEG: resultis - a

6368;	  case NOT: resultis ~ a        // case FNEG: resultis %- a

6369;	  case LH:  resultis lh a

6370;	  case RH:  resultis rh a

6371;	  case Q1:  resultis q1 a

6372;	  case Q2:  resultis q2 a

6373;	  case Q3:  resultis q3 a

6374;	  case Q4:  resultis q4 a

6375;	  case LHZ: resultis #777777 & lh a

6376;	  case RHZ: resultis #777777 & rh a

6377;	  case Q1Z: resultis #777 & q1 a

6378;	  case Q2Z: resultis #777 & q2 a

6379;	  case Q3Z: resultis #777 & q3 a

6380;	  case Q4Z: resultis #777 & q4 a
6381;	  default:  TransReport(-1,,203, 0, 0); resultis 0

6382;	                                // Compiler bug.
6383;	 }

6384;	and SingleBit(x) := valof       // If x eq 2k return k, otherwise
6385;	                                //-- return -1.
6386;	{ for k := 0 to 35 do
6387;	  { if (x & 1) eq 1 resultis x eq 1 => k, -1
6388;	    x := x rshift 1
6389;	   }
6390;	  resultis -1
6391;	 }

6392;	and EvalQN(K, V) := valof       // Extract from K the field defined by
6393;	                                //-- V.
6394;	{ let N, W, T := V << QN.N, V << QN.W, V << QN.T
6395;	                                // Offset, width, access type.
6396;	  K := K lshift N               // Move desired field to the left end.
6397;	  let S := WordSizeOb - W       // The shift needed.
6398;	  switchon T into
6399;	  { case 0:
6400;	      resultis K rshift S       // Logical access.

6401;	// Replace this by RSCALE when possible.     ******* ******* *******

6402;	    case 1:
6403;	      resultis K < 0 => -(-K rshift S), K rshift S

6404;	                                // Numeric access.
6405;	    case 2:
6406;	      resultis (K & #400000,,0) ne 0

6407;	                                // bitb field
6408;	   }
6409;	 }

6410;	and EvalStringAp(S, n) :=S|n    // Apply the string S to n.

6411;	// This routine is used when the node MUST be evaluable at compile
6412;	//-- time.

6413;	and EvalConst(LVX) := valof
6414;	{ let x := rv LVX
6415;	  if #400000 > lh x > 0 resultis rv lh x
6416;	  Lookat(LVX)                   // Look first in the usual mode.
6417;	  x := lh rv LVX; if #400000 > x > 0 resultis rv x
6418;	                                // A good value found.
6419;	                                // We can"t get a value, so let"s get a
6420;	                                //-- good error diagnostic.
6421;	  let c := Constant             // Save the old value of Constant.
6422;	  Constant := true ,, true      // No error reported ,, constant value
6423;	                                //-- needed.
6424;	  Lookat(LVX)
6425;	  x := rv LVX
6426;	  let NewC := lh Constant
6427;	  Constant := c                 // Restore the old value.
6428;	  if #400000 > lh x > 0 resultis rv lh x
6429;	  if NewC=-1 \ NewC=#777777 do TransReport(125, x, 0)
6430;	                                // Complain, unless we already have.
6431;	  rv LVX := ZERONODE+1 ,, ZERONODE
6432;	  resultis 0
6433;	 }


		TRN7.BCP;3


6434;	// BCPL Compiler -- Trans, Part 7.

6435;	// Pures  Code that follows is pure procedure.
6436;	// Impures  Code that follows is impure.
6437;	// Complab  Output a label.
6438;	// Compentry Output an entry point.
6439;	// Compdatalab Output a data label.
6440;	// Compjump Output a jump to a label.
6441;	// Out1  Output a single operation.
6442;	// Out2  Output an op with a numeric parameter.
6443;	// Out2P  Output an op with a label parameter.
6444;	// Out3P  Output an op with a numeric parameter and a label parameter.
6445;	// Out1C  Output an op with a 1-byte parameter.
6446;	// OutN  Output a number.
6447;	// OutL  Output a label.
6448;	// OutC  Output a character.
6449;	// *W  output an item.
6450;	// *Write4  output a number.
6451;	// *Write2  output a label.
6452;	// *Set  set BlockIn to BlockWanted and tell the code generator.
6453;	// * local to this file.

6454;	get "<bcpl>head"
6455;	get "<XBCPL>headtrn"            // Declarations for TRANS.

6456;	static                          // Switches used by the following
6457;	                                //-- routines.
6458;	{ BlockIn :     0               // The block we are currently compiling
6459;	                                //-- in.
6460;	  BlockWanted : 0               // The block we think we want to be in.
6461;	 }

6462;	let Pures() be
6463;	BlockWanted := 0

6464;	and Impures() be
6465;	BlockWanted := 1

6466;	and Complab(L) be
6467;	Out2P(LAB, L)

6468;	and Compentry(N, L) be
6469;	{ let V := vec NAMELENGTH
6470;	  Unpackstring(H2|N, V)
6471;	  Out3P(ENTRY, V|0, L)
6472;	  for i := 1 to V|0 do OutC(V|i)
6473;	 }

6474;	and Compdatalab(L) be
6475;	Out2P(DATALAB, L)

6476;	and Compjump(L) be
6477;	Out2P(JUMP, L)

6478;	and Out1(x) be
6479;	W(x)

6480;	and Out2(x,y) be
6481;	{ W(x)
6482;	  Write4(y)
6483;	 }

6484;	and Out2P(x,y) be
6485;	{ W(x)
6486;	  Write2(y)
6487;	 }

6488;	and Out3P(x,y,z) be
6489;	{ W(x)
6490;	  Write4(y)
6491;	  Write2(z)
6492;	 }

6493;	and Out1C(Op, B) be
6494;	{ W(Op); W(B)
6495;	 }

6496;	and OutN(x) be
6497;	Write4(x)

6498;	and OutL(x) be
6499;	Write2(x)

6500;	and OutC(x) be
6501;	W(x)

6502;	// The following local routines do the actual storing.

6503;	and W(x) be
6504;	{ unless BlockIn eq BlockWanted do Set()
6505;	  Writech(Ocode, x)
6506;	 }

6507;	and Write4(x) be
6508;	{ unless BlockIn eq BlockWanted do Set()
6509;	  Writech(Ocode,q4 x)
6510;	  Writech(Ocode,q3 x)
6511;	  Writech(Ocode,q2 x)
6512;	  Writech(Ocode,q1 x)
6513;	 }

6514;	and Write2(x) be
6515;	{ unless BlockIn eq BlockWanted do Set()
6516;	  Writech(Ocode,q2 x)
6517;	  Writech(Ocode,q1 x)
6518;	 }

6519;	and Set() be
6520;	{ Writech(Ocode, BLOCK); Writech(Ocode, BlockWanted)
6521;	  BlockIn := BlockWanted
6522;	 }



		TRN8.BCP;3


6523;	// BCPL Compiler -- Part 8 of Trans --  Process Structure References.

6524;	// DoQualName Load a qualified name, returning data describing what
6525;	//-- happened.
6526;	// EvalSize Return the size in bits of a qualified name.
6527;	// *GetTable Get the table for a structure.
6528;	// * local to this file.

6529;	get "<XBCPL>headtrn"            // Declarations for TRANS.

6530;	manifest
6531;	{ LoadNeeded  := 1 lshift 26
6532;	 }                              // (Bitsperword - offset QN.M - size
6533;	                                //-- QN.M ) }   //  QN.M is 1

6534;	// This routine is called with the right son of a LEFTLUMP or RIGHTLUMP
6535;	//-- node as the first argument.
6536;	// The other arguments are described below.
6537;	// The routine compiles code to load the offset, and returns a value as
6538;	//-- described by the structure QN
6539;	// in HEAD.TRN.B, whose fields are as follows...
6540;	// W width of the item being accessed, in bits.
6541;	// T 0 if logical access, 1 if numeric and 2 if boolean.
6542;	// M 0 if nothing loaded, 1 if bit offset loaded, 2 if word offset
6543;	//-- loaded.
6544;	// N offset in bits to be added to what has been loaded.
6545;	// The last three arguments are booleans, which if true do the
6546;	//-- following...
6547;	// SWwide  permit access to fields of arbitrary width.  (Used in LV
6548;	//-- contexts.)
6549;	// SWbit  return only bit offset.  That is, QN.M will be either 0 or 2,
6550;	//-- but not 1.
6551;	// SWnoload Emit no OCODE, used in Lookat.

6552;	// This routine is called from
6553;	// Load LEFTLUMP, RIGHTLUMP and OFFSET
6554;	// LoadLV RIGHTLUMP
6555;	// Simpass LEFTLUMP or RIGHTLUMP as the principle operator on the left
6556;	//-- of ASS.
6557;	// Lookat OFFSET, LEFTLUMP and RIGHTLUMP

6558;	let DoQualName(x, SWwide, SWbit, SWnoload) := valof
6559;	{ let Table := -1               // Address of the structure definition
6560;	                                //-- table.

6561;	  and MainSubSw := 0            // Status of subscripting so far, like
6562;	                                //-- this...
6563;	                                // 0  no subscript or numeric
6564;	                                //-- subscript.
6565;	                                // 1  calculated subscript, in words.
6566;	                                // 2  calculated subscript, in bits.
6567;	  and MainSubN := 0             // Accumulated offset in bits.

6568;	  and SubSw := nil              // Status of current node, as for
6569;	                                //-- MainSubSw.  <0 => no subscript.
6570;	  and Sub := nil                // Subscript tree if SubSw _ 1 or 2,
6571;	                                //-- and value if SubSw _ 0.

6572;	  let Data := 0                 // Put the answer here.
6573;	  and W := nil                  // For the width of the data item.
6574;	  and OldSSP := SSP             // Save the stack pointer.

6575;	  let More := true              // Set at true as long as there are
6576;	                                //-- more levels of qualification.

6577;	  while More do
6578;	  { if #400000 > lh x > 0 do { TransReport(177, x, 0); goto Done }
6579;	                                // Cannot happen -- I think.
6580;	    More := H1|x eq DOT         // Are there still more levels of
6581;	                                //-- qualification?
6582;	    let N := More => H2|x, x    // The name or UPLUMP at this level.
6583;	    if #400000 > lh N > 0 do { TransReport(177, N, 0); goto Done }
6584;	                                // Cannot happen -- I think.
6585;	    SubSw := -1                 // No subscript yet at this level.
6586;	    if H1|N eq UPLUMP do        // There is a subscript.
6587;	    { Lookat(H3+N)              // Optimize the subscript.
6588;	      Sub := H3|N               // The piece of tree that is the
6589;	                                //-- subscript.
6590;	      test #400000 > lh Sub > 0
6591;	                                // Is the subscript numeric?
6592;	      ifso SubSw, Sub := 0, rv lh Sub
6593;	                                // Yes, so remember that fact and the
6594;	                                //-- value.
6595;	      ifnot                     // No, so remember that fact.
6596;	      { if SWnoload resultis LoadNeeded
6597;	                                // But quit if called from Lookat.
6598;	        SubSw := 1
6599;	       }
6600;	      N := H2|N                 // The name.
6601;	     }

6602;	    Table := GetTable(N, Table) // Get the structure definition table
6603;	                                //-- for this name.
6604;	    if Table eq 0 do goto Done  // Oops -- bad table.

6605;	    let RepSw := q3 Table|4     // Are replications expected at this
6606;	                                //-- level?

6607;	    if SubSw < 0 do             // No subscript encountered at this
6608;	                                //-- level.
6609;	    { if More & RepSw do        // Complain if subscript was expected
6610;	                                //-- and there are more levels.
6611;	      TransReport(175, x, 0)
6612;	      x := H3|x
6613;	      loop
6614;	     }

6615;	// We get here only if a subscript was found at the current level.

6616;	    unless RepSw do             // Complain if subscript found but not
6617;	                                //-- expected.
6618;	    { TransReport(174, x, 0); x := H3|x; loop
6619;	     }

6620;	    let F := Table|1            // Offset of zeroth element at this
6621;	                                //-- level.
6622;	    and S := Table|2            // Size of one replication, in bits.
6623;	    and L := lh Table|3         // Lower limit of replication.

6624;	    x := H3|x                   // On to the next level.

6625;	    if SubSw eq 0 do            // The subscript at this level is
6626;	                                //-- numeric.
6627;	    { MainSubN := MainSubN + F + Sub * S
6628;	                                // Add the offset.
6629;	      loop
6630;	     }

6631;	// There is a non-constant subscript at this level.

6632;	    let WordOK :=
6633;	      (~ SWbit) & F rem WordSizeOb eq 0 & S rem WordSizeOb eq 0 &
6634;	      MainSubSw ne 2

6635;	    test WordOK
6636;	    ifso F, S := F/WordSizeOb, S/WordSizeOb
6637;	    ifnot SubSw := 2

6638;	    if MainSubSw eq 1 & ~WordOK do
6639;	    { Out2(LN, WordSizeOb); Out1(MULT)
6640;	     }
6641;	    Load(Sub)                   // Load the subscript.
6642;	    unless S eq 1 do { Out2(LN, S); Out1(MULT) }
6643;	    unless F eq 0 do { Out2(LN, F); Out1(PLUS) }
6644;	    unless MainSubSw eq 0 do Out1(PLUS)
6645;	                                // Add it to what came before.
6646;	    MainSubSw := SubSw
6647;	   }                            // This is the end of the "while More
6648;	                                //-- do" repeat block.

6649;	// All levels of qualification have been processed.

6650;	  W := Table|2                  // Width at this level.
6651;	  if SubSw < 0 do W := W * rh Table|3
6652;	                                // If no subscript at this level, mult
6653;	                                //-- by number of reps.
6654;	  if W > WordSizeOb & ~SWwide do { TransReport(173, x, 0); W := 1 }
6655;	                                // Width too wide.
6656;	  if SubSw < 0 do MainSubN := MainSubN + Table|1
6657;	                                // No subscript at the last level.
6658;	  Data << QN.W := W             // Width of the item being accessed.
6659;	  Data << QN.T := q4 Table|4    // Access type.
6660;	  Data << QN.M := MainSubSw     // What sort of thing has been loaded?
6661;	  Data << QN.N := MainSubN      // Constant part of the offset.

6662;	Done:
6663;	  SSP := OldSSP + (SWnoload => 0, 1)
6664;	  if PDRMAXSSP < SSP do PDRMAXSSP := SSP
6665;	  resultis Data
6666;	 }

6667;	and EvalSize(x) := valof        // Return the size in bits of a
6668;	                                //-- qualified name.
6669;	{ let Table := -1

6670;	  let More, Sub := true, nil    // more to do? , last element
6671;	                                //-- subscripted?
6672;	  while More do                 // Work through qualifications.
6673;	  { More := H1|x eq DOT         // Is there still more to do after
6674;	                                //-- this?
6675;	    let N := More => H2|x, x
6676;	    Sub := H1|N eq UPLUMP       // Is this element subscripted?
6677;	    Table := GetTable(Sub => H2|N, N, Table)
6678;	                                // Ignore initial subscripts.
6679;	    if Table eq 0 resultis 1    // An error was detected in GetTable.
6680;	    x := H3|x
6681;	   }

6682;	  resultis Table eq 0 => 1, Sub => Table|2, Table|2 * rh Table|3
6683;	 }

6684;	// Return the structure definition table corresponding to x.  Return 0
6685;	//-- for error.

6686;	and GetTable(x, Table) := valof
6687;	{ unless H1|x eq NAME do { TransReport(-1, x, 0); resultis 0 }
6688;	  if Table < 0 do               // The first table ever.
6689;	  { let t := CellWithName(x)    // Look up the name.
6690;	    if t eq 0 do { TransReport(172, x, H2|x, 0); resultis 0 }
6691;	                                // Name not declared.
6692;	    unless lh Dvec|t eq STRUCTURE do
6693;	    { TransReport(170, 0, H2|x, 0); resultis 0
6694;	     }
6695;	    resultis Dvec|(t+1)         // Datum returned is the address of the

6696;	                                //-- structure definition table.
6697;	   }

6698;	// We already have a structure.  Look up the next substructure.

6699;	  x := H2|x                     // The string itself.
6700;	  let U := Table + 4 + q1 Table|4
6701;	                                // Last cell to look at.
6702;	  for t := Table+5 to U
6703;	  do if x eq rv t|0 do resultis rv t
6704;	  TransReport(171, 0, x, 0)     // Substructure name not found.
6705;	  resultis 0
6706;	 }


		TRN9.BCP;4


6707;	// BCPL Compiler  --  Trans, Part 9 -- Process structure declarations.

6708;	// TransStructDecl  Process a structure declaration, producing tables.
6709;	// *TSD   Process one node of a structure declaration.
6710;	// *InitNode  Initialize a node.
6711;	// *BitsIn   Report number of bits in a declarator, such as BYTE.
6712;	// *Check   Check that a structure declaration does not overlap words.
6713;	// *CheckNames  Detect improper multiple use of a name.
6714;	// * local to this compilation.

6715;	get "<XBCPL>headtrn"            // Declarations for Trans.
6716;	get "<XBCPL>headsymb"           // Symbol table declarations.

6717;	//local statics
6718;	static
6719;	{ Offset :  nil                 // Offset of current item from
6720;	                                //-- beginning of the structure.
6721;	  SDvec :   nil                 // Table entry at next outer level,
6722;	                                //-- into which to put names.
6723;	  CBranch : nil                 // Current branch, for error
6724;	                                //-- diagnostics.
6725;	 }

6726;	manifest
6727;	{ MaxNames  := 127              // The maximum number of names
6728;	                                //-- immediately inferior to any
6729;	                                //-- structure element.
6730;	 }

6731;	// This is the only routine in this file known outside of it.  It is
6732;	//-- called by TransBlockBody
6733;	// to process a structure declaration.

6734;	let TransStructDecl(x) be
6735;	{ let t := nil                  // The new node will go here.
6736;	  while H1|x eq LINE do { Curline := H2|x; x := H3|x }
6737;	  switchon H1|x into
6738;	  { case SEQ:                   // Do first one arm, and then the
6739;	                                //-- other.
6740;	      TransStructDecl(H2|x)
6741;	      TransStructDecl(H3|x)
6742;	      return

6743;	    case SD:                    // A named structure at the top level.
6744;	      { Offset := 0
6745;	        if H2|x eq 0 do { TSD(H4|x, true); return }
6746;	                                // No name at the top level.
6747;	        let v := vec 4 + MaxNames
6748;	                                // Maximum possible size of a node.
6749;	        SDvec := v              // Make this quantity globally
6750;	                                //-- available.
6751;	        InitNode(x, v)

6752;	        TSD(H4|x, false)        // Do all of the work...

6753;	        CBranch := x            // For error diagnostics from
6754;	                                //-- CheckNames.
6755;	        CheckNames(v)           // Be sure there are no name
6756;	                                //-- duplications.
6757;	        v|2 := Offset           // The size of the thing...
6758;	        if (q3 v|4)=#777 \ (q3 v|4)=-1 do v|1 := v|1 - v|2 * lh v|3
6759;	                                          // Offset of zero-th element.
6760;	        let N := 4 + q1 v|4     // Total number of words in the node.
6761;	        t := Newvec(N)          // Get a place to put the table.
6762;	        for k := 0 to N do t|k := v|k
6763;	                                // Copy the thing there.
6764;	        CBranch := t            // For error diagnostics from Check.
6765;	        Check(t, 0)             // Check that no item straddles a word
6766;	                                //-- boundary.
6767;	        endcase
6768;	       }

6769;	    case OVERLAY:               // Overlay at the top level.
6770;	      { TransStructDecl(H2|x)   // The one arm.
6771;	        let L := Offset         // The size of the first arm.
6772;	        TransStructDecl(H3|x)   // Do the other arm.
6773;	        unless L eq Offset do TransReport(2,,162, x, 0)
6774;	        return
6775;	       }

6776;	    case SDATOM:                // A terminal node at the top level.
6777;	      { t := Newvec(4)          // Get some space to put the node.
6778;	        InitNode(x, t)
6779;	        t|1 := 0
6780;	        let n := BitsIn(H4|x)   // Size of this kind of item.
6781;	        let s := H5|x eq 0 => 1, EvalConst(H5+x)
6782;	                                // The size field
6783;	        t|2 := rh n * s         // The size of this item.
6784;	        if (q3 t|4)=#777 \ (q3 t|4)=-1 do t|1 := t|1 - t|2 * lh t|3
6785;	                                          // Offset of zero-th element.
6786;	        q4 t|4 := lh n          // Type of access needed.
6787;	        if lh n eq 2 & t|2 ne 1 do TransReport(176, x, 0)
6788;	                                   // BITB n, with n  ne  1
6789;	        endcase
6790;	       }

6791;	    default:                    // Improper node encountered -- EGAD.
6792;	      TransReport(-1,,203, x, 0)
6793;	                                // Compiler bug.
6794;	      return

6795;	   }

6796;	// Install the created name in Dvec so it can be used.

6797;	  if t|1 eq 0 do t|1 := 0       // But first get rid of -0 as an
6798;	                                //-- offset.
6799;	  if t|0 eq 0 return            // No name declared.  Curious???
6800;	  AddName(H2|x, STRUCTURE, t)   // Make the name known in the current
6801;	                                //-- block.
6802;	  if (SWbits << SW.Symtab)&(SWbits << SW.SymtabLong) do EnterSymbol(H2|x, STstructure, t)
6803;	                                // Make a symbol-table entry.
6804;	 }

6805;	// This routine does most of the work.  It is called by TransStructDecl
6806;	//-- and recursively by itself.
6807;	// It is applied to some part of a structure declaration and does the
6808;	//-- following...
6809;	// It creates a table for that part.
6810;	// It stores the location of that table in SDvec.
6811;	// It increments Offset by the total size of the part.

6812;	and TSD(x, Sw) be               // Process a single structure item.  Sw
6813;	                                //-- is true if names are to be
6814;	                                //-- declared.
6815;	{ while H1|x eq LINE do { Curline := H2|x; x := H3|x }
6816;	  let t := nil                  // The new node goes here.
6817;	  switchon H1|x into
6818;	  { case SEQ:                   // First do one arm, then the other.
6819;	      TSD(H2|x, Sw)
6820;	      TSD(H3|x, Sw)
6821;	      return

6822;	    case OVERLAY:               // Two substructures overlaid.
6823;	      { let OldOffset := Offset // Remember the current offset.
6824;	        TSD(H2|x, Sw)           // Process one arm.
6825;	        let NewOffset := Offset
6826;	                                // Remember how big that one was.
6827;	        Offset := OldOffset     // Put back what we started with.
6828;	        TSD(H3|x, Sw)           // Process the other arm.
6829;	        unless Offset eq NewOffset do TransReport(162, x, 0)
6830;	                                      // Not both the same size.
6831;	        return
6832;	       }

6833;	    case SD:                    // A substructure with substructures.
6834;	      { if H2|x eq 0 do { TSD(H4|x, Sw); return }
6835;	                                // No name, so no table.
6836;	        let v := vec 4 + MaxNames
6837;	                                // The largest possible table entry.
6838;	        InitNode(x, v)
6839;	        let OldSDvec, OldOffset := SDvec, Offset
6840;	                                // Save 2 globals in the stack.
6841;	        SDvec := v
6842;	        let RepSW := (q3 v|4)=#777 \ (q3 v|4)=-1
6843;	                                // Are there replicators?
6844;	        if RepSW do Offset := 0
6845;	        TSD(H4|x, false)        // Do all the work.....
6846;	        CBranch := x            // For error diagnostics from
6847;	                                //-- CheckNames.
6848;	        CheckNames(v)           // Check for name duplication.
6849;	        v|2 := RepSW => Offset, Offset - OldOffset
6850;	                                // size
6851;	        if RepSW do v|1 := v|1 - v|2 * lh v|3
6852;	                                // Offset of zero-th element.
6853;	        Offset := OldOffset + v|2 * rh v|3
6854;	        SDvec := OldSDvec
6855;	        let N := 4 + q1 v|4     // Number of words in this node.
6856;	        t := Newvec(N)          // Some space into which to store the
6857;	                                //-- result.
6858;	        for k := 0 to N do t|k := v|k
6859;	                                // Copy the node into static storage.
6860;	        endcase
6861;	       }

6862;	    case SDATOM:                // Process a terminal node.
6863;	      { let v := vec 4          // A place into which to put the node.
6864;	        InitNode(x, v)
6865;	        let n := BitsIn(H4|x)   // Size of this item.
6866;	        let s := H5|x eq 0 => 1, EvalConst(H5+x)
6867;	                                // The size field.
6868;	        v|2 := rh n * s         // Size of 1 replication.
6869;	        if (q3 v|4)=#777 \ (q3 v|4)=-1 do v|1 := v|1 - v|2 * lh v|3
6870;	                                          // Offset of zero-th element.
6871;	        Offset := Offset + v|2 * rh v|3
6872;	                                // Step offset by space used.
6873;	        q4 v|4 := lh n          // Type of access needed.
6874;	        if lh n eq 2 & v|2 ne 1 do TransReport(176, x, 0)
6875;	                                   // BITB n, with n  ne  1
6876;	        if v|0 eq 0 return      // No structure def table if no name.
6877;	        t := Newvec(4); for k := 0 to 4 do t|k := v|k
6878;	                                           // Get some space, and copy
6879;	                                           //-- the table.
6880;	        endcase
6881;	       }

6882;	    case FILL:
6883;	      { let n := rh BitsIn(H2|x)
6884;	                                // Size to fill to.
6885;	        let r := Offset rem n   // Bits of last element already used.
6886;	        unless r eq 0 do Offset := Offset + n - r
6887;	                                // Move Offset, but not if it"s OK.
6888;	        return
6889;	       }

6890;	    default:
6891;	      TransReport(-1,,203, x, 0)
6892;	                                // Compiler bug.
6893;	      return

6894;	   }

6895;	// We have a declaration.  Is this to be declared?

6896;	  if Sw do                      // Top level call?
6897;	  { if t|0 eq 0 return          // No name.   Curious??
6898;	    AddName(H2|x, STRUCTURE, t)
6899;	                                // Declare the name.
6900;	    if (SWbits << SW.Symtab)&(SWbits << SW.SymtabLong) do EnterSymbol(H2|x, STstructure, t)
6901;	                                  // Symbol table entry.
6902;	    return
6903;	   }

6904;	// Enter the table in t into the parent node.

6905;	  if t|1 eq 0 do t|1 := 0       // An offset of -0 is a bore.
6906;	  let k := q1 SDvec|4           // Number of names used so far.
6907;	  if k ge MaxNames do { TransReport(163, x, 0); return }
6908;	                                // Too many names at this level.
6909;	  SDvec|(k+5) := t              // Enter this node.
6910;	  q1 SDvec|4 := k+1             // Step the count.
6911;	  return
6912;	 }

6913;	and InitNode(x, v) be           // Initialize the table entry at v from
6914;	                                //-- the declaration at x.
6915;	{ let Name := H2|x              // The name.
6916;	  v|0 := Name eq 0 => 0, H2|Name
6917;	  v|1 := Offset                 // Current offset.
6918;	  v|3 := 0 ,, 1                 // Lower limit _ 0, number of
6919;	                                //-- replications _ 1
6920;	  v|4 := 0 ,, 0                 // Type 0, 0 replications, 0
6921;	                                //-- substructures.
6922;	  unless H3|x eq 0 do           // Check for a REP node.
6923;	  { let y := H3|x               // There is one, so process it.
6924;	    let L := H2|y eq 0 => 1, EvalConst(H2+y)
6925;	                                // The lower limit of replication.
6926;	    and U := EvalConst(H3+y)    // The upper limit.
6927;	    let R := U - L + 1          // Number of replications.
6928;	    unless R > 0 do { TransReport(164, x, 0); L, R := 0, 1 }
6929;	    v|3 := L ,, R               // Record lower limit, number of
6930;	                                //-- replications.
6931;	    q3 v|4 := true              // Record that there are replications.
6932;	   }
6933;	 }

6934;	// This routine processes a structure declarator, returning its size
6935;	//-- and its access type
6936;	// coded as 0 for non-numeric, 1 for numeric, and 2 for boolean.

6937;	and BitsIn(x) := valof
6938;	switchon x into
6939;	{ case BIT:     resultis 0 ,, 1

6940;	  case BITN:    resultis 1 ,, 1

6941;	  case BITB:    resultis 2 ,, 1

6942;	  case CHAR:
6943;	  case BYTE:    resultis 0 ,, ByteSizeOb

6944;	  case BYTEN:   resultis 1 ,, ByteSizeOb

6945;	  case WORD:    resultis 0 ,, WordSizeOb

6946;	  default:                      // this should never occur
6947;	                TransReport(-1,,203, x, 0); resultis 0 ,, 1
6948;	 }

6949;	// THISAAAA ROUTINEAAAA ISAAAA BUGGY
6950;	//-- AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA
6951;	//-- AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA
6952;	//-- AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA
6953;	//-- AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:
6954;	// This routine checks that the declaration is OK, in the sense that no
6955;	//-- named item stradles a word
6956;	// boundary.  Its parameters are a node and the offset at which its
6957;	//-- parent is encountered.
6958;	// This routine is called from TransStructDecl for case SD, and calls
6959;	//-- itself.

6960;	and Check(x, F) be
6961;	{ let S := x|2                  // Size of 1 replication of this item.
6962;	  if S eq 1 then return         // If this item has size 1, it needs no

6963;	                                //-- check.

6964;	  let R := rh x|3               // Number of replications.
6965;	  and N := q1 x|4               // Number of substructures.
6966;	  and RepSw := (q3 x|4)=#777 \ (q3 x|4)=-1
6967;	                                // Is this item replicated?

6968;	  if N eq 0 do                  // Has this item any substructures?
6969;	  {                             // No, so it is a terminal element.  We
6970;	                                //-- must check it...
6971;	    if x|0 eq 0 return          // ...except that unnamed terminal
6972;	                                //-- fields must not be checked.
6973;	    if S eq WordSizeOb do       // Is it a WORD element?
6974;	    {                           // Yes, so its offset must be on a word
6975;	                                //-- boundary.
6976;	      unless F rem WordSizeOb eq 0 goto BadDeclaration
6977;	      return
6978;	     }
6979;	    if S > WordSizeOb goto BadDeclaration
6980;	                                // One replication of it is too big.
6981;	                                // It"s not a word.  Is it replicated?
6982;	    unless RepSw do
6983;	    { unless F rem WordSizeOb + S le WordSizeOb goto BadDeclaration
6984;	      return
6985;	     }

6986;	// It"s replicated, so each replication must be checked.

6987;	    F := F + S*R                // Adjust offset to be that of first
6988;	                                //-- element used, rather than zero-th.
6989;	    for r := 1 to R do
6990;	    { unless (F rem WordSizeOb) + S le WordSizeOb goto BadDeclaration
6991;	      F := F + S
6992;	     }
6993;	    return
6994;	   }

6995;	// It"s not a terminal node, so all sub-nodes must be processed.  As a
6996;	  //-- special case,
6997;	                                // if each subnode is an even number of
6998;	                                //-- words, we need only examine the
6999;	                                //-- first replication.
7000;	  if S rem WordSizeOb eq 0 \ R eq 1 do
7001;	  { for k := 5 to N+4 do Check(x|k, F)
7002;	                                // Check all subfields.
7003;	    return
7004;	   }

7005;	// There are no simplifications, so do it the hard way.

7006;	  for r := 1 to R do            // Iterate all replications.
7007;	  { for k := 5 to N+4 do Check(x|k, F)
7008;	    F := F + S
7009;	   }
7010;	  return

7011;	BadDeclaration:
7012;	  TransReport(165, CBranch, 0)
7013;	  unless CBranch|0 eq 0
7014;	  do TransReport(0, 0, "structure is ", CBranch|0, 0)
7015;	  TransReport(0, 0, "element at fault is ", x|0, 0)

7016;	 }

7017;	and CheckNames(t) be            // Check that all subnodes at a given
7018;	                                //-- level are distinct.
7019;	{ let N := 4 + q1 t|4           // The last cell occupied by a name.
7020;	  for J := 5 to N-1 do          // Look at all of the names, except the
7021;	                                //-- last.
7022;	  { let Name := t|J|0           // The current name.
7023;	    if Name eq 0 loop           // An unnamed field -- don"t check it.
7024;	    for K := J+1 to N do        // Compare it with all other names.
7025;	    if Name eq t|K|0 do
7026;	    { TransReport(166, CBranch, "the name is ", Name, 0); break
7027;	     }
7028;	   }
7029;	 }



		CG0.BCP;7


7030;	// BCPL Compiler -- Code Generator main program.

7031;	// *CGWritech
7032;	// Cg  The main program of the code generator.
7033;	// Initstack
7034;	// Readop  Read an operator from the input stream.
7035;	// ReadNM  Read a number from the input stream.
7036;	// ReadL  Read a label from the input stream.
7037;	// *CGreport Special error handler for the code generator.
7038;	// Push
7039;	// StartStack
7040;	// Pop
7041;	// Elt

7042;	get "<bcpl>utilhead"
7043;	get "<xbcpl>headcg"

7044;	//home base for these global statics
7045;	static
7046;	{
7047;	SSP:0
7048;	  Arg1 :       0
7049;	  Arg2 :       0
7050;	  TempV :      0
7051;	  TempT :      0
7052;	  ConstV :     0
7053;	  ConstP :     0
7054;	  ConstL :     0
7055;	  Svec :       0
7056;	  SvecP :      0
7057;	  SvecT :      0
7058;	  StatV :      0
7059;	  StatP :      0
7060;	  Op :         0
7061;	  MAXXRNUMBER: 0
7062;	  P10regV:     0
7063;	  globinfo:    0
7064;	  Block1JFN:   0
7065;	  Report:      0
7066;	  OutA:        0
7067;	  OutB:        0
7068;	  Ch:          0
7069;	  bl2pptr:     #441100560000
7070;	  bl2sptr:     #441100560000
7071;	  Block2JFN:   0
7072;	  bl1pptr:     #441100600000
7073;	  bl1sptr:     #441100600000
7074;	  flgstk:      vec 20
7075;	MaxStack: 0
7076;	 }

7077;	//local statics
7078;	static
7079;	{ BadOcode : false
7080;	  MacroName:   vec 40
7081;	 }

7082;	let CGWritech(a,b) be
7083;	{ if NumbArgs()=1 do
7084;	  { b:=a
7085;	    a:=OUTPUT
7086;	   }
7087;	  test b=$*n then
7088;	  { BOUT(a,$*c)
7089;	    BOUT(a,$*l)
7090;	   }
7091;	  or BOUT(a,b)
7092;	 }

7093;	and Cg(snm,rnm,lnm,rootname) be
7094;	{cgfap
7095;	  let oldwr:=Writech

7096;	// init VMILLER's statics

7097;	  VMINIT()
7098;	  bl2pptr:=#441100560000
7099;	  bl2sptr:=#441100560000
7100;	  bl1pptr:=#441100600000
7101;	  bl1sptr:=#441100600000
7102;	  Block2JFN:=0
7103;	  BadOcode:=false
7104;	  Writech:=CGWritech
7105;	  let bbstrt:=NextParam()

7106;	  OutA:= table BlockA,
7107;	               nil,
7108;	               0,
7109;	               nil,
7110;	               0,
7111;	               0,
7112;	               0
7113;	  OutA|0,OutA|1,OutA|2,OutA|3,OutA|4,OutA|5,OutA|6:=
7114;	    BlockA,nil,0,nil,0,0,0
7115;	  OutB:= table BlockB,
7116;	               nil,
7117;	               0,
7118;	               nil,
7119;	               0,
7120;	               0,
7121;	               0
7122;	  OutB|0,OutB|1,OutB|2,OutB|3,OutB|4,OutB|5,OutB|6:=
7123;	    BlockB,nil,0,nil,0,0,0
7124;	  Block1JFN:=0
7125;	  let v1 := vec 200
7126;	  ConstV, ConstP := v1, 0
7127;	  let v1 := vec 200
7128;	  ConstL := v1
7129;	  let v1 := vec 300
7130;	  Svec, SvecP, SvecT := v1, 0, 300
7131;	  let v1 := vec 300
7132;	  StatV, StatP:= v1, 0
7133;	  let v1:=vec 1500
7134;	  TempV := v1
7135;	  TempT := TempV + 1500
7136;	  let v1 := vec #20
7137;	  P10regV := v1
7138;	  for i:=0 to #17 do P10regV|i:=0
7139;	                                // all regs empty
7140;	let v1_vec 10
7141;	MaxStack_v1
7142;	StartStack(MaxStack,10)
7143;	  Initstack(0)

7144;	  flgstk|0:=1
7145;	  flgstk|1:=false

7146;	// initialize the index register limits

7147;	  MAXXRNUMBER := 0              // for collection of max xr used
7148;	let  XRBOT := 2                    // 1 for JSP & function results
7149;	let  XRTOP := #15                  // 16 for stack, 17 for PDL

7150;	  P10regV|0,P10regV|1 := -1,-1  // reserve these regs
7151;	  P10regV|#16, P10regV|#17 := -1,-1

7152;	  Report := CGreport
7153;	  Curline := 0

7154;	  if SWbits<<SW.MACfil then
7155;	  { if lnm|0 eq 0 then
7156;	    { let t:=rootname|0
7157;	      rootname|(t+1):=$.
7158;	      rootname|(t+2):=$M
7159;	      rootname|(t+3):=$A
7160;	      rootname|(t+4):=$C
7161;	      rootname|0:=t+4
7162;	      Packstring(rootname,MacroName)
7163;	      rootname|0:=t
7164;	     }
7165;	   }
7166;	  if lnm|0 ne 0 then
7167;	  { MacroName:=lnm
7168;	    SWbits<<SW.MACfil:=true
7169;	   }
7170;	  if SWbits<<SW.MACfil then MacroJFN:=CreateOutput(MacroName)
7171;	  let v1:=vec GlobNMax+1
7172;	  globinfo:=v1

7173;	  RLINIT(SWbits<<SW.MACfil)
7174;	  WRLST("TITLE ")
7175;	  WRLST(snm)
7176;	  WRLST(" translated to MACRO by BCPL*n")
7177;	  WRLST("; the next JFCL is the first word in the REL file...*n;the address is the location of the start of the block b stuff*n")
7178;	  WRMAC(JFCL,0,LABEL,bbstrt,0,0,0)
7179;	  WRIMP()
7180;	  WRLAB(bbstrt)
7181;	  WRPU()
7182;	  Scan()                        // DO THE WORK.

7183;	  WRPU()
7184;	  Outconsts()
7185;	  Outnumbs()
7186;	  WRLST("IMPURE:*n")

7187;	  { let v:=vec 20
7188;	    if rnm|0 eq 0 then
7189;	    { let t:=rootname|0
7190;	      rootname|(t+1):=$.
7191;	      rootname|(t+2):=$R
7192;	      rootname|(t+3):=$E
7193;	      rootname|(t+4):=$L
7194;	      rootname|0:=t+4
7195;	      Packstring(rootname,rnm)
7196;	      rootname|0:=t
7197;	     }
7198;	    Packstring(rootname,v)
7199;	    CGPS2(v,rnm)
7200;	   }
7201;	  OUTPUT := MONITOR
7202;	  if SWbits << SW.Debug do      // If debugging, print out the index
7203;	                                //-- register usage information.
7204;	  { WriteS("XR usage: ")
7205;	    WriteOct(XRBOT)
7206;	    WriteS(", ")
7207;	    WriteOct(MAXXRNUMBER)
7208;	    WriteS(", ")
7209;	    WriteOct(XRTOP)
7210;	    Writech(OUTPUT, $*n)

7211;	// later on, perhaps, we can store these in the binary output file
7212;	// but for now we will just have to print them.
7213;	   }

7214;	  if BadOcode do
7215;	  { Curline := 0
7216;	    Report(300)
7217;	   }

7218;	  Writech:=oldwr
7219;	 }cgfap

7220;	and Initstack(S) be
7221;	{ Arg2, Arg1 := TempV, TempV + Tempsize
7222;	  SSP := S
7223;	  H1|Arg2, H2|Arg2, H3|Arg2, H5|Arg2 := LOCAL, 0, SSP-2, SSP-2
7224;	  H1|Arg1, H2|Arg1, H3|Arg1, H5|Arg1 := LOCAL, 0, SSP-1, SSP-1
7225;	 }

7226;	and Readop():= valof
7227;	{ Readch(INPUT,lv Ch)
7228;	  if EofFlg resultis END
7229;	  resultis Ch
7230;	 }

7231;	and ReadNM():= valof
7232;	{ let n:=0
7233;	  Readch(INPUT,lv Ch)
7234;	  n:=Ch
7235;	  Readch(INPUT,lv Ch)
7236;	  n:=(n lshift 9)\Ch
7237;	  Readch(INPUT,lv Ch)
7238;	  n:=(n lshift 9)\Ch
7239;	  Readch(INPUT,lv Ch)
7240;	  n:=(n lshift 9)\Ch
7241;	  resultis n
7242;	 }

7243;	and ReadL() := valof
7244;	{ let n:=0
7245;	  Readch(INPUT,lv Ch)
7246;	  n:=Ch
7247;	  Readch(INPUT,lv Ch)
7248;	  n:=(n lshift 9)\Ch
7249;	  resultis n
7250;	 }

7251;	and CGreport(n,gn) be           // Report an error.  As a special case,
7252;	                                //-- -1 is for not yet implemented.
7253;	{ let a:=OUTPUT
7254;	  OUTPUT:=MONITOR
7255;	  if n < 0 do
7256;	  { BadOcode := true
7257;	    return
7258;	   }
7259;	  BCPLreport(n)
7260;	  if n=402 do
7261;	  { WriteOct(gn)
7262;	    WriteS("*n")
7263;	   }
7264;	  unless Curline eq 0 do Wfline(Curline)
7265;	  OUTPUT:=a
7266;	 }

7267;	and Push(stack,elt)_valof
7268;	{ rh stack|0_rhz stack|0+1
7269;	if (lhz stack|0) le (rhz stack|0) do Help("Stack overflow*n")
7270;	stack|(rhz stack|0)_elt
7271;	resultis elt
7272;	}

7273;	and StartStack(stack,maxnumelts)_valof
7274;	{ stack|0_maxnumelts,,0
7275;	resultis stack
7276;	}

7277;	and Pop(stack)_valof
7278;	{ let x_stack|(rhz stack|0)
7279;	if (rhz stack|0) le 0 do Help("Stack underflow*n")
7280;	rh stack|0_rhz stack|0-1
7281;	resultis x
7282;	}

7283;	and Elt(stack)_stack|(rhz stack|0)



		CG1.BCP;5


7284;	// BCPL Compiler -- Code Generator Master Switch.

7285;	// Scan  --  Read all the OCODE and call the routines that process it.

7286;	get "<xbcpl>headcg"

7287;	//local statics
7288;	static
7289;	{ LastOffset : -1               // Value of SSP at last LINE item.
7290;	  LastOffA :   -1               // Value of OffA at last LINE.
7291;	  LastLine :   -1               // Last LINE number.
7292;	 }
7293;	let Scan() be
7294;	{scan
7295;	Next:                           // Come here to read the next OCODE
7296;	                                //-- item.
7297;	  Op := Readop()

7298;	L:                              // Come here to branch on the OCODE
7299;	                                //-- item in Op.
7300;	  switchon Op into
7301;	  { default:          Report(303)
7302;	                      { let a := OUTPUT
7303;	                        OUTPUT := MONITOR
7304;	                        WriteOct(Op)
7305;	                        Writech(OUTPUT,$*n)
7306;	                        OUTPUT := a
7307;	                       }
7308;	                      goto Next

7309;	    case LINE:                  // Line number.
7310;	                      { Curline := ReadNM()
7311;	                                // Read the line ID.
7312;	                        if SWbits << SW.MACfil & Curline ne LastLine do
7313;	                        { WriteS("*n*t;*s")
7314;	                          Wfline(Curline)
7315;	                         }
7316;	                        LastLine := Curline
7317;	                        unless SWbits << SW.Symtab goto Next
7318;	                                // All done if not creating a symbol
7319;	                                //-- table.
7320;	                        unless OutA|Off eq LastOffA do
7321;	                        { SymtabStoreCommand(Curline, OutA|Off)
7322;	                          LastOffA := OutA|Off
7323;	                         }
7324;	                        if SSP eq LastOffset do goto Next

7325;	                                                // No change in SSP.
7326;	                        SymtabStoreStack(SSP, OutA|Off)
7327;	                                // Report change in stack offset.
7328;	                        LastOffset := SSP
7329;	                                // Remember the new value.
7330;	                        goto Next
7331;	                       }

7332;	    case DECL:        if SWbits << SW.Symtab do SymtabStoreILC(ReadNM(), OutA|Off, OutB|Off)
7333;	                      goto Next

7334;	    case INT:
7335;	                      { let n:=ReadNM()
7336;	                        let l:=ReadL()
7337;	                        let v:=vec 20
7338;	                        let v1:=vec 20
7339;	                        v|0:=n
7340;	                        for i:=1 to n do Readch(INPUT,v+i)
7341;	                        Packstring(v,v1)
7342;	                        WRINT(v1,l)
7343;	                        goto Next
7344;	                       }

7345;	    case EXT:
7346;	                      { let n:=ReadNM()
7347;	                        let l:=ReadL()
7348;	                        let v:=vec 20
7349;	                        let v1:=vec 20
7350;	                        v|0:=n
7351;	                        for i:=1 to n do Readch(INPUT,v+i)
7352;	                        Packstring(v,v1)
7353;	                        WREXT(v1,l)
7354;	                        goto Next
7355;	                       }

7356;	    case BLOCK:
7357;	                      { let n:=Readop()
7358;	                        and a:=nil
7359;	                        switchon n into
7360;	                        { default:
7361;	                            a:=OUTPUT
7362;	                            OUTPUT:=MONITOR
7363;	                            WriteS("*nUnknown BLOCK number: ")
7364;	                            WriteOct(a)
7365;	                            WriteS(", taken to be 1: Impure*n")
7366;	                            OUTPUT:=a
7367;	                          case 1:
7368;	                            WRIMP()
7369;	                            goto Next
7370;	                          case 0:
7371;	                                // Pures
7372;	                            WRPU()
7373;	                         }
7374;	                        goto Next
7375;	                       }

7376;	    case END:         return

7377;	    case GLOBAL:
7378;	                      { let n:=ReadNM()
7379;	                        let l:=ReadL()
7380;	                        NoteGlobal(n,l)
7381;	                        goto Next
7382;	                       }

7383;	    case RVCB:        Op:=RVCN
7384;	                      CGrvcandrvcn(1)
7385;	                      goto Next

7386;	    case CFGB:        Op:=CFGN
7387;	                      CGcfgandcfgn(1)
7388;	                      goto Next

7389;	    case SPC:
7390;	    case SGC:
7391;	    case SLC:         CGspcandslc(Readop())
7392;	                      goto Next

7393;	    case STINDC:      CGstindc()
7394;	                      goto Next

7395;	    case RVC:
7396;	    case RVCN:        CGrvcandrvcn(Readop())
7397;	                      goto Next

7398;	    case CFG:
7399;	    case CFGN:        CGcfgandcfgn(Readop())
7400;	                      goto Next

7401;	    case LX:
7402;	    case SX:
7403;	    case SXQ1:
7404;	    case SXQ2:                  // Not yet implemented. ::::::: :::::::
7405;	                                //-- ::::::: ::::::: ::::::: :::::::
7406;	                      ReadNM()
7407;	                      Report(-1)
7408;	                      goto Next

7409;	    case LG:          LoadT(GLOBAL, ReadNM())
7410;	                      goto Next

7411;	    case LP:          LoadT(LOCAL, ReadNM())
7412;	                      goto Next

7413;	    case LL:          LoadT(LABEL, ReadL())
7414;	                      goto Next

7415;	    case LC:
7416;	    case NUMBARGS:
7417;	    case LN:          LoadT(NUMBER, ReadNM())
7418;	                      goto Next

7419;	    case LZTR:
7420;	    case LSTR:        CGstring(ReadNM(),Op=LSTR)
7421;	                      goto Next

7422;	    case TRUE:        LoadT(NUMBER, true)
7423;	                      goto Next

7424;	    case FALSE:       LoadT(NUMBER, false)
7425;	                      goto Next

7426;	    case DYNVECDEC:
7427;	    case LLP:
7428;	    case LLG:
7429;	    case LLL:
7430;	                      { let DISP:=Op eq LLL => ReadL(), ReadNM()
7431;	                        let XR:=NextP10reg()
7432;	                        and t:=
7433;	                          ((Op eq LLP)\(Op=DYNVECDEC)) => LOCAL,
7434;	                          Op eq LLG => GLOBAL, LABEL
7435;	                        if Op=DYNVECDEC do ReadL()
7436;	                        WRMAC(MOVEI,XR,t,DISP,0,0,0)
7437;	                        LoadT(P10reg,XR)
7438;	                        goto Next
7439;	                       }

7440;	    case SP:          Storein(LOCAL, ReadNM(), 0)
7441;	                      goto Next

7442;	    case SPRH:        Storein(LOCAL, ReadNM(), RH)
7443;	                      goto Next

7444;	    case SPLH:        Storein(LOCAL, ReadNM(), LH)
7445;	                      goto Next

7446;	    case SPQ1:        Storein(LOCAL, ReadNM(), Q1)
7447;	                      goto Next

7448;	    case SPQ2:        Storein(LOCAL, ReadNM(), Q2)
7449;	                      goto Next

7450;	    case SPQ3:        Storein(LOCAL, ReadNM(), Q3)
7451;	                      goto Next

7452;	    case SPQ4:        Storein(LOCAL, ReadNM(), Q4)
7453;	                      goto Next

7454;	    case SPRHZ:       Storein(LOCAL, ReadNM(), RHZ)
7455;	                      goto Next

7456;	    case SPLHZ:       Storein(LOCAL, ReadNM(), LHZ)
7457;	                      goto Next

7458;	    case SG:          Storein(GLOBAL, ReadNM(), 0)
7459;	                      goto Next

7460;	    case SGRH:        Storein(GLOBAL, ReadNM(), RH)
7461;	                      goto Next

7462;	    case SGLH:        Storein(GLOBAL, ReadNM(), LH)
7463;	                      goto Next

7464;	    case SGQ1:        Storein(GLOBAL, ReadNM(), Q1)
7465;	                      goto Next

7466;	    case SGQ2:        Storein(GLOBAL, ReadNM(), Q2)
7467;	                      goto Next

7468;	    case SGQ3:        Storein(GLOBAL, ReadNM(), Q3)
7469;	                      goto Next

7470;	    case SGQ4:        Storein(GLOBAL, ReadNM(), Q4)
7471;	                      goto Next

7472;	    case SGRHZ:       Storein(GLOBAL, ReadNM(), RHZ)
7473;	                      goto Next

7474;	    case SGLHZ:       Storein(GLOBAL, ReadNM(), LHZ)
7475;	                      goto Next

7476;	    case SL:          Storein(LABEL, ReadL(), 0)
7477;	                      goto Next

7478;	    case SLRH:        Storein(LABEL, ReadL(), RH)
7479;	                      goto Next

7480;	    case SLLH:        Storein(LABEL, ReadL(), LH)
7481;	                      goto Next

7482;	    case SLQ1:        Storein(LABEL, ReadL(), Q1)
7483;	                      goto Next

7484;	    case SLQ2:        Storein(LABEL, ReadL(), Q2)
7485;	                      goto Next

7486;	    case SLQ3:        Storein(LABEL, ReadL(), Q3)
7487;	                      goto Next

7488;	    case SLQ4:        Storein(LABEL, ReadL(), Q4)
7489;	                      goto Next

7490;	    case SLRHZ:       Storein(LABEL, ReadL(), RHZ)
7491;	                      goto Next

7492;	    case SLLHZ:       Storein(LABEL, ReadL(), LHZ)
7493;	                      goto Next

7494;	    case STIND:       StoreI(0)
7495;	                      goto Next

7496;	    case STINDRH:     StoreI(RH)
7497;	                      goto Next

7498;	    case STINDLH:     StoreI(LH)
7499;	                      goto Next

7500;	    case STINDQ1:     StoreI(Q1)
7501;	                      goto Next

7502;	    case STINDQ2:     StoreI(Q2)
7503;	                      goto Next

7504;	    case STINDQ3:     StoreI(Q3)
7505;	                      goto Next

7506;	    case STINDQ4:     StoreI(Q4)
7507;	                      goto Next

7508;	    case STINDRHZ:    StoreI(RHZ)
7509;	                      goto Next

7510;	    case STINDLHZ:    StoreI(LHZ)
7511;	                      goto Next

7512;	    case FMULT:
7513;	    case MULT:
7514;	                      { let A1, A2 := Arg1, Arg2
7515;	                        and r:=nil
7516;	                        if H1|Arg1 eq P10reg \
7517;	                           Addrble(Arg2) & H1|Arg2 ne P10reg
7518;	                        do A1, A2 := Arg2, Arg1
7519;	                        Makeaddrble(A1)
7520;	                        r:=MovetoReg(A2, -1)
7521;	                                // to any register
7522;	                        CompMAC((Op=FMULT)=>FMPR,IMUL,r,Addr(A1,V1))
7523;	                        Lose1(P10reg,0,r,0)
7524;	                        goto Next
7525;	                       }

7526;	    case FDIV:
7527;	    case DIV:
7528;	    case REM:
7529;	                      { let r:=nil
7530;	                        Makeaddrble(Arg1)
7531;	                        r:=PairP10reg()
7532;	                                // first of a pair of free registers
7533;	                        MovetoReg(Arg2,r)
7534;	                        CompMAC((Op=FDIV)=>FDVR,IDIV,r,Addr(Arg1,V1))
7535;	                        Lose1(P10reg,0,Op eq REM => r+1, r , 0)
7536;	                        goto Next
7537;	                       }

7538;	    case FPLUS:
7539;	    case PLUS:        CGplus()
7540;	                      goto Next

7541;	    case FMINUS:
7542;	    case MINUS:       CGsubt()
7543;	                      goto Next

7544;	    case EQUIV:
7545;	    case NEQUIV:      Makeaddrble(Arg1)
7546;	                      { let r1,r2 := nil,nil
7547;	                        r1:=MovetoReg(Arg2,-1)
7548;	                        r2:=NextP10reg()

7549;	// set up the truth val if both args the same

7550;	                        WRMAC(Op eq EQUIV => SETO,SETZ, r2, 0,0, 0,0,
7551;	                              0)
7552;	                        CompMAC(CAME, r1, Addr(Arg1, V1))
7553;	                        WRMAC(SETCMM,0,P10reg,r2, 0,0,0)
7554;	                                // Not same, use other result
7555;	                        Lose1(P10reg, 0, r2, 0)
7556;	                                // result in r2
7557;	                       }
7558;	                      goto Next

7559;	    case LSCALE:
7560;	    case RSCALE:      CGscale(Op)
7561;	                      goto Next

7562;	    case COMCOM:
7563;	                      { Makeaddrble(Arg2)
7564;	                        let r:=MovetoReg(Arg1,-1)
7565;	                        CompMAC(HRL,r,Addr(Arg2,V1))
7566;	                        Lose1(P10reg,0,r,0)
7567;	                        goto Next
7568;	                       }

7569;	// case SWAP:
7570;	// { let v_vec 5
7571;	// v|1,v|2,v|3,v|4,v|5_H1|Arg1,H2|Arg1,H3|Arg1,H4|Arg1,H5|Arg1
7572;	// H1|Arg1,H2|Arg1,H3|Arg1,H4|Arg1,H5|Arg1_H1|Arg2,H2|Arg2,H3|Arg2,H4|Arg2,H5|Arg2
7573;	// H1|Arg2,H2|Arg2,H3|Arg2,H4|Arg2,H5|Arg2_v|1,v|2,v|3,v|4,v|5
7574;	// goto Next
7575;	// }

7576;	    case FLS:                   // One of the GREAT features of the
7577;	                                //-- PDP-10
7578;	                      Op := LS
7579;	                      goto rels

7580;	    case FGR:         Op := GR
7581;	                      goto rels

7582;	    case FEQ:         Op:=EQ
7583;	                      goto rels

7584;	    case EQ:
7585;	    case NE:
7586;	    case LS:
7587;	    case GR:
7588;	    case LE:
7589;	    case GE:
7590;	    rels:
7591;	                      {rel
7592;	                        let Relop := Op
7593;	                        test Iszero(Arg2)
7594;	                        then
7595;	                        { switchon Relop into
7596;	                          { case LS:
7597;	                              Relop := GR
7598;	                              endcase

7599;	                            case GR:
7600;	                              Relop := LS
7601;	                              endcase

7602;	                            case LE:
7603;	                              Relop := GE
7604;	                              endcase

7605;	                            case GE:
7606;	                              Relop := LE
7607;	                           }
7608;	                          Lose1(H1|Arg1, H2|Arg1, H3|Arg1, H4|Arg1)
7609;	                         }
7610;	                        or test Iszero(Arg1)
7611;	                           then Stack(SSP-1)
7612;	                           or
7613;	                           { CGrelVal(Relop)
7614;	                                // Leaves true or false on stack
7615;	                             Relop := TRUE
7616;	                            }

7617;	                        Op := Readop()
7618;	                        if Op eq JT logor Op eq JF do
7619;	                        { if Relop eq TRUE do Relop:=NE
7620;	                          CGrel(Relop, Op eq JT, ReadL())
7621;	                          goto Next
7622;	                         }

7623;	// New Op isn^t JT or JF.  Get truth value into stack
7624;	                        if Relop eq TRUE goto L
7625;	                                // there already
7626;	                        Makeaddrble(Arg1)
7627;	                                // get ready to test it
7628;	                        { let OPC,r := nil,NextP10reg()
7629;	                          WRMAC(SETO,r, 0,0, 0,0,0)
7630;	                                // true until tesst
7631;	                          switchon Relop into
7632;	                          { case EQ:
7633;	                              OPC:=SKIPE
7634;	                              endcase

7635;	                            case NE:
7636;	                              OPC:=SKIPN
7637;	                              endcase

7638;	                            case LS:
7639;	                              OPC:=SKIPL
7640;	                              endcase

7641;	                            case GR:
7642;	                              OPC:=SKIPG
7643;	                              endcase

7644;	                            case LE:
7645;	                              OPC:=SKIPLE
7646;	                              endcase

7647;	                            case GE:
7648;	                              OPC:=SKIPGE
7649;	                           }
7650;	                          CompMAC(OPC,0,Addr(Arg1,V1))
7651;	                          WRMAC(SETZ,r, 0,0, 0,0,0)
7652;	                                // false
7653;	                          H1|Arg1,H3|Arg1 := P10reg, r
7654;	                          H2|Arg1,H4|Arg1 := 0 , 0
7655;	                         }
7656;	                        goto L
7657;	                       }rel

7658;	    case RHZ:
7659;	    case LHZ:
7660;	    case Q1Z:
7661;	    case Q2Z:
7662;	    case Q3Z:
7663;	    case Q4Z:
7664;	    case RH:
7665;	    case LH:
7666;	    case Q1:
7667;	    case Q2:
7668;	    case Q3:
7669;	    case Q4:          unless H2|Arg1 eq 0 do MovetoReg(Arg1,-1)
7670;	                      H2|Arg1 := Op
7671;	                      goto Next

7672;	    case LSHIFT:
7673;	    case RSHIFT:      CGshift(Op)
7674;	                      goto Next

7675;	    case LOGAND:
7676;	    case LOGOR:
7677;	    case EQV:
7678;	    case NEQV:        CGlogop(Op)
7679;	                      goto Next

7680;	    case FNEG:        Op:=NEG
7681;	    case NEG:
7682;	    case NOT:         MakeNUMSimple(Arg1)
7683;	                      if H1|Arg1 eq NUMBER & H2|Arg1 eq 0 do
7684;	                      { H3|Arg1 := Op eq NEG => - H3|Arg1 , not H3|Arg1
7685;	                        goto Next
7686;	                       }
7687;	                      Makeaddrble(Arg1)
7688;	                      MovetoReg(Arg1,-1)
7689;	                      CompMAC(Op eq NEG => MOVNS,SETCMM, 0,
7690;	                              Addr(Arg1,V1))
7691;	                      goto Next

7692;	    case RV:          CGrv()
7693;	                      goto Next

7694;	    case JUMP:        Store(0, SSP)
7695;	                      WRMAC(JRST,0, LABEL,ReadL(), 0,0,0)
7696;	                      Outconsts()
7697;	                      goto Next

7698;	    case JT:
7699;	    case JF:          Store(0, SSP-2)
7700;	                      MovetoReg(Arg1,-1)
7701;	                      WRMAC(Op eq JT=>JUMPN,JUMPE, H3|Arg1, LABEL,
7702;	                            ReadL(), 0,0,0)
7703;	                      Stack(SSP-1)
7704;	                      goto Next

7705;	    case GOTO:        Store(0, SSP-2)
7706;	                      MovetoReg(Arg1,-1)
7707;	                      WRMAC(JRST,0, 0,0, 0,H3|Arg1,0)
7708;	                      Initstack(SSP-1)
7709;	                      Outconsts()
7710;	                      goto Next

7711;	    case LAB:         Store(0, SSP)
7712;	                      Initstack(SSP)
7713;	                      WRLAB(ReadL())
7714;	                      goto Next

7715;	    case STACK:       Stack(ReadNM())
7716;	                      goto Next

7717;	    case STORE:       Store(0, SSP)
7718;	                      Initstack(SSP)
7719;	                      goto Next

7720;	    case ENTRY:
7721;	                      { let n := ReadNM()
7722;	                        WRLAB(ReadL())
7723;	                        WRLST("*t;Entry: ")
7724;	                        for i:=1 to n do WRCH(PBIN())
7725;	                        WRCH($*n)
7726;	                        goto Next
7727;	                       }

7728;	    case SAVE:
7729;	                      { let n := ReadNM()
7730;	Push(MaxStack,ReadL())
7731;	                        WRMAC(MOVEM,JSPAC,LOCAL,0, 0,0,0)
7732;	WRMAC(MOVEI,MAXAC,LOCAL,Elt(MaxStack),0,0,0)
7733;	WRMAC(CAMLE,MAXAC,GLOBAL,#272,0,0,0)
7734;	WRMAC(JSP,JSPAC,GLOBAL,#273,0,0,0)
7735;	                        Initstack(n)
7736;	                        goto Next
7737;	                       }

7738;	// case LVRTAP:

7739;	    case FNAP:
7740;	    case RTAP:        CGapply(Op, ReadNM(),Elt(MaxStack))
7741;	                      goto Next

7742;	case ENDEF: Pop(MaxStack)
7743;	goto Next

7744;	    case RNAME:       flgstk|0:=flgstk|0+1
7745;	                      flgstk|(flgstk|0):=false
7746;	                      goto Next

7747;	    case RRTAP:
7748;	    case RFNAP:
7749;	                      { let r:=ReadNM()
7750;	                        let na:=ReadL()

7751;	// switchon r into
7752;	// { default: Report(-1) // bad resproc. cmplr bug
7753;	// goto Next
7754;	// //macro stuff: instr(ac,offset,index,indirect)
7755;	// // chek that line can be put out in 1 instr and
7756;	// // that flgstk|(flgstk|0) is false. not=> error
7757;	// // put out the line ; endcase
7758;	// }

7759;	                        flgstk|0:=flgstk|0-1
7760;	                        goto Next
7761;	                       }

7762;	    case FNRN:        MovetoReg(Arg1, RsltAC)
7763;	                      SSP := SSP - 1

7764;	    case RTRN:        WRMAC(JRST,0, LOCAL,0, 1,0,0)
7765;	                                // Restore flags, while we^re at it
7766;	                      Initstack(SSP)
7767;	                      Outconsts()
7768;	                      goto Next

7769;	    case RES:         Store(0, SSP-2)
7770;	                      MovetoReg(Arg1, RsltAC)
7771;	                      WRMAC(JRST,0, LABEL, ReadL(), 0,0,0)
7772;	                      Stack(SSP-1)
7773;	                      Outconsts()
7774;	                      goto Next

7775;	    case RSTACK:      Stack(ReadNM())
7776;	                      LoadT(P10reg,RsltAC)
7777;	                      goto Next

7778;	    case FINISH:      WRMAC(OpJSYS, 0, NUMBER, #170, 0,0,0)
7779;	                                // HALTF ... pause
7780;	                      goto Next

7781;	    case SWITCHON:    CGswitch()
7782;	                      goto Next

7783;	    case DATALAB:     WRLAB(ReadL())
7784;	                      goto Next

7785;	    case ITEML:       WRMAC(JRST,0, LABEL,ReadL(), 0,0,0)
7786;	                      goto Next

7787;	    case ITEMN:       WRDATA(ReadNM(), 0, 0)
7788;	                      goto Next

7789;	    case ITEMNL:      WRDATA(0, ReadL(), 0)
7790;	                      goto Next

7791;	    case VEC:         WRBLK(ReadNM())
7792;	                      goto Next

7793;	    case ASCIZCONST:
7794;	    case STRINGCONST:
7795;	                      { let n := ReadNM()
7796;	                        storestring(n, ReadL(),Op=STRINGCONST)
7797;	                        goto Next
7798;	                       }

7799;	   }                            // end of switchon block
7800;	 }scan



		CG2.BCP;3


7801;	// BCPL Code Generator -- subroutines.
7802;	// Last modified on mon 23 aug 71 2349.20 by ae.

7803;	// LoadT
7804;	// Lose1
7805;	// Stack
7806;	// Store
7807;	// NextP10reg
7808;	// *ForceP10reg
7809;	// *ScanRegs
7810;	// PairP10reg
7811;	// *StoreT
7812;	// *StoreCodes
7813;	// *Storein
7814;	// StoreI
7815;	// MoveNtoReg
7816;	// *AddNtoReg
7817;	// MakeNUMSimple
7818;	// MovetoReg

7819;	get "<xbcpl>headcg"

7820;	let LoadT(a, b) be
7821;	{ Arg2 := Arg1
7822;	  Arg1 := Arg1 + Tempsize
7823;	  if Arg1 ge TempT do { Report(909); finish }
7824;	  H1|(Arg1), H2|(Arg1) := a, 0
7825;	  H3|(Arg1) := b
7826;	  H4|(Arg1) := 0
7827;	  H5|(Arg1) := SSP
7828;	  SSP := SSP + 1
7829;	 }

7830;	and Lose1(a, b, c, d) be
7831;	{ SSP := SSP - 1
7832;	  test Arg2 eq TempV
7833;	  then
7834;	  { H1|(Arg2), H2|(Arg2) := LOCAL, 0
7835;	    H3|(Arg2), H5|(Arg2) := SSP-2, SSP-2
7836;	   }
7837;	  or Arg1, Arg2 := Arg2, Arg2 - Tempsize
7838;	  H1|(Arg1), H2|(Arg1), H3|(Arg1), H4|(Arg1) := a, b, c, d
7839;	  H5|(Arg1) := SSP - 1
7840;	 }

7841;	and Stack(n) be
7842;	{1
7843;	  if n ge SSP+3 do
7844;	  { Store(0, SSP)
7845;	    Initstack(n)
7846;	    return
7847;	   }

7848;	  while n gr SSP do LoadT(LOCAL, SSP)

7849;	L:
7850;	  if n eq SSP return

7851;	  unless Arg2 eq TempV do
7852;	  { Arg1 := Arg2
7853;	    Arg2 := Arg1 - Tempsize
7854;	    SSP := SSP - 1
7855;	    goto L
7856;	   }

7857;	  if n eq SSP-1 do
7858;	  { for i := 0 to Tempsize-1 do Arg1|(i) := Arg2|(i)
7859;	    SSP := n
7860;	    H1|(Arg2), H2|(Arg2), H3|(Arg2) := LOCAL, 0, SSP-2
7861;	    H5|(Arg2) := SSP-2
7862;	    return
7863;	   }

7864;	  Initstack(n)
7865;	 }1

7866;	and Store(P, R) be
7867;	{1
7868;	  let t := TempV
7869;	  until t gr Arg1 do
7870;	  { let S := H5|(t)
7871;	    if S gr R return
7872;	    if S ge P do StoreT(t)
7873;	    t := t + Tempsize
7874;	   }
7875;	 }1

7876;	and NextP10reg() := valof       // Return a free register number
7877;	{ for i:=1 to #17
7878;	  do if P10regV|i eq 0 do { P10regV|i:=1; resultis i }
7879;	  resultis ForceP10reg()
7880;	 }

7881;	and ForceP10reg() := valof
7882;	{ let x:=nil                    // temp for the stuff below
7883;	  ScanRegs()                    // scan the stack to update P10regV
7884;	                                // first, look for a 0 item
7885;	  for i:=0 to #17
7886;	  do if P10regV|i eq 0 do { P10regV|i:=1; resultis i }

7887;	// having found none of those, look for the oldest

7888;	  x:=TempV
7889;	  { if H1|x eq P10reg & P10regV|(H3|x) eq 1 goto Fnd
7890;	    x:=x+Tempsize
7891;	   }
7892;	  repeatuntil x ge Arg2         // leave top two args alone
7893;	                                // real screw up
7894;	  Report(9999)
7895;	  Store(0,SSP)
7896;	  resultis ForceP10reg()

7897;	Fnd:                            // found a reg
7898;	  StoreT(x)                     // unload it
7899;	  resultis ForceP10reg()
7900;	 }

7901;	and ScanRegs() be
7902;	{ let x:=TempV
7903;	  for i:=0 to #17
7904;	  do if P10regV|i ge 0 do P10regV|i:=0
7905;	  { if H1|x eq P10reg do
7906;	    { let r:=H3|x
7907;	      if P10regV|r eq 0 do P10regV|r:=1
7908;	     }
7909;	    x:=x+Tempsize
7910;	   }
7911;	  repeatuntil x>Arg1
7912;	 }

7913;	and PairP10reg() := valof       // get a contiguous pair of regs
7914;	{ ScanRegs()
7915;	  for i:=0 to #16
7916;	  do if P10regV|i eq 0 & P10regV|(i+1) eq 0 do
7917;	     { P10regV|i,P10regV|(i+1) := 1,1
7918;	       resultis i
7919;	      }

7920;	// no free pair ... force a free pair

7921;	  Store(0,SSP-2)
7922;	  resultis PairP10reg()
7923;	 }

7924;	and StoreT(x) be
7925;	{storet
7926;	  let r:=0
7927;	  if H1|x eq LOCAL & H3|x eq H5|x do switchon H2|x into
7928;	                                     // Vbl is where it should  be
7929;	  { case 0: return              // nothing  to do to it

7930;	    case PLUS:                  // Add to memory
7931;	            if H4|x eq 0 goto STF
7932;	            if H4|x eq 1 do
7933;	            { WRMAC(AOS,0, LOCAL,H5|x, 0,0,0); goto STF
7934;	             }
7935;	            if H4|x eq (-1) do
7936;	            { WRMAC(SOS,0, LOCAL,H5|x, 0,0,0); goto STF
7937;	             }
7938;	            { let r:=NextP10reg()
7939;	              MoveNtoReg(H4|x,r)
7940;	              WRMAC(ADDM,r, LOCAL,H5|x, 0,0,0)
7941;	              goto STF
7942;	             }
7943;	   }

7944;	  if H1|x eq NUMBER do
7945;	  { MakeNUMSimple(x)
7946;	    if H2|x eq 0 do switchon H3|x into
7947;	    { case 0:    WRMAC(SETZM,0, LOCAL,H5|x, 0,0,0)
7948;	                 goto STF

7949;	      case (-1): WRMAC(SETOM,0, LOCAL,H5|x, 0,0,0)
7950;	                 goto STF
7951;	     }
7952;	   }

7953;	  r:=MovetoReg(x,-1)            // bring it into any reg
7954;	  WRMAC(MOVEM,r, LOCAL,H5|x, 0,0,0)
7955;	STF:
7956;	  H1|x, H2|x, H3|x, H4|x := LOCAL, 0, H5|x, 0
7957;	 }storet

7958;	and StoreCodes(Part, LVopcode, LVbitn) be
7959;	{ rv LVopcode, rv LVbitn := 0,0
7960;	  switchon Part into
7961;	  { case 0:   rv LVopcode := MOVEM; return

7962;	    case RH:  rv LVopcode := HRRM; return

7963;	    case LH:  rv LVopcode := HRLM; return

7964;	    case RHZ: rv LVopcode:=HRRZM ; return

7965;	    case LHZ: rv LVopcode:=HRLZM ; return

7966;	    case Q1:  rv LVbitn := 35; endcase

7967;	    case Q2:  rv LVbitn := 26; endcase

7968;	    case Q3:  rv LVbitn := 17; endcase

7969;	    case Q4:  rv LVbitn := 8
7970;	   }
7971;	  rv LVopcode := OpDPB          // not to be confused with the routine
7972;	                                //-- DPB
7973;	  return
7974;	 }

7975;	and Storein(k,n,p) be
7976;	{storein
7977;	  let r,o,b:=MovetoReg(Arg1,-1),nil,nil
7978;	  StoreCodes(p, lv o, lv b)
7979;	  WRMAC(o, r, k, n, 0,0, (b>0=>-1,0), 9, b)
7980;	  Stack(SSP-1)
7981;	 }storein

7982;	and StoreI(p) be
7983;	{storei
7984;	  let Sr:=MovetoReg(Arg2, -1)
7985;	  and Rr,OPC,BN,m := nil, nil, nil, H2|Arg1

7986;	  test m eq PLUS
7987;	  ifnot m:=0
7988;	  ifso
7989;	  { let n:=H4|Arg1
7990;	    test (lh n eq 0) logor (n<0 & (lh (-n) eq 0))
7991;	    ifso m,H2|Arg1 := n,0
7992;	    ifnot m:=0
7993;	   }

7994;	  Rr:=MovetoReg(Arg1, -1)

7995;	  StoreCodes(p, lv OPC, lv BN)
7996;	  WRMAC(OPC, Sr, NUMBER, m, 0, Rr, (BN>0=>-1,0), 9, BN)
7997;	  Stack(SSP-2)
7998;	 }storei

7999;	and MoveNtoReg(N,R) be
8000;	{ if N eq 0 do { WRMAC(SETZ, R, 0,0, 0,0,0); return }
8001;	  if N eq (-1) do { WRMAC(SETO, R, 0,0, 0,0,0); return }
8002;	  if rh N eq 0 do { WRMAC(MOVSI, R, NUMBER, lh N, 0,0,0); return }
8003;	  if ((rh N)&#777777) eq #777777 do
8004;	  { WRMAC(HRLOI, R, NUMBER, (lh N)&#777777, 0,0,0); return
8005;	   }
8006;	  if lh N eq 0 do
8007;	  { WRMAC(MOVEI, R, NUMBER, (rh N)&#777777, 0,0,0); return
8008;	   }
8009;	  if ((lh N)&#777777) eq #777777 do
8010;	  { WRMAC(HRROI, R, NUMBER, (rh N)&#777777, 0,0,0); return
8011;	   }
8012;	  if N<0 & lh (-N) eq 0 do
8013;	  { WRMAC(MOVNI, R, NUMBER, -N, 0,0,0); return
8014;	   }

8015;	  WRMAC(MOVE, R, NUMBER, N, 0,0,1)
8016;	                                // Literal
8017;	  return
8018;	 }

8019;	and AddNtoReg(N, R) be
8020;	{ let NegFlg:=(N<0)
8021;	  if N eq 0 return
8022;	  if NegFlg do N:=-N

8023;	  if lh N eq 0 do
8024;	  { WRMAC(NegFlg=>SUBI,ADDI,R, NUMBER, N, 0,0,0); return
8025;	   }

8026;	  WRMAC(NegFlg=>SUB,ADD,R, NUMBER,N, 0,0,1)
8027;	                                // Literal
8028;	  return
8029;	 }

8030;	and MakeNUMSimple(x) be
8031;	{ unless H1|x eq NUMBER return
8032;	  switchon H2|x into
8033;	  { case RVPLUS: H3|x,H2|x := H3|x + H4|x , RV
8034;	    case RV:     return         // can^t simplify

8035;	    case 0:      endcase

8036;	    case PLUS:   H3|x:=H3|x+H4|x; endcase

8037;	    case LH:     H3|x:= lh H3|x; endcase

8038;	    case RH:     H3|x:= rh H3|x; endcase

8039;	    case Q1:     H3|x:= q1 H3|x; endcase

8040;	    case Q2:     H3|x:= q2 H3|x; endcase

8041;	    case Q3:     H3|x:= q3 H3|x; endcase

8042;	    case Q4:     H3|x:= q4 H3|x; endcase

8043;	    case LHZ:    H3|x:=#777777 & lh H3|x
8044;	    case RHZ:    H3|x:=#777777 & rh H3|x
8045;	    case Q1Z:    H3|x:=#777 & q1 H3|x
8046;	    case Q2Z:    H3|x:=#777 & q2 H3|x
8047;	    case Q3Z:    H3|x:=#777 & q3 H3|x
8048;	    case Q4Z:    H3|x:=#777 & q4 H3|x
8049;	   }
8050;	  H2|x := 0
8051;	  H4|x := 0
8052;	  return
8053;	 }

8054;	and MovetoReg(x, Reg) := valof  // returns the register used
8055;	{loadreg
8056;	  test H1|x eq P10reg
8057;	  ifso
8058;	  { if Reg<0 do Reg:=H3|x
8059;	   }                            // If it^s there already, use it
8060;	  ifnot
8061;	  { if Reg<0 do Reg:=NextP10reg()
8062;	   }                            // O^E get a free one

8063;	// do we have to do anything?
8064;	  if H1|x eq P10reg & H3|x eq Reg & H2|x eq 0 resultis Reg
8065;	                                // No

8066;	  if H1|x eq NUMBER do
8067;	  { MakeNUMSimple(x)
8068;	    if H2|x eq 0                // pure number
8069;	    do
8070;	    { MoveNtoReg(H3|x,Reg)
8071;	      H1|x,H3|x,H4|x := P10reg,Reg,0
8072;	      resultis Reg
8073;	     }
8074;	    if H2|x ne RV do { Report(9999); finish }
8075;	                                // afu
8076;	    WRMAC(MOVE,Reg,NUMBER,rh H3|x, 0,0,0)
8077;	                                // load from that loc
8078;	    H1|x,H2|x,H3|x,H4|x:=P10reg,0,Reg,0
8079;	    resultis Reg
8080;	   }

8081;	// LOCAL, GLOBAL, LABEL or other P10reg by now

8082;	  switchon H2|x into
8083;	  {load
8084;	    case 0:      WRMAC(MOVE,Reg, H1|x,H3|x, 0,0,0)
8085;	                 endcase

8086;	    case PLUS:   WRMAC(MOVE,Reg, H1|x,H3|x, 0,0,0)
8087;	                 AddNtoReg(H4|x,Reg)
8088;	                 endcase

8089;	    case RV:     H2|x:=0
8090;	    DoRV:        MovetoReg(x,Reg)
8091;	                                // get it without the RV
8092;	                 WRMAC(MOVE,Reg,NUMBER,0, 0,Reg,0)
8093;	                 endcase

8094;	    case RVPLUS: test (lh H4|x) eq 0 logor (H4|x<0 & lh(-(H4|x)) eq 0)
8095;	                 ifso
8096;	                 { let n:=H4|x
8097;	                   H2|x:=0
8098;	                   MovetoReg(x,Reg)
8099;	                   WRMAC(MOVE,Reg,NUMBER,n, 0,Reg,0)
8100;	                   endcase
8101;	                  }
8102;	                 ifnot
8103;	                 { H2|x := PLUS
8104;	                   goto DoRV
8105;	                  }

8106;	    case RH:     WRMAC(HRRE,Reg, H1|x,H3|x, 0,0,0)
8107;	                 endcase

8108;	    case LH:     WRMAC(HLRE,Reg,H1|x,H3|x, 0,0,0)
8109;	                 endcase

8110;	    case Q1:     WRMAC(HRL,Reg,H1|x,H3|x, 0,0,0)
8111;	                 WRMAC(LSH,Reg,NUMBER,9,0,0,0)
8112;	                 WRMAC(ASH,Reg,NUMBER,-27, 0,0,0)
8113;	                 endcase

8114;	    case Q3:     WRMAC(HLL,Reg,H1|x,H3|x, 0,0,0)
8115;	                 WRMAC(LSH,Reg,NUMBER,9,0,0,0)
8116;	                 WRMAC(ASH,Reg,NUMBER,-27, 0,0,0)
8117;	                 endcase

8118;	    case Q2:
8119;	    case Q4:     WRMAC((H2|x eq Q2)=> HRL,HLL,Reg,H1|x,H3|x, 0,0,0)
8120;	                 WRMAC(ASH,Reg,NUMBER,-27, 0,0,0)
8121;	                 endcase

8122;	    case RHZ:    WRMAC(HRRZ,Reg, H1|x,H3|x, 0,0,0)
8123;	                 endcase

8124;	    case LHZ:    WRMAC(HLRZ,Reg,H1|x,H3|x, 0,0,0)
8125;	                 endcase

8126;	    case Q3Z:
8127;	    case Q1Z:    WRMAC((H2|x=Q3Z)=>HLR,HRR,Reg,H1|x,H3|x, 0,0,0)
8128;	                 WRMAC(ANDI,Reg,NUMBER,#777,0,0,0)
8129;	                 endcase

8130;	    case Q2Z:
8131;	    case Q4Z:    WRMAC((H2|x eq Q2Z)=> HRR,HLR,Reg,H1|x,H3|x, 0,0,0)
8132;	                 WRMAC(ASH,Reg,NUMBER,-9, 0,0,0)
8133;	                 WRMAC(ANDI,Reg,NUMBER,#777,0,0,0)
8134;	   }load

8135;	  H1|x, H2|x, H3|x, H4|x := P10reg, 0, Reg, 0
8136;	  resultis Reg
8137;	 }loadreg



		CG3.BCP;5


8138;	// BCPL Code generators -- MACRO output routines.

8139;	get "<xbcpl>headcg"
8140;	manifest
8141;	{ undeflab := 410
8142;	  muldef :=   411
8143;	 }

8144;	//A GLOBAL STATIC:
8145;	static
8146;	{ MacroJFN:0
8147;	}

8148;	static
8149;	{ pureblockx:   0
8150;	  progstart:    false
8151;	  purerel:      0
8152;	  impureblockx: 0
8153;	  impurerel:    -1
8154;	 }
8155;	structure
8156;	{ P2
8157;	  { bit 18
8158;	    code bit 2
8159;	    off bit 16
8160;	   }
8161;	 }
8162;	manifest
8163;	{ labtabmax :=  #1777
8164;	  globtabmax := #77
8165;	  littabmax :=  #1777
8166;	 }
8167;	static
8168;	{ lhw:  0
8169;	  rhw:  0
8170;	  rhwr: 0
8171;	  lhwr: 0
8172;	 }
8173;	manifest
8174;	{ intabov := -1
8175;	  extabov := 412
8176;	  dupdef :=  413
8177;	 }
8178;	static
8179;	{ purearea:    #400000
8180;	  pureblock:   vec 380
8181;	  purex:       0
8182;	  purexx:      0
8183;	  impurearea:  #440000
8184;	  impureblock: vec 380
8185;	  impurex:     0
8186;	  impurexx:    0
8187;	 }
8188;	static
8189;	{ impurebase: 0
8190;	  globtab:    vec globtabmax
8191;	  globx:      414
8192;	 }
8193;	static
8194;	{ reljfn:     0
8195;	  p2w:        0
8196;	  p2wr:       0
8197;	  relcounter: 0
8198;	 }
8199;	static
8200;	{ relbits: 0
8201;	  tmpx:    18
8202;	 }
8203;	static
8204;	{ inttab:          vec #50
8205;	  inttabv:         vec #50
8206;	  inttabx:         -1
8207;	  exttab:          vec #50
8208;	  exttabv:         vec #50
8209;	  exttabx:         -1
8210;	  locationcounter: 0
8211;	  impurecounter:   0
8212;	  cglist:          false
8213;	  cgpure:          true
8214;	  cgimpure:        false
8215;	  PURE:            0
8216;	  IMPURE:          0

8217;	// PURE and IMPURE hold the jfns for
8218;	// the pure and impure temporary files respectively
8219;	 }
8220;	structure
8221;	{ P
8222;	  { bit 18
8223;	    code bit 2
8224;	    off bit 16
8225;	   }
8226;	 }
8227;	static
8228;	{ littab:  vec littabmax+1
8229;	  littabv: vec littabmax+1
8230;	  littabx: -1
8231;	  labtab:  vec labtabmax+1
8232;	  labtabv: vec labtabmax+1
8233;	  labtabx: -1
8234;	 }
8235;	manifest
8236;	{ tabov :=     415
8237;	  littabmax := #1777
8238;	  labtabmax := #1777
8239;	 }
8240;	static
8241;	{ relx:        -1
8242;	  purecount:   0
8243;	  impurecount: 0
8244;	  relxr:       0
8245;	  relr:        0
8246;	  relbuf:      vec 380
8247;	  relc:        0
8248;	  tmpcount:    0
8249;	 }
8250;	structure
8251;	{ rbits
8252;	  { r^0^littabmax+1 bit 2
8253;	   }
8254;	 }
8255;	structure
8256;	{ rword
8257;	  { a^18 bit 2
8258;	   }
8259;	 }

8260;	//Routines and functions in this package. * => local
8261;	// *glr50
8262;	// *bl2out
8263;	// *bl2in
8264;	// VMINIT
8265;	// *radix50
8266;	// WRLST
8267;	// RLINIT
8268;	// *outtmp
8269;	// *ftmp
8270;	// *readtmp
8271;	// *litsearch
8272;	// *labsearch
8273;	// *emitw
8274;	// *outrel
8275;	// *frel
8276;	// *cgp1i
8277;	// CGPS2
8278;	// WRINT
8279;	// WREXT
8280;	// *purein
8281;	// *pureout
8282;	// *impurein
8283;	// *impureout
8284;	// WRCH
8285;	// WROCT
8286;	// *WRN
8287;	// WRIMP
8288;	// WRPU
8289;	// WRBLK
8290;	// NoteGlobal
8291;	// *bl1out
8292;	// *bl1in
8293;	// CompMAC
8294;	// *w
8295;	// WRMAC
8296;	// WRLAB
8297;	// WRDATA
8298;	// *OPCODE
8299;	//////////

8300;	let glr50(l):=valof
8301;	{ let k,w,r:=0,vec 4,vec 2
8302;	  for i:=3 to 0 by -1 do
8303;	  { w|i:=l rem 8
8304;	    l:=l/8
8305;	    if l eq 0 then
8306;	    { k:=i
8307;	      break
8308;	     }
8309;	   }
8310;	  r>>String.c^1:=$g
8311;	  r>>String.c^2:=$l
8312;	  l:=3
8313;	  for i:=k to 3 do
8314;	  { r>>String.c^l:=(w|i)+#60
8315;	    l:=l+1
8316;	   }
8317;	  r>>String.n:=6-k
8318;	  resultis radix50(r)
8319;	 }
8320;	and bl2out(bs,ch) be
8321;	{ IDPB(ch,lv bl2sptr)
8322;	 }

8323;	and bl2in(bs):=valof
8324;	{ EofFlg:=false
8325;	  test bl2pptr=bl2sptr
8326;	  then
8327;	  { EofFlg:=true
8328;	    resultis $*e
8329;	   }
8330;	  or resultis ILDB(lv bl2pptr)
8331;	 }

8332;	and VMINIT() be
8333;	{
8334;	  { pureblockx:=0
8335;	SSP_0
8336;	    progstart:=false
8337;	    MacroJFN:=0
8338;	    purerel:=0
8339;	    impureblockx:=0
8340;	    impurerel:=-1
8341;	   }
8342;	  { lhw:=0
8343;	    rhw:=0
8344;	    rhwr:=0
8345;	    lhwr:=0
8346;	   }
8347;	  { purearea:=#400000
8348;	    purex:=0
8349;	    purexx:=0
8350;	    impurearea:=#440000
8351;	    impurex:=0
8352;	    impurexx:=0
8353;	   }
8354;	  { impurebase:=0
8355;	    globx:=-1
8356;	   }
8357;	  { reljfn:=0
8358;	    p2w:=0
8359;	    p2wr:=0
8360;	    relcounter:=0
8361;	   }
8362;	  { relbits:=0
8363;	    tmpx:=18
8364;	   }
8365;	  { inttabx:=-1
8366;	    exttabx:=-1
8367;	    locationcounter:=0
8368;	    impurecounter:=0
8369;	    cglist:=false
8370;	    cgpure:=true
8371;	    cgimpure:=false
8372;	    PURE:=0
8373;	    IMPURE:=0

8374;	// PURE and IMPURE hold the jfns for
8375;	// the pure and impure temporary files respectively
8376;	   }
8377;	  { littabx:=-1
8378;	    labtabx:=-1
8379;	   }
8380;	  { relx:=-1
8381;	    purecount:=0
8382;	    impurecount:=0
8383;	    relxr:=0
8384;	    relr:=0
8385;	    tmpcount:=0
8386;	   }

8387;	 }
8388;	and radix50(v):=valof
8389;	{                               // radix50 input is a string

8390;	// the output is the name converted to radix50
8391;	// and packed into the lower 32 bits of the word

8392;	  let a,w:=nil,0

8393;	// w will have the value as built up

8394;	  let i:=nil
8395;	  i:=v>>String.n
8396;	  i:=(i gt 6)=>6,i
8397;	  for j:=1 to i do
8398;	  { a:=v>>String.c^j
8399;	    test a gt #100
8400;	    ifso
8401;	    { a:=a-#66
8402;	      if a gt #44 then
8403;	      { a:=a-#40
8404;	        if a gt #44 then a:=0
8405;	       }
8406;	     }
8407;	    ifnot
8408;	    { a:=a-#57
8409;	      if a le 0 gt #12 then a:=0
8410;	     }
8411;	    w:=w*#50+a
8412;	   }
8413;	  resultis w
8414;	 }
8415;	and WRLST(s) be
8416;	{ if cglist then
8417;	  {                             // write on the proper file
8418;	    WriteS(OUTPUT,s)
8419;	   }
8420;	  return
8421;	 }
8422;	and RLINIT(ll) be
8423;	{ cglist:=ll

8424;	// indicate whether there is a listing or not

8425;	  OUTPUT:=MacroJFN
8426;	  PURE:=CreateOutput(-pureout)
8427;	  for i:=0 to GlobNMax do { globinfo|i:=-1}
8428;	  return
8429;	 }

8430;	and outtmp(w,r) be
8431;	{ test cgpure
8432;	  ifso
8433;	  { locationcounter:=locationcounter+1
8434;	    test purecount eq 18
8435;	    ifso
8436;	    { pureblock|(pureblockx-18):=purerel
8437;	      pureblockx:=pureblockx+1
8438;	      purerel:=0
8439;	      purecount:=1
8440;	     }
8441;	    ifnot purecount:=purecount+1
8442;	    test pureblockx eq 380
8443;	    ifso
8444;	    { BOUT(PURE,380)
8445;	      for i:=0 to 379 do BOUT(PURE,pureblock|i)
8446;	      pureblockx:=1
8447;	     }
8448;	    ifnot pureblockx:=pureblockx+1
8449;	    pureblock|pureblockx:=w
8450;	    purerel<<rword.a^purecount:=r
8451;	    return
8452;	   }
8453;	  ifnot
8454;	  { impurecounter:=impurecounter+1
8455;	    test impurecount eq 18
8456;	    ifso
8457;	    { impureblock|(impureblockx-18):=impurerel
8458;	      impurecount:=1
8459;	      impureblockx:=impureblockx+1
8460;	      impurerel:=0
8461;	     }
8462;	    ifnot impurecount:=impurecount+1
8463;	    test pureblockx eq 380
8464;	    ifso
8465;	    { BOUT(IMPURE,380)
8466;	      for i:=0 to 379 do BOUT(IMPURE,impureblock|i)
8467;	      impureblockx:=1
8468;	     }
8469;	    ifnot impureblockx:=impureblockx+1
8470;	    impurerel<<rword.a^impurecount:=r
8471;	    impureblock|impureblockx:=w
8472;	    return
8473;	   }
8474;	 }
8475;	and ftmp() be
8476;	{ test cgpure
8477;	  ifso
8478;	  { unless pureblockx eq 0 do
8479;	    { pureblock|(pureblockx-purecount):=purerel
8480;	      BOUT(PURE,pureblockx+1)
8481;	      for i:=0 to pureblockx do BOUT(PURE,pureblock|i)
8482;	      pureblockx:=0
8483;	      purerel:=0
8484;	      purecount:=0
8485;	     }
8486;	   }
8487;	  ifnot
8488;	  { unless impureblockx eq 0 do
8489;	    { impureblock|(impureblockx-impurecount):=impurerel
8490;	      BOUT(IMPURE,impureblockx+1)
8491;	      for i:=0 to impureblockx do BOUT(IMPURE,impureblock|i)
8492;	      impureblockx:=0
8493;	      impurerel:=0
8494;	      impurecount:=0
8495;	     }
8496;	   }
8497;	  return
8498;	 }
8499;	and readtmp() be
8500;	{ if tmpcount eq 0 then
8501;	  {                             // read in a new block
8502;	  back:
8503;	    tmpcount:=BIN((cgpure=>PURE,IMPURE))
8504;	    if EofFlg then return
8505;	    if tmpcount le 0 then
8506;	    { frel()
8507;	      relcounter:=relcounter-tmpcount
8508;	      goto back
8509;	     }
8510;	    tmpx:=18
8511;	   }
8512;	  test tmpx eq 18
8513;	  ifso
8514;	  { relbits:=BIN((cgpure=>PURE,IMPURE))
8515;	    tmpcount:=tmpcount-1
8516;	    tmpx:=1
8517;	   }
8518;	  ifnot tmpx:=tmpx+1
8519;	  p2wr:=relbits<<rword.a^tmpx
8520;	  p2w:=BIN(cgpure=>PURE,IMPURE)
8521;	  tmpcount:=tmpcount-1
8522;	  return
8523;	 }
8524;	and litsearch(x,r):=valof
8525;	{ for i:=0 to littabx do
8526;	  { if littab|i eq x then
8527;	    { if littabv>>rbits.r^i eq r then resultis i
8528;	     }
8529;	   }
8530;	  if littabx eq littabmax then
8531;	  { Report(tabov)
8532;	    resultis 0
8533;	   }
8534;	  littabx:=littabx+1
8535;	  littab|littabx:=x
8536;	  littabv>>rbits.r^littabx:=r
8537;	  resultis littabx
8538;	 }
8539;	and labsearch(l):=valof
8540;	{ for i:=0 to labtabx do
8541;	  { if labtab|i eq l then resultis i
8542;	   }
8543;	  if labtabx eq labtabmax then
8544;	  { Report(tabov)
8545;	    resultis 0
8546;	   }
8547;	  labtabx:=labtabx+1
8548;	  labtab|labtabx:=l
8549;	  labtabv|labtabx:=0
8550;	  resultis labtabx
8551;	 }
8552;	and emitw() be
8553;	{                               // when entered (p2w,p2wr) contains
8554;	                                //-- word

8555;	// it is translated and output to REL file

8556;	  let x,y:=nil,nil
8557;	  x:=lhz p2w
8558;	  y:=rhz p2w
8559;	  if p2wr ge 2 then x:=cgp1i(x,true)
8560;	  if p2wr & 1 eq 1 then y:=cgp1i(y,false)
8561;	  outrel((rhz x,,rhz y),(lhz x)*2+(lhz y))
8562;	  return
8563;	 }
8564;	and outrel(w,r) be
8565;	{ if relx eq 379 then
8566;	  { BOUT(reljfn,(1,,360))
8567;	    relbuf|361:=relr
8568;	    for i:=0 to 379 do BOUT(reljfn,relbuf|i)
8569;	    relx:=-1
8570;	   }
8571;	  test relx eq -1
8572;	  ifso
8573;	  { relbuf|1:=relcounter
8574;	    relr:=#200000000000
8575;	    relxr:=2
8576;	    relc:=1
8577;	    relx:=2
8578;	   }
8579;	  ifnot
8580;	  { test relxr eq 18
8581;	    ifso
8582;	    { relbuf|(relx-18):=relr
8583;	      relr:=0
8584;	      relxr:=1
8585;	      relx:=relx+2
8586;	     }
8587;	    ifnot
8588;	    { relxr:=relxr+1
8589;	      relx:=relx+1
8590;	     }
8591;	   }
8592;	  relc:=relc+1
8593;	  relr<<rword.a^relxr:=r
8594;	  relbuf|relx:=w
8595;	  relcounter:=relcounter+1
8596;	  return
8597;	 }
8598;	and frel() be
8599;	{ unless relx eq -1 do
8600;	  { relbuf|(relx-relxr):=relr
8601;	    BOUT(reljfn,(1,,relc))
8602;	    for i:=0 to relx do BOUT(reljfn,relbuf|i)
8603;	    relx:=-1
8604;	    return
8605;	   }
8606;	 }

8607;	and cgp1i(a,lr):=valof
8608;	{                               // lr:true if left half, false if right
8609;	                                //-- half

8610;	// a is half word to be translated (pass 1 address)

8611;	  let x,y,z:=nil,nil,nil
8612;	  x:=a<<P.code
8613;	  y:=a<<P.off
8614;	  switchon x into
8615;	  { case 1:                     // label (internal: Ln)
8616;	            y:=labtabv|y        // get label table entry
8617;	            x:=lhz y
8618;	            y:=rhz y
8619;	            switchon x into
8620;	            { case 0: Report(undeflab)
8621;	                      resultis 0

8622;	              case 1: resultis (1,,y)

8623;	              case 2: resultis (1,,y+impurebase)
8624;	             }
8625;	    case 0:
8626;	    exter:                      // external name reference
8627;	            z:=exttabv|y
8628;	            z:=lr=>lh z,rh z
8629;	            test z lt 0

8630;	// is there a chain for this half word?

8631;	            ifso z:=0           // no emit a zero
8632;	            ifnot z:=(1,,z)
8633;	            test lr
8634;	            ifso lh exttabv|y:=relcounter
8635;	            ifnot rh exttabv|y:=relcounter
8636;	            resultis z

8637;	    case 2:                     // global
8638;	            z:=lr=>lh globinfo|y,rh globinfo|y
8639;	            test z lt 0         // is there a chain?
8640;	            ifso z:=0
8641;	            ifnot z:=(1,,z)
8642;	            test lr
8643;	            ifso lh globinfo|y:=relcounter
8644;	            ifnot rh globinfo|y:=relcounter
8645;	            resultis z

8646;	    case 3: resultis (1,,y+locationcounter)
8647;	   }
8648;	 }
8649;	and CGPS2(tnm,rnm) be
8650;	{ let counter,entlength:=nil,nil
8651;	                                // pass 2
8652;	  impurebase:=locationcounter+littabx+1

8653;	// now force out the remainder(if any) of the
8654;	// pass 1 pure and impure files

8655;	  cgpure:=true
8656;	  ftmp()
8657;	  cgpure:=false
8658;	  ftmp()
8659;	  EndWrite(PURE)
8660;	  EndWrite(IMPURE)
8661;	  PURE:=FindInput(-purein)
8662;	  if cglist                     // is there a listing?
8663;	  then
8664;	  { if cgimpure then
8665;	    { EndWrite(Block1JFN)
8666;	      OUTPUT:=MacroJFN
8667;	      Block1JFN:=FindInput(-bl1in)
8668;	      WriteS("*n;Impures*n")
8669;	      { let c:=BIN(Block1JFN)
8670;	        if EofFlg break
8671;	        Writech(OUTPUT,c)
8672;	       }
8673;	      repeat
8674;	      WriteS("*n;End of impures*n")
8675;	      EndRead(Block1JFN)
8676;	      if Block2JFN ne 0 do
8677;	      { EndWrite(Block2JFN)
8678;	        Block2JFN:=FindInput(-bl2in)
8679;	        { let c:= BIN(Block2JFN)
8680;	          if EofFlg break
8681;	          Writech(OUTPUT,c)
8682;	         }
8683;	        repeat
8684;	        EndRead(Block2JFN)
8685;	       }
8686;	     }

8687;	// now begin to write REL file
8688;	   }
8689;	  reljfn:=CreateOutput(rnm,36)

8690;	// create REL file

8691;	  counter:=17
8692;	  entlength:=inttabx+globx+2
8693;	  if entlength ne 0 then { BOUT(reljfn,(4,,entlength)) }
8694;	  for i:=0 to inttabx do
8695;	  { test counter eq 17
8696;	    ifso
8697;	    { BOUT(reljfn,0)
8698;	      counter:=0
8699;	     }
8700;	    ifnot counter:=counter+1
8701;	    BOUT(reljfn,inttab|i)
8702;	   }
8703;	  for i:=0 to globx do
8704;	  { test counter eq 17
8705;	    ifso
8706;	    { BOUT(reljfn,0)
8707;	      counter:=0
8708;	     }
8709;	    ifnot counter:=counter+1
8710;	    BOUT(reljfn,glr50(lhz (globtab|i)))
8711;	   }
8712;	  BOUT(reljfn,(6,,1))
8713;	  BOUT(reljfn,0)
8714;	  BOUT(reljfn,radix50(tnm))
8715;	  relcounter:=0
8716;	  cgpure:=true
8717;	  relx:=-1
8718;	  tmpcount:=0
8719;	  { readtmp()
8720;	    if EofFlg break
8721;	    emitw()
8722;	   }
8723;	  repeat
8724;	  for i:=0 to littabx do
8725;	  { p2w:=littab|i
8726;	    p2wr:=littabv>>rbits.r^i
8727;	    emitw()
8728;	   }
8729;	  frel()
8730;	  IMPURE:=FindInput(-impurein)
8731;	  cgpure:=false
8732;	  relx:=-1
8733;	  tmpcount:=0
8734;	  { readtmp()
8735;	    if EofFlg break
8736;	    emitw()
8737;	   }
8738;	  repeat
8739;	  frel()

8740;	// now all done with the code
8741;	// now output the symbol table
8742;	// first output the internals (i.e. entries)

8743;	  unless inttabx eq -1 do
8744;	  { BOUT(reljfn,(2,,inttabx*2+2))
8745;	    counter:=16
8746;	    for i :=0 to inttabx do
8747;	    { test counter eq 16
8748;	      ifso
8749;	      { BOUT(reljfn,#042104210421)

8750;	// rel word for all symtab entries

8751;	        counter:=0
8752;	       }
8753;	      ifnot counter:=counter+2
8754;	      BOUT(reljfn,(inttab|i) logor #040000000000)
8755;	      { let jj:=nil
8756;	        jj:=labtabv|(inttabv|i)
8757;	        BOUT(reljfn,((lhz jj) eq 1)=>(rhz jj),(rhz jj)+impurebase)
8758;	       }
8759;	     }
8760;	   }
8761;	  unless globx eq -1 do
8762;	  { BOUT(reljfn,(2,,globx*2+2))
8763;	    counter:=16
8764;	    for i:=0 to globx do
8765;	    { let jj,kk:=nil,nil
8766;	      test counter eq 16
8767;	      ifso
8768;	      { BOUT(reljfn,#042104210421)
8769;	        counter:=0
8770;	       }

8771;	      ifnot counter:=counter+2
8772;	      BOUT(reljfn,glr50(lhz (globtab|i)) logor #040000000000)
8773;	      jj:=labtabv|(rhz(globtab|i))
8774;	      BOUT(reljfn,((lhz jj) eq 1)=>(rhz jj),(rhz jj)+impurebase)
8775;	     }
8776;	   }

8777;	// now output the global requests

8778;	  if cglist then
8779;	  { for i:= 0 to GlobNMax do
8780;	    { if globinfo|i ne -1 do
8781;	      { WriteS("EXTERN*sGL")
8782;	        WriteOct(i)
8783;	        Writech($*n)
8784;	       }
8785;	     }
8786;	    if progstart then WriteS("*tEXTERN*tBCFRST*n")
8787;	    WriteS("*n*tLIT*n")
8788;	    WriteS(".REQUEST SYS:BCPLIB*n")
8789;	    WriteS("*n*tEND*n*n")
8790;	    EndWrite(MacroJFN)
8791;	   }
8792;	  { let jj,kk:=0,0
8793;	    for i:=0 to GlobNMax do
8794;	    { if globinfo|i ne -1 then jj:=jj+2
8795;	     }
8796;	    if jj ne 0 then BOUT(reljfn,(2,,jj))
8797;	    counter:=16
8798;	    for i:=0 to GlobNMax do
8799;	    { if globinfo|i ne -1 then
8800;	      { test counter eq 16
8801;	        ifso
8802;	        { BOUT(reljfn,#042104210421)
8803;	          counter:=0
8804;	         }
8805;	        ifnot counter:=counter+2
8806;	        BOUT(reljfn,glr50(i) logor #600000000000)
8807;	        BOUT(reljfn,rhz (globinfo|i))
8808;	       }
8809;	     }

8810;	   }

8811;	// now output the external name requests

8812;	  if exttabx ge 0 then
8813;	  { BOUT(reljfn,(2,,exttabx*2+2))
8814;	   }
8815;	  counter:=16
8816;	  for i:=0 to exttabx do
8817;	  { let jj:= nil
8818;	    test counter eq 16
8819;	    ifso
8820;	    { BOUT(reljfn,#042104210421)
8821;	      counter:=0
8822;	     }
8823;	    ifnot counter:=counter+2
8824;	    BOUT(reljfn,#600000000000 logor exttab|i)
8825;	    BOUT(reljfn,(rhz exttabv|i))
8826;	   }

8827;	// now output "IMPURE"

8828;	  BOUT(reljfn,(2,,2))
8829;	  BOUT(reljfn,#40000000000)
8830;	  BOUT(reljfn,#100000000000 logor radix50("IMPURE"))
8831;	  BOUT(reljfn,impurebase)

8832;	// now output the "EXTERN BCFRST" if GL1 is present

8833;	  if progstart then
8834;	  { BOUT(reljfn,(2,,2))
8835;	    BOUT(reljfn,0)
8836;	    BOUT(reljfn,#600000000000 logor radix50("BCFRST"))
8837;	    BOUT(reljfn,0)
8838;	   }

8839;	// ////

8840;	  for i:=1 to RequireTable|0 do
8841;	  { BOUT(reljfn,(#16,,3))
8842;	    BOUT(reljfn,0)
8843;	    BOUT(reljfn,RequireTable|(i*2-1))
8844;	    BOUT(reljfn,RequireTable|(i*2))
8845;	    BOUT(reljfn,0)
8846;	   }
8847;	  for i:=1 to RequestTable|0 do
8848;	  { BOUT(reljfn,(#17,,3))
8849;	    BOUT(reljfn,0)
8850;	    BOUT(reljfn,RequestTable|(i*2-1))
8851;	    BOUT(reljfn,RequestTable|(i*2))
8852;	    BOUT(reljfn,0)
8853;	   }

8854;	// ////////
8855;	// now output the library request

8856;	  BOUT(reljfn,(#17,,3))
8857;	  BOUT(reljfn,0)
8858;	  BOUT(reljfn,#424360545142)

8859;	// the octal number is sixbit 'bcplib'

8860;	  BOUT(reljfn,0)
8861;	  BOUT(reljfn,#637163000000)

8862;	// the octal number is sixbit 'SYS'
8863;	// now output the END block

8864;	  BOUT(reljfn,(5,,1))
8865;	  BOUT(reljfn,#200000000000)
8866;	  BOUT(reljfn,relcounter)
8867;	  EndWrite(reljfn)
8868;	  return
8869;	 }
8870;	and WRINT(v,l) be
8871;	{                               // v is a packed string representing

8872;	// a local name which will be an entry
8873;	// l is the label number

8874;	  let x:=radix50(v)
8875;	  if inttabx=#50                // have we hit the max number?
8876;	  then
8877;	  { Report(intabov)
8878;	    return
8879;	   }
8880;	  inttabx:=inttabx+1
8881;	  inttab|inttabx:=x
8882;	  inttabv|inttabx:=labsearch(l)
8883;	  if Block2JFN eq 0 then Block2JFN:=CreateOutput(-bl2out)
8884;	  WriteS(Block2JFN,v)
8885;	  WriteS(Block2JFN,"=L")
8886;	  WriteN(Block2JFN,l)
8887;	  WriteS(Block2JFN,"*nENTRY*t")
8888;	  WriteS(Block2JFN,v)
8889;	  Writech(Block2JFN,$*n)
8890;	  return
8891;	 }
8892;	and WREXT(v,l) be
8893;	{ let x,i:=radix50(v),nil
8894;	  if exttabx eq #50 then
8895;	  { Report(extabov)
8896;	    return
8897;	   }
8898;	  exttabx:=exttabx+1
8899;	  exttab|exttabx:=x
8900;	  exttabv|exttabx:=-1
8901;	  i:=labsearch(l)
8902;	  if labtabv|i ne 0 then
8903;	  { Report(dupdef)
8904;	    return
8905;	   }
8906;	  labtabv|i:=(3,,exttabx)
8907;	  if Block2JFN eq 0 then Block2JFN:=CreateOutput(-bl2out)
8908;	  WriteS(Block2JFN,"*nEXTERN*t")
8909;	  WriteS(Block2JFN,v)
8910;	  WriteS(Block2JFN,"*nL")
8911;	  WriteN(Block2JFN,l)
8912;	  Writech(Block2JFN,$=)
8913;	  WriteS(Block2JFN,v)
8914;	  Writech(Block2JFN,$*n)
8915;	  return
8916;	 }
8917;	and purein(b):=valof
8918;	{ test purexx eq purex
8919;	  ifso
8920;	  { EofFlg:=true
8921;	    resultis 0
8922;	   }
8923;	  ifnot
8924;	  { let x:=purearea|purexx
8925;	    purexx:=purexx+1
8926;	    EofFlg:=false
8927;	    resultis x
8928;	   }
8929;	 }
8930;	and pureout(b,c) be
8931;	{ if purex ge #40000 then
8932;	  { Report(416)
8933;	    return
8934;	   }
8935;	  purearea|purex:=c
8936;	  purex:=purex+1
8937;	  return
8938;	 }
8939;	and impurein(b):=valof
8940;	{ test impurexx eq impurex
8941;	  ifso
8942;	  { EofFlg:=true
8943;	    resultis 0
8944;	   }
8945;	  ifnot
8946;	  { let x:=impurearea|impurexx
8947;	    impurexx:=impurexx+1
8948;	    EofFlg:=false
8949;	    resultis x
8950;	   }
8951;	 }
8952;	and impureout(b,c) be
8953;	{ if impurex ge #40000 then
8954;	  { Report(417)
8955;	    return
8956;	   }
8957;	  impurearea|impurex:=c
8958;	  impurex:=impurex+1
8959;	  return
8960;	 }

8961;	and WRCH(c) be

8962;	{ if cglist then Writech(OUTPUT,c)
8963;	 }

8964;	and WROCT(e) be
8965;	{ if cglist then WriteOct(OUTPUT,e)
8966;	 }
8967;	and WRN(e) be
8968;	{ if cglist then WriteN(OUTPUT,e)
8969;	 }
8970;	and WRIMP() be
8971;	{ if not cgimpure then
8972;	  { if cglist then Block1JFN:=CreateOutput(-bl1out)
8973;	    cgimpure:=true
8974;	    IMPURE:=CreateOutput(-impureout)
8975;	   }
8976;	  cgpure:=false
8977;	  OUTPUT:=Block1JFN
8978;	  return
8979;	 }
8980;	and WRPU() be
8981;	{ cgpure:=true
8982;	  OUTPUT:=MacroJFN
8983;	  return
8984;	 }
8985;	and WRBLK(n) be
8986;	{ if cglist then
8987;	  { WRLST("*tBLOCK*t")
8988;	    WROCT(n)
8989;	    WRCH($*n)
8990;	   }
8991;	  test cgpure
8992;	  ifso { locationcounter:=locationcounter+n }

8993;	  ifnot { impurecounter:=impurecounter+n }
8994;	  ftmp()
8995;	  BOUT((cgpure=>PURE,IMPURE),-n)
8996;	 }
8997;	and NoteGlobal(G,L) be
8998;	{ let so:=OUTPUT
8999;	  if cglist then
9000;	  { if Block2JFN eq 0 then Block2JFN:=CreateOutput(-bl2out)
9001;	    OUTPUT:=Block2JFN
9002;	    WriteS("GL")
9003;	    WriteOct(G)
9004;	    WriteS("=L")
9005;	    WriteN(L)
9006;	    Writech($*n)
9007;	    WriteS("ENTRY*sGL")
9008;	    WriteOct(G)
9009;	    Writech($*n)
9010;	   }
9011;	  for i:=0 to globx do
9012;	  { if G eq lhz (globtab|i) then
9013;	    { Report(402,G)
9014;	      OUTPUT:=so
9015;	      return
9016;	     }
9017;	   }
9018;	  if globx eq globtabmax then
9019;	  { Report(intabov)
9020;	    OUTPUT:=so
9021;	    return
9022;	   }
9023;	  globx:=globx+1
9024;	  lh (globtab|globx):=G
9025;	  rh (globtab|globx):=labsearch(L)
9026;	  if G eq 1 then progstart:=true
9027;	  OUTPUT:=so
9028;	  return
9029;	 }
9030;	and bl1out(b,c) be
9031;	{ IDPB(c,lv bl1sptr)
9032;	 }
9033;	and bl1in(b):=valof
9034;	{ EofFlg:=false
9035;	  test bl1pptr eq bl1sptr
9036;	  ifso
9037;	  { EofFlg:=true
9038;	    resultis $*e
9039;	   }
9040;	  ifnot resultis ILDB(lv bl1pptr)
9041;	 }
9042;	and CompMAC(o,a,v) be
9043;	{ WRMAC(o,a, v|0,v|1, v|2,v|3,v|4, v|5,v|6)
9044;	 }
9045;	and w(C) be
9046;	{ WRCH(C)
9047;	 }
9048;	and WRMAC(o,a, t,e, i,x,l, s,b) be
9049;	{wrmac                          // o:OPCODE; a:AC; t:Type; e:Eff.addr
9050;	                                //-- (# going with  t)

9051;	// i:Indirect bit; x:XR; l: Literal
9052;	// l_0:: no literal
9053;	// l_1:: straight literal
9054;	// l_-1: [POINT s,  e, b]
9055;	// s:Byte size; b:Right-most bit number of byte

9056;	  structure
9057;	  { P
9058;	    { opcode bit 9
9059;	      AC bit 4
9060;	      indir bit 1
9061;	      index bit 4
9062;	     }
9063;	    Q
9064;	    { bytes bit 6
9065;	      point bit 6
9066;	     }
9067;	   }
9068;	  flgstk|(flgstk|0):=true       // yes, code was output

9069;	// maybe error for resproc if macro statement

9070;	  w($*t)
9071;	  if cglist then WRLST(OPCODE(o))
9072;	  w($*t)

9073;	  lhw<<P.opcode:=o
9074;	  lhw<<P.AC:=a
9075;	  lhw<<P.indir:=i
9076;	  if a>0 do
9077;	  { WROCT(a)
9078;	    w($,)
9079;	    if a>MAXXRNUMBER & a<#16 do MAXXRNUMBER:=a
9080;	   }

9081;	  if i ne 0 do w($*a)

9082;	  if l ne 0 do test l>0
9083;	               ifso w($[)
9084;	               ifnot
9085;	               { WRLST("[POINT*s")
9086;	                 WRN(s)
9087;	                 w($,)
9088;	                }

9089;	  switchon t into
9090;	  { case LOCAL:  if x ne 0 do Report(919)
9091;	                                // Mpl indexing no good
9092;	                 x:=StackAC
9093;	    case 0:
9094;	    case NUMBER:
9095;	    case P10reg: rhwr:=0
9096;	                 rhw:=e
9097;	                 if e<0 do
9098;	                 { w($-)
9099;	                   e:= -e
9100;	                  }
9101;	                 WROCT(e)
9102;	                 endcase

9103;	    case LABEL:  rhwr:=1
9104;	                 rhw:=labsearch(e)
9105;	                 rhw<<P2.code:=1
9106;	                 w($L)
9107;	                 WRN(e)
9108;	                 endcase

9109;	    case GLOBAL: WRLST("GL")
9110;	                 WROCT(e)
9111;	                 rhwr:=1
9112;	                 rhw:=e
9113;	                 rhw<<P2.code:=2
9114;	                 endcase

9115;	    default:     Report(918)
9116;	                 WRLST("ErrorAddress")
9117;	                 rhwr:=0
9118;	                 rhw:=0
9119;	   }

9120;	  if x ne 0 do
9121;	  { w($()
9122;	    WROCT(x)
9123;	    w($))
9124;	   }

9125;	  test l eq 0
9126;	  ifso
9127;	  { lhw<<P.index:=x
9128;	   }
9129;	  ifnot
9130;	  { test l>0
9131;	    ifso w($])
9132;	    ifnot
9133;	    { if b ge 0 do
9134;	      { w($,)
9135;	        WRN(b)
9136;	       }
9137;	      rhw<<Q.bytes:=35-b
9138;	      rhw<<Q.point:=s
9139;	      rhw<<P.index:=x
9140;	      w($])
9141;	     }

9142;	    rhw:=litsearch(rhw,rhwr)
9143;	    rhwr:=1
9144;	    rhw<<P2.code:=3
9145;	    lhw<<P.index:=0
9146;	   }
9147;	  rh lhw:=rhw
9148;	  outtmp(lhw,rhwr)              // do the output to the proper file
9149;	  w($*n)
9150;	  test cgpure then OutA|Off:=OutA|Off+1
9151;	  or OutB|Off:=OutB|Off+1
9152;	 }wrmac

9153;	and WRLAB(n) be
9154;	{ let j:=nil
9155;	  w($L)
9156;	  WRN(n)
9157;	  WRLST(":*n")
9158;	  j:=labsearch(n)
9159;	  test labtabv|j eq 0
9160;	  ifso { labtabv|j:=cgpure=>(1,,locationcounter),(2,,impurecounter) }
9161;	  ifnot { Report(muldef) }
9162;	 }

9163;	and WRDATA(a,l,g) be
9164;	{ let f:=0
9165;	  if l ne 0 do f:=1
9166;	  if g ne 0 do f:=f+2
9167;	  switchon f into
9168;	  { case 3: Report(989)
9169;	            finish
9170;	            endcase

9171;	    case 0: WRLST("*tXWD*t")
9172;	            WROCT(lhz a)
9173;	            w($,)
9174;	            WROCT(rhz a)
9175;	            outtmp(a,0)
9176;	            endcase

9177;	    case 1: WRLST("*tZ*tL")
9178;	            WRN(l)
9179;	            a:=labsearch(l)
9180;	            a<<P2.code:=1
9181;	            outtmp(a,1)
9182;	            endcase

9183;	    case 2: WRLST("*tZ*tGL")
9184;	            WROCT(g)
9185;	            g<<P2.code:=2
9186;	            outtmp(g,1)
9187;	   }
9188;	  w($*n)
9189;	  test cgpure then OutA|Off:=OutA|Off+1
9190;	  or OutB|Off:=OutB|Off+1
9191;	 }

9192;	and OPCODE(o) := selecton o into
9193;	{ default: "**ERROR"
9194;	           get "<XBCPL>opcsplngs"
9195;	 }



		CG4.BCP;4


9196;	// <XBCPL>CG4.BCP;12    28-MAY-73 15:02:49 EDIT BY ROVNER
9197;	// fix for jsp 1,1

9198;	// BCPL Code Generator -- Subroutines.
9199;	// Last modified on tue 31 aug 71 1842.39 by   AE.

9200;	// CGapply
9201;	// CGrv
9202;	// CGsubt
9203;	// Outconsts
9204;	// Outnumbs
9205;	// CGrel
9206;	//CGrelVal
9207;	// CGplus
9208;	// CGshift
9209;	// CGscale
9210;	// CGlogop
9211;	// CGswitch
9212;	// CGstring
9213;	// storestring

9214;	get "<xbcpl>headcg"
9215;	get "<bcpl>utilhead"

9216;	let CGapply(Op, S,MAXSSP) be
9217;	{ let v := vec 10
9218;	  Store(0, SSP-2)
9219;	  Makeaddrble(Arg1)
9220;	  if H1|Arg1 eq LOCAL
9221;	  do while MovetoReg(Arg1,-1)=1 do loop
9222;	  WRMAC(ADDI,StackAC, NUMBER,S, 0,0,0)
9223;	  CompMAC(JSP,JSPAC,Addr(Arg1,v))
9224;	  WRMAC(SUBI,StackAC, NUMBER,S, 0,0,0)
9225;	WRMAC(MOVEI,MAXAC,LOCAL,MAXSSP,0,0,0)
9226;	  Stack(S)
9227;	  if Op eq FNAP do LoadT(P10reg, RsltAC)
9228;	  return
9229;	 }

9230;	and CGrv() be
9231;	{ if H2|(Arg1) eq 0 do
9232;	  { H2|(Arg1) := RV
9233;	    return
9234;	   }
9235;	  if H2|(Arg1) eq PLUS do
9236;	  { H2|(Arg1) := RVPLUS
9237;	    return
9238;	   }
9239;	  MovetoReg(Arg1, -1)
9240;	  H2|(Arg1) := RV
9241;	 }

9242;	and CGsubt() be
9243;	{
9244;	  let r:=nil
9245;	  test Op=FMINUS then Makeaddrble(Arg1)
9246;	  or
9247;	  { MakeNUMSimple(Arg1)
9248;	    MakeNUMSimple(Arg2)
9249;	    if H1|Arg1 eq NUMBER & H2|Arg1 eq 0 & H2|Arg2 eq 0 do
9250;	    { H2|Arg2,H4|Arg2 := PLUS, - H3|Arg1
9251;	      MakeNUMSimple(Arg2)
9252;	      Stack(SSP-1)
9253;	      return
9254;	     }

9255;	    Makeaddrble(Arg1)
9256;	    if Iszero(Arg2) do
9257;	    {
9258;	      MovetoReg(Arg1,-1)
9259;	      CompMAC(MOVNS,0, Addr(Arg1,V1))
9260;	      Lose1(H1|Arg1,H2|Arg1,H3|Arg1,H4|Arg1)
9261;	      return
9262;	     }
9263;	   }
9264;	  r:=MovetoReg(Arg2,-1)
9265;	  CompMAC((Op=FMINUS)=>FSBR,SUB,r, Addr(Arg1,V1))
9266;	  Lose1(P10reg,0,r,0)
9267;	 }

9268;	and Outconsts() be
9269;	{ let i := 0
9270;	  until i eq SvecP do
9271;	  { let Size := Svec|(i+1)
9272;	    WRLAB(Svec|(i))
9273;	    for j := i+2 to i+Size+1 do WRDATA(Svec|(j), 0, 0)
9274;	    i := i + Size + 2
9275;	   }
9276;	  SvecP := 0

9277;	  i := 0
9278;	  until i eq StatP do
9279;	  { let G, L := StatV|(i+1), StatV|(i+2)
9280;	    WRLAB(StatV|(i))
9281;	    WRDATA(G, L, G )
9282;	    i := i + 3
9283;	   }

9284;	  StatP := 0
9285;	 }

9286;	and Outnumbs() be
9287;	{ for i := 1 to ConstP do
9288;	  { WRLAB(ConstL|(i))
9289;	    WRDATA(ConstV|(i), 0, 0)
9290;	   }
9291;	 }

9292;	and CGrel(Relop,b,l) be
9293;	{rel                            // if b is false, use "not Relop"

9294;	// compile a jump^relop to l

9295;	  let OPC,r := nil,nil
9296;	  Store(0,SSP-2)

9297;	  unless b do Relop := selecton Relop into
9298;	  {
9299;	    case EQ: NE
9300;	    case NE: EQ
9301;	    case LE: GR
9302;	    case GE: LS
9303;	    case LS: GE
9304;	    case GR: LE
9305;	   }

9306;	  r:=MovetoReg(Arg1, -1)
9307;	  Initstack(SSP-1)

9308;	  OPC := selecton Relop into
9309;	  {
9310;	    case EQ: JUMPE
9311;	    case NE: JUMPN
9312;	    case LE: JUMPLE
9313;	    case GE: JUMPGE
9314;	    case LS: JUMPL
9315;	    case GR: JUMPG
9316;	   }

9317;	  WRMAC(OPC,r, LABEL,l, 0,0,0)
9318;	 }rel

9319;	and CGrelVal(Relop) be
9320;	{relval                         // Compare Arg2 Relop Arg1

9321;	// and Lose1 a true or false
9322;	// Neither arg is 0

9323;	  let OPC,r,Rr:=nil,nil,nil
9324;	  and Immed:=false
9325;	  and v:=vec 10

9326;	  r:=MovetoReg(Arg2,-1)
9327;	  MakeNUMSimple(Arg1)

9328;	  if H1|Arg1 eq NUMBER & H2|Arg1 eq 0 & lh H3|Arg1 eq 0 do Immed:=true

9329;	  unless Immed do Makeaddrble(Arg1)
9330;	  OPC := selecton Relop into
9331;	  {
9332;	    case EQ: Immed => CAIE,CAME
9333;	    case NE: Immed => CAIN,CAMN
9334;	    case LS: Immed => CAIL,CAML
9335;	    case GR: Immed => CAIG,CAMG
9336;	    case LE: Immed => CAILE,CAMLE
9337;	    case GE: Immed => CAIGE,CAMGE
9338;	   }

9339;	  Rr:=NextP10reg()              // The reg holding the result of this
9340;	                                //-- expr
9341;	  WRMAC(SETO,Rr, 0,0, 0,0,0)    // true until test fails
9342;	  test Immed
9343;	  ifso WRMAC(OPC,r, NUMBER,H3|Arg1, 0,0,0)
9344;	  ifnot CompMAC(OPC,r, Addr(Arg1,v))
9345;	  WRMAC(SETZ,Rr, 0,0, 0,0,0)    // test failed
9346;	  Lose1(P10reg,0,Rr,0)
9347;	 }relval

9348;	and CGplus() be
9349;	{plus
9350;	  let r:=nil
9351;	  and v:=vec 10
9352;	  unless Op=FPLUS do
9353;	  { MakeNUMSimple(Arg1)
9354;	    MakeNUMSimple(Arg2)
9355;	    if H1|Arg1 eq NUMBER & H2|Arg2 eq 0 & H2|Arg1 eq 0 do
9356;	    { H2|Arg2 := PLUS
9357;	      H4|Arg2 := H3|Arg1
9358;	      MakeNUMSimple(Arg2)       // in case it^s a sum of 2 #^s
9359;	      Stack(SSP-1)
9360;	      return
9361;	     }

9362;	    if H1|Arg2 eq NUMBER & H2|Arg2 eq 0 & H2|Arg1 eq 0 do
9363;	    { Lose1(H1|Arg1,PLUS,H3|Arg1,H3|Arg2)
9364;	      return
9365;	     }
9366;	   }

9367;	// have to do it the hard way

9368;	  r:=MovetoReg(Arg2,-1)
9369;	  Makeaddrble(Arg1)
9370;	  CompMAC((Op=FPLUS)=>FADR,ADD,r, Addr(Arg1,v))
9371;	  Lose1(P10reg,0,r,0)
9372;	 }plus

9373;	and CGshift(OP) be
9374;	{shift
9375;	  let r:=nil
9376;	  and Sr:=nil                   // possible register to hold the shift

9377;	// someday, detect the half word to self type op^s

9378;	// detect shifts by a constant

9379;	  MakeNUMSimple(Arg1)
9380;	  if H1|Arg1 eq NUMBER & H2|Arg1 eq 0 & (lh H3|Arg1) eq 0 do
9381;	  { if OP eq RSHIFT do H3|Arg1 := - H3|Arg1
9382;	    if H3|Arg1 eq 0 return
9383;	    r:=MovetoReg(Arg2,-1)
9384;	    WRMAC(LSH,r, NUMBER,H3|Arg1, 0,0,0)
9385;	    Lose1(P10reg,0,r,0)
9386;	    return
9387;	   }

9388;	// can^t shift immed

9389;	  Sr := MovetoReg(Arg1,-1)
9390;	  r:=MovetoReg(Arg2,-1)
9391;	  if OP eq RSHIFT do WRMAC(MOVNS,0, P10reg,Sr, 0,0,0)
9392;	  WRMAC(LSH,r, 0,0, 0,Sr,0)
9393;	  Lose1(P10reg,0,r,0)
9394;	 }shift

9395;	and CGscale(OP) be
9396;	{scale
9397;	  let r:=nil
9398;	  and Sr:=nil                   // possible register to hold the shift

9399;	// someday, detect the half word to self type op^s

9400;	// detect shifts by a constant

9401;	  MakeNUMSimple(Arg1)
9402;	  if H1|Arg1 eq NUMBER & H2|Arg1 eq 0 & (lh H3|Arg1) eq 0 do
9403;	  { if OP eq RSCALE do H3|Arg1 := - H3|Arg1
9404;	    if H3|Arg1 eq 0 return
9405;	    r:=MovetoReg(Arg2,-1)
9406;	    WRMAC(ASH,r, NUMBER,H3|Arg1, 0,0,0)
9407;	    Lose1(P10reg,0,r,0)
9408;	    return
9409;	   }

9410;	// can^t shift immed

9411;	  Sr := MovetoReg(Arg1,-1)
9412;	  r:=MovetoReg(Arg2,-1)
9413;	  if OP eq RSCALE do WRMAC(MOVNS,0, P10reg,Sr, 0,0,0)
9414;	  WRMAC(ASH,r, 0,0, 0,Sr,0)
9415;	  Lose1(P10reg,0,r,0)
9416;	 }scale

9417;	and CGlogop(OP) be
9418;	{logop
9419;	  let r:=nil
9420;	  and OPC:=selecton OP into
9421;	  {
9422;	    case LOGAND: AND
9423;	    case LOGOR:  IOR
9424;	    case EQV:    NXOR
9425;	    case NEQV:   XOR
9426;	   }

9427;	  and A1,A2 := Arg1,Arg2
9428;	  and v:=vec 10

9429;	  if H1|Arg1 eq P10reg logor (Addrble(Arg2) & H1|Arg2 ne P10reg)
9430;	  do A1,A2:=Arg2,Arg1

9431;	  Makeaddrble(A1)
9432;	  r:=MovetoReg(A2,-1)
9433;	  CompMAC(OPC,r,Addr(A1,v))
9434;	  Lose1(P10reg,0,r,0)
9435;	 }logop

9436;	and CGswitch() be
9437;	{
9438;	  let q:=ReadNM()
9439;	  let DLBL:=ReadL()

9440;	  let r:=MovetoReg(Arg1,-1 )

9441;	  for i:=1 to q do              // put out the compare code
9442;	  { let a:=ReadNM()
9443;	    let l:=ReadL()

9444;	    test lh a eq 0
9445;	    ifso WRMAC(CAIN,r, NUMBER,a, 0,0,0)
9446;	    ifnot WRMAC(CAMN,r, NUMBER,a, 0,0,1)
9447;	                                // Literal

9448;	    WRMAC(JRST,0, LABEL,l, 0,0,0)
9449;	                                // Jump if equal
9450;	   }

9451;	  WRMAC(JRST,0, LABEL,DLBL, 0,0,0)
9452;	                                // Jump default: if fall through
9453;	  Stack(SSP-1)

9454;	 }

9455;	and CGstring(n,e) be
9456;	{ let l := NextParam()
9457;	  let r:=NextP10reg()
9458;	  WRMAC(MOVEI,r, LABEL,l, 0,0,0)
9459;	  LoadT(P10reg,r)
9460;	  test NumbArgs()=1 then storestring(n, l)
9461;	  or storestring(n,l,e)
9462;	 }

9463;	and storestring(n, l,e) be
9464;	{ let v := vec 520
9465;	  let Size := n/Bytesperword + 1
9466;	  e:=(NumbArgs()=3) & ~e
9467;	  if e do Size:=n/5+1
9468;	  if SvecP+Size+2 gr SvecT do
9469;	  { let m := NextParam()
9470;	    WRMAC(JRST,0, LABEL,m, 0,0,0)
9471;	    Outconsts()
9472;	    WRLAB(m)
9473;	   }
9474;	  for i := 1 to n do v|i := Readch(INPUT,lv Ch)
9475;	  v|0 := n
9476;	  Svec|SvecP := l
9477;	  Svec|(SvecP+1) := Size
9478;	  test e then
9479;	  { let vv:=vec 200
9480;	    Packstring(v,vv)
9481;	    StringToASCIZ(vv,lv Svec|(SvecP+2))
9482;	   }
9483;	  or Packstring(v, lv Svec|(SvecP+2))
9484;	  SvecP := SvecP + Size + 2
9485;	 }



		CG5.BCP;3


9486;	// Code Generator for BCPL on TENEX -- Structure Stuff.

9487;	// Addrble
9488;	// Iszero
9489;	// Makeaddrble
9490;	// Addr
9491;	// CGstindc
9492;	// CGrvcandrvcn
9493;	// CGcfgandcfgn
9494;	// CGspcandslc

9495;	get "<xbcpl>headcg"

9496;	let Addrble(x) := valof
9497;	{addrble
9498;	  let M:=nil
9499;	  MakeNUMSimple(x)
9500;	  M:= H2|x
9501;	  if M eq 0 & H1|x ne NUMBER resultis true
9502;	  if M eq RV & H1|x eq NUMBER resultis true

9503;	  resultis (H1|x eq P10reg) &

9504;	  (M eq RV logor (M eq RVPLUS & (lh H4|x) eq 0))
9505;	 }addrble

9506;	and Iszero(x) := H1|x eq NUMBER & H2|x eq 0 & H3|x eq 0

9507;	and Makeaddrble(x) be
9508;	{ma
9509;	  let M,D:=nil,nil
9510;	  if Addrble(x) return

9511;	  M,D := H2|x, H4|x
9512;	  unless H1|x eq P10reg
9513;	  do if M eq RV logor M eq RVPLUS do
9514;	     { H2|x,H4|x:=0,0
9515;	       MovetoReg(x,-1)
9516;	       H2|x,H4|x := M,D
9517;	       if Addrble(x) return
9518;	      }

9519;	// well, that didn^t work.

9520;	  MovetoReg(x,-1)
9521;	 }ma

9522;	and Addr(x,v) := valof
9523;	{addr
9524;	  for i:=0 to 6 do v|i := 0
9525;	  Makeaddrble(x)
9526;	  v|0,v|1 := H1|x,H3|x          // the normal case
9527;	  if H1|x eq NUMBER
9528;	  do test H2|x eq RV
9529;	     ifnot Report(979)          // bug*
9530;	     ifso v|4:=0

9531;	  if H1|x eq P10reg &(H2|x eq RV \ H2|x eq RVPLUS)
9532;	  do v|0,v|1,v|3:=NUMBER,(H2|x eq RVPLUS => H4|x,0) , H3|x
9533;	  resultis v
9534;	 }addr

9535;	and CGstindc() be
9536;	{ let f,q,x:=Arg1,Arg2,Arg2-Tempsize
9537;	  let w:=Readop()
9538;	  let v:=vec 10
9539;	  if Arg2 eq TempV do           // get the 3rd argument if it isn^t in
9540;	                                //-- the pseudo stak.
9541;	  { x:=v
9542;	    H1|x,H2|x,H3|x,H5|x:=LOCAL,0,SSP-3,SSP-3
9543;	   }
9544;	  let rp:=PairP10reg()
9545;	  Makeaddrble(x)
9546;	  Makeaddrble(q)
9547;	  test (H1|f eq NUMBER) & (H2|f eq 0) then
9548;	  { WRMAC(MOVE,
9549;	          rp+1,
9550;	          NUMBER,
9551;	          ((((36-w-((H3|f) rem 36)) lshift 6) logor w) lshift 6),,(H3|f)/36,
9552;	          0,
9553;	          0,
9554;	          1)
9555;	    CompMAC(ADD,rp+1,Addr(q,V1))
9556;	   }
9557;	  or
9558;	  { MovetoReg(f,rp)
9559;	    WRMAC(IDIVI,rp,NUMBER,36,0,0,0)
9560;	    CompMAC(ADD,rp,Addr(q,V1))
9561;	    WRMAC(ADDI,rp+1,NUMBER,w-36,0,0,0)
9562;	    WRMAC(MOVN,rp+1,P10reg,rp+1,0,0,0)
9563;	    WRMAC(LSH,rp+1,NUMBER,6,0,0,0)
9564;	    WRMAC(ORI,rp+1,NUMBER,w,0,0,0)
9565;	    WRMAC(LSH,rp+1,NUMBER,24,0,0,0)
9566;	    WRMAC(HRR,rp+1,P10reg,rp,0,0,0)
9567;	   }
9568;	  MovetoReg(x,rp)
9569;	  WRMAC(OpDPB,rp,P10reg,rp+1,0,0,0)
9570;	  Stack(SSP-3)
9571;	 }

9572;	and CGrvcandrvcn(w) be
9573;	{ let f,q:=Arg1,Arg2

9574;	  let rp:=PairP10reg()
9575;	  Makeaddrble(q)
9576;	  test (H1|f eq NUMBER) & (H2|f eq 0) then
9577;	  { WRMAC(MOVE,
9578;	          rp+1,
9579;	          NUMBER,
9580;	          ((((36-w-((H3|f) rem 36)) lshift 6) logor w) lshift 6),,(H3|f)/36,
9581;	          0,
9582;	          0,
9583;	          1)
9584;	    CompMAC(ADD,rp+1,Addr(q,V1))
9585;	   }
9586;	  or
9587;	  { MovetoReg(f,rp)
9588;	    WRMAC(IDIVI,rp,NUMBER,36,0,0,0)
9589;	    CompMAC(ADD,rp,Addr(q,V1))
9590;	    WRMAC(ADDI,rp+1,NUMBER,w-36,0,0,0)
9591;	    WRMAC(MOVN,rp+1,P10reg,rp+1,0,0,0)
9592;	    WRMAC(LSH,rp+1,NUMBER,6,0,0,0)
9593;	    WRMAC(ORI,rp+1,NUMBER,w,0,0,0)
9594;	    WRMAC(LSH,rp+1,NUMBER,24,0,0,0)
9595;	    WRMAC(HRR,rp+1,P10reg,rp,0,0,0)
9596;	   }
9597;	  WRMAC(OpLDB,rp,P10reg,rp+1,0,0,0)
9598;	  if Op eq RVCN do
9599;	  { WRMAC(TDNE,rp,NUMBER,1 lshift (w-1),0,0,1)
9600;	    WRMAC(OR,rp,NUMBER,(-2) lshift (w-1),0,0,1)
9601;	   }
9602;	  Lose1(P10reg,0,rp,0)
9603;	 }

9604;	and CGcfgandcfgn(w) be
9605;	{ let f,x:=Arg1,Arg2
9606;	  Makeaddrble(x)
9607;	  let rp:=PairP10reg()
9608;	  MakeNUMSimple(f)
9609;	  test (H1|f eq NUMBER) & (H2|f eq 0) then
9610;	  { WRMAC(OpLDB,rp,NUMBER,MovetoReg(x,rp+1),0,0,-1,w,H3|f+w-1)
9611;	   }
9612;	  or
9613;	  { Makeaddrble(f)
9614;	    MoveNtoReg(36-w,rp)
9615;	    CompMAC(SUB,rp,Addr(f,V1))
9616;	    WRMAC(LSH,rp,NUMBER,6,0,0,0)
9617;	    WRMAC(ORI,rp,NUMBER,w,0,0,0)
9618;	    WRMAC(LSH,rp,NUMBER,24,0,0,0)
9619;	    WRMAC(HRRI,rp,P10reg,rp+1,0,0,0)
9620;	    MovetoReg(x,rp+1)
9621;	    WRMAC(OpLDB,rp,P10reg,rp,0,0,0)
9622;	   }
9623;	  if Op eq CFGN do
9624;	  { WRMAC(TDNE,rp,NUMBER,1 lshift (w-1),0,0,1)
9625;	    WRMAC(OR,rp,NUMBER,(-2) lshift (w-1),0,0,1)
9626;	   }
9627;	  Lose1(P10reg,0,rp,0)
9628;	 }

9629;	and CGspcandslc(w) be
9630;	{ let f,x:=Arg1,Arg2
9631;	  let rp:=nil

9632;	  Makeaddrble(x)
9633;	  let xrg:=MovetoReg(x,-1)
9634;	  MakeNUMSimple(f)
9635;	  test (H1|f eq NUMBER) & (H2|f eq 0) then
9636;	  { let lhh:=((((36-H3|f-w)lshift 6) logor w)lshift 6)
9637;	    if Op eq SPC do
9638;	    { WRMAC(OpDPB,xrg,NUMBER,((lhh logor StackAC),,ReadNM()),0,0,1)
9639;	      Stack(SSP-2)
9640;	      return
9641;	     }
9642;	    rp:=NextP10reg()
9643;	    MoveNtoReg((lhh,,0),rp)
9644;	   }
9645;	  or
9646;	  { Makeaddrble(f)
9647;	    rp:=NextP10reg()
9648;	    MoveNtoReg(36-w,rp)
9649;	    CompMAC(SUB,rp,Addr(f,V1))
9650;	    WRMAC(LSH,rp,NUMBER,6,0,0,0)
9651;	    WRMAC(ORI,rp,NUMBER,w,0,0,0)
9652;	    WRMAC(LSH,rp,NUMBER,24,0,0,0)
9653;	   }
9654;	  test Op eq SPC then { WRMAC(OR,rp,NUMBER,(StackAC,,ReadNM()),0,0,1)}
9655;	  or test Op=SLC then { WRMAC(HRRI,rp,LABEL,ReadL(),0,0,0)}
9656;	     or WRMAC(HRRI,rp,GLOBAL,ReadNM(),0,0,0)
9657;	  WRMAC(OpDPB,xrg,P10reg,rp,0,0,0)
9658;	  Stack(SSP-2)
9659;	 }


		CONCORDANCE

	prefix declaration codes...
		e....external
		s....static
		m....manifest
		l....label
		v....(local) variable
		f....function
		r....routine
		i....iteration index
		d....dummy argument
		g....global


A                   (d)2624 2628 (d)2632 2649 (v)2861 2879 2880 
                    2886 2896 2897 2897 2898 2907 2916 2916 2917 
                    2919 2921 2921 2922 2931 2939 2939 2940 2942 
                    2945 2949 2949 2951 (v)2959 2963 2967 (v)2975 
                    2977 2980 (v)2983 2986 2991 2991 3000 3003 
                    3006 (v)3017 3020 3030 3031 3031 3034 3037 
                    3040 3041 3042 3045 3049 3054 3055 3055 3059 
                    3075 3075 3076 3076 3084 3101 3102 3102 3105 
                    3108 3109 3109 3112 3113 3113 3116 3119 3120 
                    3120 3123 3124 3124 3129 3130 3130 3136 3141 
                    3151 3151 3153 3156 3156 3159 3162 3162 3166 
                    3170 3170 3173 3177 3177 3180 3184 3184 3187 
                    3191 3191 3201 3206 3206 3207 3207 3212 3225 
                    3231 3235 3235 3237 3240 3240 3242 3245 3245 
                    3251 3255 3255 3257 3263 3263 3265 3268 3268 
                    3271 3275 3275 3277 3280 3280 (v)3291 3301 
                    3308 3308 3316 3316 3322 3329 3330 3330 3333 
                    3333 3338 3340 (v)3343 3382 3386 3386 3390 
                    3393 3393 3398 3398 3400 3400 3405 3406 3406 
                    3413 3415 3415 3419 3419 3422 3441 3441 3446 
                    3447 3473 3473 3481 3487 3491 3491 3494 3502 
                    3503 3504 3509 3510 3510 3512 3516 3518 3518 
                    3527 3527 (v)3578 3582 3586 3607 3616 3621 
                    3621 3626 3630 3630 3634 3638 3638 3641 (v)3651 
                    3654 3656 3656 3657 3657 3658 (v)5468 5469 
                    5469 5474 5474 5476 (v)5784 5785 5786 (v)6177 
                    6179 6180 6180 6185 6192 6193 6195 (v)6264 
                    6268 

a                   (d)2286 2288 (d)2291 2293 (d)2296 2298 (d)2301 
                    2303 (d)2306 2308 (d)2311 2313 (v)3533 3539 
                    3540 3545 3551 3552 3553 3554 3557 3558 3558 
                    3559 3562 3562 3563 (v)3828 3861 (d)6329 
                    6331 6332 6333 6334 6335 6336 6337 6338 6339 
                    6340 6341 6342 6343 6344 6345 6349 6350 6351 
                    6352 6352 6352 6354 6354 6354 6356 6357 6358 
                    6359 6360 6361 (d)6365 6367 6368 6369 6370 
                    6371 6372 6373 6374 6375 6376 6377 6378 6379 
                    6380 (d)7082 7084 7085 7088 7089 7091 (v)7253 
                    7265 (v)7302 7306 (v)7358 7361 7364 7366 
                    (d)7820 7824 (d)7830 7838 8257 (v)8392 8398 
                    8399 8401 8401 8402 8403 8403 8404 8404 8408 
                    8408 8409 8409 8411 8450 8470 8519 8593 (d)8607 
                    8612 8613 (d)9042 9043 (d)9048 9074 9076 
                    9077 9079 9079 9079 (d)9163 9172 9174 9175 
                    9179 9180 9181 (v)9442 9444 9445 9446 

A1                  (v)7514 7518 7519 7522 (v)9427 9430 9431 
                    9433 

A2                  (v)7514 7518 7520 (v)9427 9430 9432 

ABORT               (m)156 (m)471 (m)720 3480 4102 

Abort               (g)30 1754 1800 1823 (r)1867 2408 

AC                  9059 9074 

ADD                 8026 9370 9555 9560 9584 9589 

ADDI                8024 9222 9561 9590 

ADDM                7940 

AddName             (g)626 4259 4337 4652 4709 4758 (r)4779 5108 
                    5120 5316 5619 5748 6156 6800 6898 

AddNtoReg           (r)8019 8087 

Addr                (g)266 7522 7534 7552 7565 7650 7690 9223 
                    9259 9265 9344 9370 9433 (f)9522 9555 9560 
                    9584 9589 9615 9649 

Addrble             (g)264 7517 9429 (f)9496 9510 9517 

AND                 (m)151 (m)439 (m)713 2801 2808 3334 3338 
                    4436 4570 4614 9422 

ANDI                8128 8133 

AOS                 7933 

AR                  (v)6185 6186 6187 6189 6190 

Arg1                (g)199 (s)7048 7221 7224 7224 7224 7224 7514 
                    7516 7518 7530 7534 7545 7552 7564 7608 7608 
                    7608 7608 7610 7626 7650 7653 7653 7654 7654 
                    7669 7669 7670 7682 7683 7683 7684 7684 7684 
                    7687 7688 7690 7700 7701 7706 7707 7762 7770 
                    7821 7822 7822 7823 7824 7824 7825 7826 7827 
                    7837 7838 7838 7838 7838 7839 7852 7853 7858 
                    7869 7911 7977 7985 7989 7991 7994 9219 9220 
                    9221 9223 9231 9232 9235 9236 9239 9240 9245 
                    9247 9249 9249 9250 9255 9258 9259 9260 9260 
                    9260 9260 9265 9306 9327 9328 9328 9328 9329 
                    9343 9344 9353 9355 9355 9357 9362 9363 9363 
                    9369 9370 9379 9380 9380 9380 9381 9381 9382 
                    9384 9389 9401 9402 9402 9402 9403 9403 9404 
                    9406 9411 9427 9429 9430 9440 9536 9573 9605 
                    9630 

Arg2                (g)200 (s)7049 7221 7223 7223 7223 7223 7514 
                    7517 7517 7518 7533 7547 7563 7565 7593 7821 
                    7832 7834 7834 7835 7835 7837 7837 7837 7851 
                    7852 7853 7858 7860 7860 7860 7861 7892 7984 
                    9248 9249 9250 9250 9251 9256 9264 9326 9354 
                    9355 9356 9357 9358 9362 9362 9363 9368 9383 
                    9390 9405 9412 9427 9429 9429 9430 9536 9536 
                    9539 9573 9605 9630 

Args                521 (d)2568 2571 2571 2571 

ASCIZCONST          (m)160 (m)363 (m)739 1040 3030 3348 3788 
                    3888 3933 3946 3949 3967 4358 4360 5599 5602 
                    6281 7793 

ASCIZToString       1298 

ASH                 8112 8116 8120 8132 9406 9414 

ASS                 (m)148 (m)419 (m)709 989 1018 2882 3313 3327 
                    3383 3386 3400 3449 4026 

Assign              (g)639 4029 5202 (f)5370 5380 5380 5386 

b                   (d)2291 2293 (d)2296 2298 (d)2301 2303 (d)2306 
                    2308 (d)2311 2313 (v)3533 3550 3552 3553 
                    3561 3562 (d)6329 6331 6332 6333 6334 6335 
                    6336 6337 6338 6339 6340 6341 6342 6343 6344 
                    6345 6349 6350 6351 6352 6352 6354 6354 6356 
                    6357 6358 6359 6360 6361 (d)7082 7084 7087 
                    7091 (d)7820 7825 (d)7830 7838 (v)7977 7978 
                    7979 7979 (d)8917 (d)8930 (d)8939 (d)8952 
                    (d)9030 (d)9033 (d)9048 9133 9135 9137 (d)9292 
                    9297 

B                   (g)308 1651 (s)2440 2487 2493 2494 2577 2581 
                    2591 2597 2600 2605 2616 2620 2621 2622 (d)2624 
                    2630 2664 2666 2722 (s)2737 (v)2861 2885 
                    2886 2915 2916 2920 2921 2938 2939 2948 2949 
                    (v)2979 2980 (v)2983 2990 2991 3005 3006 
                    (v)3017 3070 3075 3139 3141 3145 3147 3151 
                    3155 3156 3161 3162 3169 3170 3176 3177 3183 
                    3184 3190 3191 3205 3206 3225 3234 3235 3239 
                    3240 3244 3245 3254 3255 3259 3263 3267 3268 
                    3274 3275 3279 3280 (v)3291 3307 3308 3315 
                    3316 3337 3338 (v)3343 3385 3386 3392 3393 
                    3418 3419 3429 3435 3441 3472 3473 3490 3491 
                    3501 3503 3504 3525 3526 3526 3527 (v)3578 
                    3629 3630 3637 3638 (d)4923 4925 4930 4932 
                    4944 4955 4955 4958 4969 4972 4977 (v)5468 
                    5474 5474 5477 (v)5784 5785 5787 (v)6166 
                    6167 6167 6167 6168 6169 (v)6177 6180 6180 
                    6182 6184 6184 6187 6190 6193 6195 (d)6493 
                    6494 

back                (l)8502 8508 

BadDeclaration      6976 6979 6983 6990 (l)7011 

BadOcode            (s)7079 7103 7214 7256 

bbstrt              (v)7105 7178 7180 

BCPLreport          (g)45 1196 2136 (r)2361 2518 2617 2704 2716 
                    2817 2849 3830 7259 

BE                  (m)151 (m)440 3305 

Begin               (v)2562 2562 2562 2563 

BF                  (v)2385 2387 2397 2397 2398 2398 2404 2404 

Big                 (v)2505 2509 2513 2523 2525 2528 2531 2534 
                    2536 2542 2544 2551 

bigups              (d)1453 1457 1459 1460 1461 1463 1465 1466 
                    1466 1468 

BIN                 2390 2395 2399 8503 8514 8520 8669 8679 

BIT                 (m)157 (m)476 (m)720 3662 6939 

BITB                (m)157 (m)477 (m)721 3664 6941 

BITN                (m)157 (m)478 (m)721 3663 6940 

BitsIn              6780 6865 6883 (f)6937 

Bitsperbyte         (m)103 

Bitsperword         (m)106 573 

BL                  (v)4117 4134 (v)4144 4164 (v)4231 4285 

bl1in               8667 (f)9033 

bl1out              8972 (r)9030 

bl1pptr             (g)189 (s)7072 7100 9035 9040 

bl1sptr             (g)190 (s)7073 7101 9031 9035 

bl2in               (f)8323 8678 

bl2out              (r)8320 8883 8907 9000 

bl2pptr             (g)191 (s)7069 7098 8325 8330 

bl2sptr             (g)192 (s)7070 7099 8321 8325 

BLOCK               (m)733 6520 7356 

Block1JFN           (g)215 (s)7064 7124 8665 8667 8669 8675 8972 
                    8977 

Block2JFN           (g)193 (s)7071 7102 8676 8677 8678 8679 8684 
                    8883 8883 8884 8885 8886 8887 8888 8889 8907 
                    8907 8908 8909 8910 8911 8912 8913 8914 9000 
                    9000 9001 

BlockA              (m)285 (m)581 3950 4071 4078 4078 4089 4094 
                    4114 4120 4141 4172 4187 4215 4236 4238 4360 
                    4465 4626 4852 4934 4949 4957 4957 4967 4967 
                    5019 5020 5219 5219 5661 5699 5699 5795 5795 
                    7106 7114 

BlockB              (m)286 (m)582 3951 4361 4708 5716 7115 7123 

BlockIn             (g)612 3721 (s)6458 6504 6508 6515 6521 

BlockWanted         (g)613 3722 (s)6460 6463 6465 6504 6508 6515 
                    6520 6521 

BN                  (v)7985 7995 7996 7996 

BookEnd             (s)2443 2472 2703 2714 

BOUT                7088 7089 7091 8444 8445 8465 8466 8480 8481 
                    8490 8491 8566 8568 8601 8602 8693 8697 8701 
                    8706 8710 8712 8713 8714 8744 8749 8754 8757 
                    8762 8768 8772 8774 8796 8802 8806 8807 8813 
                    8820 8824 8825 8828 8829 8830 8831 8834 8835 
                    8836 8837 8841 8842 8843 8844 8845 8848 8849 
                    8850 8851 8852 8856 8857 8858 8860 8861 8864 
                    8865 8866 8995 

BRACKETLABEL        (m)338 925 930 931 2868 2900 2924 2955 3067 
                    3613 

BRANCHON            (m)155 (m)462 (m)718 3485 4224 4904 

BREAK               (m)156 (m)467 (m)719 3478 4087 

Breaklabel          (g)603 (s)3705 4089 4089 4090 4117 4121 4131 
                    4132 4134 4144 4147 4161 4162 4164 4231 4234 
                    4279 4279 4285 

bs                  (d)1619 (d)2107 (d)2111 (d)8320 (d)8323 

Bss                 91 

BY                  (m)154 (m)460 3454 3466 

BYTE                (m)158 (m)479 (m)721 3665 6943 

Bytebits            (m)104 

BYTEN               (m)158 (m)480 (m)721 3666 6944 

bytes               9064 9137 

ByteSizeOb          (m)691 6943 6944 

Bytesperword        (m)105 875 938 1038 2688 9465 

C                   (s)2212 2216 2216 2217 2231 (v)3017 3202 
                    3207 3207 3207 3212 3262 3263 (v)3343 3426 
                    3439 3441 3497 3498 3503 3504 (v)5035 5036 
                    5039 (v)5054 5060 (d)9045 9046 

c                   96 (d)2296 2298 (d)2301 2303 (d)2306 2308 
                    (d)2311 2313 2457 2608 2614 2692 2694 (v)3543 
                    3546 3552 3553 (v)6421 6427 (d)7830 7838 
                    8310 8311 8314 8398 (v)8669 8671 (v)8679 
                    8681 (d)8930 8935 (d)8952 8957 (d)8961 8962 
                    (d)9030 9031 

CAEreport           (g)324 873 886 915 931 947 1044 1049 1150 
                    1266 1273 1325 1408 1411 1421 1424 1433 1440 
                    1445 2807 2809 (r)2816 2872 2880 2883 2891 
                    2894 2903 2910 2913 2927 2933 2936 2956 2961 
                    2966 2971 2996 3026 3044 3050 3060 3063 3073 
                    3074 3138 3148 3260 3298 3303 3321 3326 3390 
                    3399 3416 3427 3433 3437 3447 3449 3458 3463 
                    3470 3488 3499 3507 3537 3548 3556 3582 3612 
                    3619 3620 3642 3653 

CAIE                9332 

CAIG                9335 

CAIGE               9337 

CAIL                9334 

CAILE               9336 

CAIN                9333 9445 

CAME                7552 9332 

CAMG                9335 

CAMGE               9337 

CAML                9334 

CAMLE               7733 9336 

CAMN                9333 9446 

Capital             (m)768 854 861 1182 

CASE                (m)155 (m)464 (m)718 3493 3503 3542 3552 
                    4168 4905 

CaseMax             (m)74 684 

CaseN               (m)681 684 4170 4179 4194 4204 5035 5042 
                    5042 5042 5048 5048 

CaseP               (g)596 (s)3696 3729 4170 4174 4176 4177 4179 
                    4179 4194 4198 4200 4202 4204 4204 5013 5035 
                    5042 5048 5072 

CaseT               (m)684 3744 4170 4194 

Casetable           (g)595 (s)3695 3745 4174 4176 4177 4198 4200 
                    4202 5041 5043 5043 5045 5051 5058 5058 

CASETO              (m)155 (m)718 3504 3553 4184 4907 

Cautions            (g)19 1596 1847 (s)2182 2372 

CBranch             (s)6723 6753 6764 6846 7012 7013 7014 7026 

cclbool             (s)1558 1630 1756 1802 1825 1862 

cclnm               (v)1610 1611 1628 1628 1630 

cclsw               (d)1891 1893 1898 1918 1939 

Cdefs               (v)2861 2886 2886 2887 2887 2897 

cdn                 (s)1634 1636 1636 1641 

CellWithName        (g)629 4699 5102 5310 5609 5740 6142 6689 

CFG                 (m)734 5512 7398 

CFGB                (m)725 5514 7386 

CFGN                (m)734 5513 7386 7399 9623 

Cg                  (g)60 1817 (r)7093 

CGapply             (g)260 7740 (r)9216 

CGcfgandcfgn        (g)270 7387 7399 (r)9604 

cgimpure            (s)8214 8371 8664 8971 8973 

cglist              (s)8212 8369 8416 8423 8662 8778 8962 8965 
                    8968 8972 8986 8999 9071 

CGlogop             (g)258 7678 (r)9417 

cgp1i               8559 8560 (f)8607 

CGplus              (g)253 7539 (r)9348 

CGPS2               (e)176 7199 (r)8649 

cgpure              (s)8213 8370 8431 8476 8503 8514 8520 8655 
                    8657 8716 8731 8976 8981 8991 8995 9150 9160 
                    9189 

CGrel               (g)256 7620 (r)9292 

CGrelVal            (g)255 7613 (r)9319 

CGreport            7152 (r)7251 

CGrv                (g)259 7692 (r)9230 

CGrvcandrvcn        (g)269 7384 7396 (r)9572 

CGscale             (g)249 7560 (r)9395 

CGshift             (g)257 7673 (r)9373 

CGspcandslc         (g)271 7391 (r)9629 

CGstindc            (g)268 7393 (r)9535 

CGstring            (g)252 7420 (r)9455 

CGsubt              (g)254 7542 (r)9242 

CGswitch            (g)261 7781 (r)9436 

CGWritech           (r)7082 7104 

Ch                  (g)186 (g)297 802 806 806 811 817 817 828 
                    837 851 866 868 906 911 912 915 915 915 917 
                    924 927 933 946 961 963 969 970 976 978 983 
                    985 989 994 995 997 997 999 1008 1010 1016 
                    1016 1018 1019 1026 1031 1031 1040 1043 1049 
                    1052 1054 1054 1054 1056 1056 1056 1058 1061 
                    1062 1062 1062 1062 1065 1067 1095 1097 1099 
                    1129 1135 1151 1152 (d)1180 1180 (s)1231 
                    1246 1247 1247 1247 1248 1248 1249 1250 1252 
                    1253 1255 1257 1257 1257 1259 1259 1259 1262 
                    1325 1325 1325 1399 1399 1399 1492 1492 1492 
                    1493 1493 1493 1495 1497 1497 1497 1497 1497 
                    1497 1501 1897 1898 1899 1901 (s)7068 7227 
                    7229 7233 7234 7235 7236 7237 7238 7239 7240 
                    7245 7246 7247 7248 9474 

ch                  (v)1319 1322 1333 1360 1360 1360 1361 1389 
                    1389 1389 1390 1413 1413 1413 1415 1425 1425 
                    1425 1427 1436 (d)1619 1621 (d)2107 2108 
                    (v)2395 2396 2398 2399 (d)8320 8321 

Chain               2490 2546 (f)2683 2718 

CHAR                (m)158 (m)481 (m)721 3667 6942 

CHARCONST           (m)142 (m)364 (m)699 1135 2783 3034 3034 
                    3358 5594 5894 

CharPtr             (v)2818 2821 2824 

Check               6765 (r)6960 7001 7007 

CheckDistinct       (g)630 4307 4406 4482 4835 

CheckNames          6755 6848 (r)7017 

Chkind              (g)314 798 802 804 851 857 868 904 917 927 
                    928 963 970 978 985 989 995 1010 1019 1653 
                    (s)2738 

chlv                (d)1487 1501 

CL                  (v)4326 4326 (v)4349 4349 (v)5016 5054 (v)5425 
                    5428 

cmdinstream         (s)1560 1630 1631 

code                8158 8223 8612 9105 9113 9144 9180 9185 

COLON               (m)152 (m)445 (m)715 1020 2882 3389 3393 
                    3499 3507 3537 3548 4063 4852 

ComB                506 2664 

COMCOM              (m)147 (m)416 (m)709 962 3265 3268 5447 5921 
                    6068 6349 7562 

COMMA               (m)147 (m)417 (m)709 963 2980 3003 3006 3260 
                    3277 3280 3904 4547 4590 4661 4751 4795 4809 
                    4990 5377 5377 5391 6273 6308 

commands            (l)1892 1977 2004 

ComN                505 2666 

Compdatalab         (g)651 3781 3785 3964 3977 4722 (r)6474 

Compentry           (g)650 4475 (r)6468 

Compile             (l)1696 1750 

Compjump            (g)652 4081 4090 4095 4122 4152 4222 4258 
                    4466 4925 4960 4970 5023 5026 5227 (r)6476 

Complab             (g)649 4064 4074 4082 4084 4123 4125 4132 
                    4149 4154 4162 4180 4206 4216 4264 4267 4271 
                    4279 4504 4937 4952 4961 4963 4971 4973 5027 
                    5068 5230 5233 5665 5706 5709 5805 5810 (r)6466 

CompMAC             (g)245 7522 7534 7552 7565 7650 7689 (r)9042 
                    9223 9259 9265 9344 9370 9433 9555 9560 9584 
                    9589 9615 9649 

COND                (m)148 (m)418 (m)709 972 1013 3257 3263 4966 
                    5218 5278 5697 5792 6164 

ConsoleStream       (g)18 1662 1664 1682 1842 1844 1854 1868 
                    1870 (s)2180 2367 

Constant            (g)610 3720 (s)5861 6147 6161 6421 6422 6426 
                    6427 

CONSTDEF            (m)151 (m)713 2886 

ConstL              (g)203 (s)7054 7128 9288 

ConstP              (g)202 (s)7053 7126 9287 

ConstructTree       (g)58 1706 (r)2754 

ConstV              (g)201 (s)7052 7126 9289 

Copy                2595 (r)2709 2722 

Count               (v)3577 3606 3607 

counter             (v)8650 8691 8695 8698 8700 8700 8704 8707 
                    8709 8709 8745 8747 8751 8753 8753 8763 8766 
                    8769 8771 8771 8797 8800 8803 8805 8805 8815 
                    8818 8821 8823 8823 

CreateOutput        1623 1662 1680 1735 1770 1771 2677 7170 8426 
                    8689 8883 8907 8972 8974 9000 

CSIZE               (m)161 (m)359 (m)743 3079 3379 5522 6223 

Curfile             (g)27 1147 1265 1271 1476 1741 (s)2177 2826 
                    2829 3752 

CURFNM              (g)594 (s)3689 3723 3854 4454 4474 4515 

Curline             (g)26 796 1002 1147 1289 1476 (s)2176 3752 
                    3760 3831 3833 3835 4022 4023 4128 4128 4157 
                    4157 4324 4326 4326 4347 4349 4349 4403 4403 
                    4433 4433 4611 4611 4832 4836 4902 5016 5054 
                    5054 5060 5425 5425 5426 5428 6736 6815 7153 
                    7215 7264 7264 7310 7312 7314 7316 7321 

d                   (d)2204 2236 2251 2282 (d)2301 2303 (d)2306 
                    2308 (d)2311 2313 (d)7830 7838 

D                   (v)9509 9511 9516 

Data                512 570 (v)2241 2242 2243 (v)2246 2247 2255 
                    2275 2277 2279 2281 (v)2370 2380 2381 2381 
                    2381 2508 2514 2537 2542 (d)4297 4306 (d)4322 
                    4326 4330 4334 4337 4338 4341 (v)6572 6658 
                    6659 6660 6661 6665 

DATALAB             (m)732 6475 7783 

Date                496 2481 2481 

Datum               (d)2500 2504 2509 2509 2510 2513 2513 2514 
                    2537 2539 (d)3806 3808 (d)4779 4785 (v)5320 
                    5328 5337 5337 5338 5338 5361 

DE                  (v)2608 2609 2610 2610 2612 2613 2614 (v)2685 
                    2686 2686 2692 2693 2694 2695 2696 2697 (v)4299 
                    4314 (v)4395 4423 (v)4457 4501 (v)5658 5669 

Debug               85 1699 1708 1773 2024 2248 2280 2495 2668 
                    3747 3858 7202 

DebugSW             (g)11 (s)1239 1395 2022 

DECL                (m)735 3809 3816 7332 

DeclareAll          4001 4004 4008 4012 4016 4019 (r)4297 

DeclareMIG          4004 4008 4012 (r)4322 4326 

DeclareStatic       4019 (r)4345 4349 

DeclDyn             4480 4620 (r)4648 4662 4663 

DeclExtList         (g)625 4001 (r)4748 4751 4751 

Decllabels          (g)634 3757 4265 4311 4411 4494 (r)4829 5663 

DeclNames           4405 (r)4608 4615 4616 

DeclStat            (g)623 4351 4632 (f)4695 4853 

Def                 (v)4401 4402 4403 4403 4403 4405 4412 4414 

DEFAULT             (m)155 (m)465 (m)718 3506 3510 3535 3540 
                    4210 4909 

Defaultlabel        (g)605 (s)3707 4213 4215 4216 5015 5024 5034 
                    5034 5039 5070 

DictGetFree         (f)1484 

DictionaryEntry     (g)322 879 (f)1308 1323 1405 1416 1428 1437 

DictO               (s)1235 1311 1313 1313 1314 1315 1321 1324 
                    1327 1332 1408 1409 1410 1414 1421 1422 1423 
                    1426 1433 1434 1435 1438 1441 

DictOffset          (m)340 1313 1486 1645 1646 1646 

DictRetFree         (r)2125 

Digit               (m)766 809 862 928 1183 

dir                 (v)1345 1346 1349 1351 1352 1354 (v)1374 
                    1375 1378 1380 1381 1383 

dirups              (d)1453 1454 1462 1462 1463 1463 

DISP                (v)7430 7436 

DIV                 (m)145 (m)395 (m)704 995 3164 5445 5840 5919 
                    5938 6002 6340 7527 

DL                  (v)5015 5070 

DLBL                (v)9439 9451 

DO                  (m)153 (m)449 1175 3416 3432 3470 

DoControl           (g)321 1016 (r)1317 

DoGet               (g)320 887 (r)1477 

Done                6578 6583 6604 (l)6662 

DoQualName          (g)662 5244 5282 5342 5489 5531 5824 6228 
                    6240 6254 (f)6558 

DoRV                (l)8090 8104 

DOT                 (m)148 (m)421 (m)710 831 943 3657 3657 6580 
                    6673 

DP                  (v)4457 4501 

DS                  (v)4299 4307 4314 (v)4395 4406 4423 (v)4457 
                    4482 4501 (v)4830 4835 (v)5658 5669 

dupdef              (m)8176 8903 

Dvec                (g)589 (s)3686 3739 3740 3740 3742 3742 4701 
                    4710 4711 4714 4740 4742 4782 4785 5113 5115 
                    5320 5323 5611 5624 5753 5754 6143 6144 6692 
                    6695 

DvecE               (g)591 (s)3692 3726 4229 4263 4284 4299 4309 
                    4314 4341 4395 4407 4423 4457 4484 4501 4837 
                    5108 5120 5317 5619 5658 5669 5748 6156 

DvecN               (m)680 683 (s)3691 3691 (s)3692 3692 (s)3694 
                    3694 3725 3725 3726 3726 3728 3728 3742 3742 
                    4780 4786 

DvecP               (g)592 (s)3694 3728 4457 4479 4501 5124 5328 
                    5642 5757 

DvecS               (g)590 (s)3691 3725 4229 4263 4284 4299 4307 
                    4309 4314 4341 4395 4406 4407 4423 4457 4479 
                    4482 4484 4501 4780 4782 4785 4786 4786 4830 
                    4835 4837 5107 5108 5120 5315 5317 5619 5658 
                    5669 5748 6156 

DvecT               (m)683 3738 4780 

DYNVECDEC           (m)741 4537 7426 7433 7435 

E                   (v)4229 4284 

e                   (d)2306 2308 (d)2311 2313 (d)8964 8965 (d)8967 
                    8968 (d)9048 9096 9097 9099 9099 9101 9104 
                    9107 9110 9112 (d)9455 9461 (d)9463 9466 
                    9466 9467 9478 

EL                  (v)4461 4512 (v)5015 5070 

Elt                 (g)227 (f)7283 7732 7740 

elt                 (d)7267 7270 7271 

emitw               (r)8552 8721 8727 8736 

Empty               (m)761 798 904 (m)1549 1653 

END                 (m)152 (m)443 (m)714 1142 2791 2796 2801 
                    2802 2942 2961 7228 7376 

ENDCASE             (m)156 (m)466 (m)719 3476 4219 

Endcaselabel        (g)606 (s)3708 3736 4220 4222 4461 4462 4512 
                    5015 5020 5026 5034 5068 5070 

ENDEF               (m)743 4509 7742 

Endofstreamch       (m)109 

EndRead             1636 1820 2348 2391 2401 8675 8684 

EndWrite            1625 1744 1784 1795 1843 1846 1868 1869 2679 
                    8659 8660 8665 8677 8790 8867 

Enter               1311 

EnterEnd            (g)617 (r)3812 4283 4318 4426 4502 

EnterExt            (g)624 4718 (f)4736 5151 5337 5635 5763 

EnterSymbol         (g)616 (f)3806 4261 4338 4653 4724 6802 6900 

entlength           (v)8650 8692 8693 8693 

Entrance            (d)1579 1611 1667 1669 1755 1801 1824 1861 

ENTRY               (m)733 6471 7720 

EOF                 999 (l)1142 

EofFlg              1898 2112 2115 7228 8324 8327 8504 8670 8680 
                    8720 8735 8920 8926 8942 8948 9034 9037 

EQ                  (m)145 (m)399 (m)705 970 3196 3214 5457 5903 
                    6333 7582 7584 7632 9299 9300 9310 9332 

EQUIV               (m)146 (m)407 (m)707 3249 5463 5917 6360 
                    7544 7550 

EQV                 (m)146 (m)405 (m)706 3247 4956 5461 5915 
                    6048 6358 7677 9424 

EqVec               (g)122 2893 2912 2935 2965 (f)3008 3072 3618 

Err                 (l)5730 5738 

ERROR               (m)157 (m)472 (m)720 3045 5585 6285 

Error               (d)2361 2362 2362 

ERRORNAME           (g)114 (g)586 (s)2746 2769 2880 2973 2998 
                    3400 3447 3645 3653 3742 

errs                (v)2388 2389 2390 2391 2393 2394 2395 2399 
                    2401 

EvalBinop           5942 (f)6329 

EvalConst           (g)644 3873 3912 3928 3936 4174 4189 4189 
                    4244 4328 4368 4536 4554 4582 4594 4666 4798 
                    4810 4813 4997 5383 6315 (f)6413 6781 6866 
                    6924 6926 

EvalQN              6244 6268 (f)6392 

EvalSize            (g)663 5522 5526 6224 6226 (f)6667 

EvalStringAp        6187 6215 6266 (f)6410 

EvalUnop            6138 (f)6365 

ExpOK               (d)3532 3556 

EXT                 (m)150 (m)434 (m)712 2923 2939 4000 4701 
                    4743 4758 5148 5336 5632 5761 7345 

extabov             (m)8175 8895 

ExtDecl             (g)21 1690 (s)2170 3768 3769 3769 4716 4719 
                    4720 4742 4743 4756 5153 5338 5638 5765 

ExtDeclN            (m)72 78 3766 3766 4745 4753 

ExtDeclS            (g)22 1690 (s)2171 3766 4737 4745 4752 

ExtDeclT            (m)78 1689 4738 

exter               (l)8626 

ExtraSymb           (g)300 792 831 1174 (s)1226 

exttab              (s)8207 8824 8899 

exttabv             (s)8208 8627 8634 8635 8825 8900 

exttabx             (s)8209 8366 8812 8813 8816 8894 8898 8898 
                    8899 8900 8906 

f                   (d)2311 2313 2461 2686 (v)2690 2696 2696 
                    2699 (v)9164 9165 9166 9166 9167 (v)9536 
                    9547 9547 9551 9551 9558 (v)9573 9576 9576 
                    9580 9580 9587 (v)9605 9608 9609 9609 9610 
                    9613 9615 (v)9630 9634 9635 9635 9636 9646 
                    9649 

F                   (v)4724 4725 (f)6307 6309 6318 6327 (v)6620 
                    6627 6633 6636 6636 6643 6643 (d)6960 6976 
                    6983 6987 6987 6990 6991 6991 7001 7007 7008 
                    7008 

FADR                9370 

FALSE               (m)142 (m)366 (m)699 2767 3042 3372 5575 
                    5896 7424 

FalseArm            (v)5794 5796 5805 

FALSENODE           (g)116 (s)2748 2767 3042 

FBody               (v)4463 4464 4504 4513 

FDB                 498 2482 

FDIV                (m)144 (m)388 (m)703 952 3187 5442 5925 5938 
                    6345 7526 7534 

FDN                 497 2484 

FDVR                7534 

FEQ                 (m)144 (m)390 (m)703 953 3194 3222 5467 5927 
                    5940 7582 

FGR                 (m)144 (m)389 (m)703 954 3195 3223 5444 5928 
                    5940 7580 

File                1540 1669 1671 1847 1874 2029 

filechars           (v)1672 1673 1674 1675 1676 1677 1679 

Fill                (d)2725 2727 

FILL                (m)158 (m)482 (m)722 3579 3582 3586 6882 

FillWord            (s)2451 2471 2498 2544 2575 

FindInput           1269 1630 1811 1812 2325 2388 2393 8661 8667 
                    8678 8730 

FINISH              (m)156 (m)470 (m)720 3479 3759 4101 7778 

FixName             1478 (r)1504 

flgstk              (g)194 (s)7074 7144 7145 7744 7744 7745 7745 
                    7759 7759 9068 9068 

FLS                 (m)144 (m)391 (m)703 955 3193 3221 5443 5926 
                    5940 7576 

FMINUS              (m)143 (m)386 (m)702 949 3118 3180 3360 5441 
                    5923 5939 6343 7541 9245 9265 

FMPR                7522 

FMULT               (m)144 (m)387 (m)702 951 3186 5466 5924 5939 
                    6344 7512 7522 

fn                  (d)2754 2773 

FNAP                (m)152 (m)714 3141 3151 3398 5080 5674 5692 
                    6272 7739 9227 

Fnd                 7889 (l)7897 

FNDEF               (m)151 (m)713 3316 4452 4625 

FNEG                (m)144 (m)703 3120 5553 7680 

FNRN                (m)723 4497 7762 

FOR                 (m)154 (m)458 (m)717 3443 3473 4228 

ForceP10reg         7879 (f)7881 7896 7899 

FPLUS               (m)143 (m)385 (m)702 948 3115 3179 3359 5465 
                    5922 5939 6342 7538 9352 9370 

FreelistC           (s)1569 1659 1710 1775 

FreelistL           (s)1570 1661 1710 1775 

FreelistP           (s)1567 1655 1710 1714 1775 2133 2134 2134 
                    2135 

FREELISTSTART       (v)1646 1655 1657 1659 

FreelistT           (s)1568 1657 2135 

frel                8506 (r)8598 8729 8739 

FSBR                9265 

ftmp                (r)8475 8656 8658 8994 

Function            (d)4297 4306 

FunctionBody        (g)599 (s)3701 3732 4463 4469 4513 4704 4711 
                    5572 

G                   (d)8997 9003 9008 9012 9013 9024 9026 (v)9279 
                    9281 9281 

g                   (d)9163 9166 9184 9185 9186 

GE                  (m)146 (m)403 (m)706 3201 3220 4277 5436 
                    5907 6338 7589 7603 7605 7647 9302 9303 9313 
                    9337 

Get                 (f)2225 2241 2246 

GET                 (m)141 (m)352 881 

getargs             1667 (r)1891 

GetConnDir          1349 1378 (f)1471 

GetFileMax          (m)73 79 1273 

GetnameP            (g)20 1271 1273 1287 1288 1288 1598 (s)2169 
                    2484 2488 

GetnameT            (m)79 1691 1694 

GetnameV            (g)17 1287 1692 1694 (s)2167 2325 2489 2829 

GetP                (g)305 1142 1145 1145 1146 1147 1265 1266 
                    1268 1268 (s)2741 2758 

GetT                (m)336 1266 2763 

GetTable            6602 6677 (f)6686 

GetV                (g)304 1146 1147 1265 (s)2740 2758 2763 

GLOBAL              (m)159 (m)723 2867 4003 4004 4330 4710 4711 
                    5136 5333 5649 5767 7377 7409 7434 7458 7460 
                    7462 7464 7466 7468 7470 7472 7474 7733 7734 
                    9109 9656 

globinfo            (g)213 (s)7063 7172 8427 8638 8638 8643 8644 
                    8780 8794 8799 8807 

GlobNMax            (m)75 4331 4332 7171 8427 8779 8793 8798 

globtab             (s)8190 8710 8772 8773 9012 9024 9025 

globtabmax          (m)8164 8190 9018 

globx               (s)8191 8355 8692 8703 8761 8762 8764 9011 
                    9018 9023 9023 9024 9025 

glr50               (f)8300 8710 8772 8806 

gn                  (d)7251 7261 

GOTO                (m)152 (m)444 (m)715 3402 4058 7705 

GR                  (m)146 (m)404 (m)706 985 3199 3218 5434 5905 
                    6336 7580 7587 7597 7599 7641 9301 9304 9315 
                    9335 

Greeting            (s)1562 1893 1929 

H1                  (m)65 2246 2277 2282 3298 3390 3398 3398 
                    3779 3793 3867 3903 3942 3948 3949 3963 3972 
                    3996 4035 4060 4070 4103 4127 4130 4148 4151 
                    4156 4159 4324 4347 4354 4360 4360 4402 4432 
                    4435 4468 4533 4567 4570 4575 4581 4610 4613 
                    4630 4650 4751 4795 4796 4796 4808 4847 4929 
                    4990 4995 5077 5192 5272 5376 5377 5391 5406 
                    5418 5469 5469 5675 5736 5785 5888 6186 6189 
                    6202 6211 6214 6217 6252 6252 6265 6308 6313 
                    6580 6586 6673 6676 6687 6736 6737 6815 6817 
                    7223 7224 7516 7517 7608 7653 7683 7824 7834 
                    7838 7860 7889 7905 7927 7944 7956 8031 8056 
                    8064 8066 8071 8078 8084 8086 8106 8108 8110 
                    8114 8119 8122 8124 8127 8131 8135 9220 9249 
                    9260 9328 9355 9362 9363 9380 9402 9429 9429 
                    9501 9502 9503 9506 9512 9526 9527 9531 9542 
                    9547 9576 9609 9635 

H2                  (m)66 2248 2249 2258 2264 2272 2546 3742 
                    3782 3791 3873 3874 3879 3883 3905 3915 3919 
                    3923 3928 3956 3965 3970 4022 4028 4029 4035 
                    4041 4041 4049 4052 4059 4059 4072 4079 4106 
                    4106 4126 4128 4150 4157 4174 4189 4217 4259 
                    4261 4290 4306 4324 4325 4326 4347 4348 4349 
                    4401 4403 4433 4437 4474 4474 4475 4536 4545 
                    4547 4550 4557 4571 4582 4586 4587 4588 4590 
                    4597 4611 4615 4620 4632 4662 4751 4757 4782 
                    4795 4801 4809 4812 4813 4814 4853 4861 4862 
                    4865 4870 4888 4892 4893 4896 4897 4900 4902 
                    4910 4912 4930 4935 4940 4945 4950 4958 4968 
                    4991 5000 5029 5029 5095 5106 5118 5124 5202 
                    5223 5243 5271 5314 5329 5380 5381 5386 5391 
                    5425 5448 5468 5487 5522 5526 5531 5568 5583 
                    5590 5594 5601 5617 5627 5643 5663 5664 5675 
                    5680 5680 5691 5701 5746 5757 5774 5781 5784 
                    5785 5796 5820 5823 5897 5929 5931 5976 5982 
                    5990 5997 6008 6017 6026 6034 6045 6051 6055 
                    6061 6065 6133 6134 6150 6165 6166 6175 6177 
                    6190 6200 6203 6205 6209 6212 6218 6220 6224 
                    6226 6228 6237 6238 6244 6250 6251 6265 6279 
                    6299 6309 6318 6470 6582 6600 6675 6677 6690 
                    6693 6699 6736 6740 6745 6770 6800 6802 6815 
                    6819 6824 6834 6883 6898 6900 6915 6916 6924 
                    6924 7223 7224 7608 7654 7669 7670 7683 7824 
                    7834 7838 7860 7927 7946 7956 7985 7991 8032 
                    8033 8050 8064 8068 8074 8078 8082 8089 8097 
                    8103 8119 8127 8131 8135 9231 9232 9235 9236 
                    9240 9249 9249 9250 9260 9328 9355 9355 9356 
                    9362 9362 9380 9402 9500 9506 9511 9514 9516 
                    9528 9531 9531 9532 9542 9547 9576 9609 9635 

H3                  (m)67 2251 3906 3912 4024 4028 4029 4037 
                    4039 4039 4040 4049 4050 4050 4051 4066 4073 
                    4080 4124 4128 4155 4157 4181 4189 4242 4242 
                    4291 4311 4313 4324 4337 4338 4347 4351 4403 
                    4411 4421 4433 4438 4442 4443 4480 4548 4554 
                    4568 4572 4575 4591 4594 4611 4616 4663 4666 
                    4751 4795 4798 4809 4810 4858 4863 4866 4870 
                    4875 4878 4883 4883 4898 4900 4905 4913 4936 
                    4941 4946 4951 4959 4962 4969 4992 4997 5025 
                    5093 5225 5244 5282 5342 5380 5383 5391 5427 
                    5449 5468 5489 5677 5677 5679 5689 5689 5690 
                    5702 5784 5785 5799 5824 5929 5931 5974 5980 
                    5988 5997 6024 6032 6049 6053 6059 6063 6069 
                    6168 6169 6175 6177 6203 6240 6254 6276 6288 
                    6311 6315 6587 6588 6612 6618 6624 6680 6736 
                    6741 6772 6815 6820 6828 6922 6923 6926 7223 
                    7224 7608 7653 7684 7684 7684 7701 7707 7825 
                    7835 7838 7860 7889 7906 7927 7946 7956 8033 
                    8033 8036 8036 8037 8037 8038 8038 8039 8039 
                    8040 8040 8041 8041 8042 8042 8043 8043 8044 
                    8044 8045 8045 8046 8046 8047 8047 8048 8048 
                    8058 8064 8070 8071 8076 8078 8084 8086 8106 
                    8108 8110 8114 8119 8122 8124 8127 8131 8135 
                    9250 9260 9328 9343 9357 9363 9363 9380 9381 
                    9381 9382 9384 9402 9403 9403 9404 9406 9506 
                    9526 9532 9542 9551 9551 9580 9580 9610 9636 

H4                  (m)68 4064 4083 4177 4207 4250 4251 4253 
                    4255 4328 4353 4368 4444 4494 4494 4497 4497 
                    4621 4852 4856 4898 4900 4907 4972 5231 5707 
                    5806 6168 6169 6745 6752 6780 6834 6845 6865 
                    7608 7654 7826 7838 7931 7932 7935 7939 7956 
                    7989 8033 8036 8051 8071 8078 8087 8094 8094 
                    8094 8096 8135 9250 9260 9357 9504 9511 9514 
                    9516 9532 

H5                  (m)69 4202 4244 4244 4475 4481 4626 4632 
                    4635 6781 6781 6866 6866 7223 7224 7827 7835 
                    7839 7861 7870 7927 7933 7936 7940 7947 7949 
                    7954 7956 9542 

H6                  (m)70 4265 4266 

Help                86 1357 1386 1640 1688 1688 1779 1814 1814 
                    1860 1860 1879 1879 1921 1959 2027 2125 2329 
                    2368 2407 2407 2618 2772 2772 3756 3756 7269 
                    7279 

HLL                 8114 8119 

HLR                 8127 8131 

HLRE                8108 

HLRZ                8124 

HRL                 7565 8110 8119 

HRLM                7963 

HRLOI               8004 

HRLZM               7965 

HRR                 8127 8131 9566 9595 

HRRE                8106 

HRRI                9619 9655 9656 

HRRM                7962 

HRROI               8010 

HRRZ                8122 

HRRZM               7964 

i                   (i)1450 1450 (i)1460 1461 1461 1463 (i)1465 
                    1466 1466 1468 (i)1508 1509 (i)1618 1618 
                    (i)1627 1627 (i)1930 1930 (i)1943 1945 (i)1986 
                    1988 1991 (i)1995 1996 1997 2000 2015 2016 
                    2044 2045 2045 2046 (i)2065 2066 2067 2070 
                    (i)2097 2098 2099 2102 (i)2121 2122 (i)2404 
                    2404 (i)2678 2678 (v)2832 2834 2834 2835 
                    2835 2836 2836 2836 2837 2840 2840 2841 2841 
                    2842 2843 2843 2843 2845 (i)3766 3768 3769 
                    3769 (i)3770 3770 (i)4557 (i)4597 (i)5000 
                    (i)5385 (i)5603 5603 (i)6472 6472 (i)7138 
                    7138 (i)7340 7340 (i)7351 7351 (i)7724 (i)7858 
                    7858 7858 (i)7877 7878 7878 7878 (i)7885 
                    7886 7886 7886 (i)7903 7904 7904 (i)7915 
                    7916 7916 7917 7917 7918 (i)8302 8303 8306 
                    (i)8313 8314 (v)8394 8395 8396 8396 8396 
                    8397 (i)8427 8427 (i)8445 8445 (i)8466 8466 
                    (i)8481 8481 (i)8491 8491 (i)8525 8526 8527 
                    8527 (i)8540 8541 8541 (i)8568 8568 (i)8602 
                    8602 (i)8694 8701 (i)8703 8710 (i)8724 8725 
                    8726 (i)8746 8754 8756 (i)8764 8772 8773 
                    (i)8779 8780 8782 (i)8793 8794 (i)8798 8799 
                    8806 8807 (i)8816 8824 8825 (i)8840 8843 
                    8844 (i)8847 8850 8851 (v)8893 8901 8902 
                    8906 (i)9011 9012 (d)9048 9075 9081 (v)9269 
                    9270 9271 9272 9273 9273 9274 9274 9277 9278 
                    9279 9279 9280 9282 9282 (i)9287 9288 9289 
                    (i)9441 (i)9474 9474 (i)9524 9524 

IDIV                7534 

IDIVI               9559 9588 

IDPB                2108 8321 9031 

IF                  (m)153 (m)451 (m)715 3408 4068 4860 4865 

IFDEBUG             (m)161 (m)358 1330 1394 

IFNOT               (m)153 (m)448 3423 3436 

IFSO                (m)153 (m)447 3427 3432 

Ignorable           (m)764 805 1187 

ILCA                517 530 537 2628 2649 (d)2653 2657 2657 

ILCB                524 2630 

ILDB                2118 8330 9040 

Immed               (v)9324 9328 9329 9332 9333 9334 9335 9336 
                    9337 9342 

IMPURE              (s)8216 8373 8465 8466 8490 8491 8503 8514 
                    8520 8660 8730 8974 8995 

impurearea          (s)8183 8350 8946 8957 

impurebase          (s)8189 8354 8623 8652 8757 8774 8831 

impureblock         (s)8184 8457 8466 8471 8489 8491 

impureblockx        (s)8152 8339 8457 8459 8459 8467 8469 8469 
                    8471 8488 8489 8490 8491 8492 

impurecount         (s)8243 8382 8455 8458 8462 8462 8470 8489 
                    8494 

impurecounter       (s)8211 8368 8454 8454 8993 8993 9160 

impurein            8730 (f)8939 

impureout           (r)8952 8974 

impurerel           (s)8153 8340 8457 8460 8470 8489 8493 

Impures             (g)648 3772 3795 3974 4696 4831 (r)6464 

impurex             (s)8185 8351 8940 8953 8957 8958 8958 

impurexx            (s)8186 8352 8940 8946 8947 8947 

IMUL                7522 

in                  (v)2325 2328 2332 2348 

Inc                 (v)4276 4277 

index               9061 9127 9139 9145 

INDEX               (m)150 (m)436 (m)712 2866 4007 4008 4334 
                    5165 5646 

indir               9060 9075 

InitNode            6751 6778 6838 6864 (r)6913 

Initstack           (g)223 7143 (r)7220 7708 7712 7718 7735 7766 
                    7845 7864 9307 

INPUT               796 1002 1144 1146 1147 1246 1252 1255 1265 
                    1269 1270 1275 1276 1276 1289 1631 1810 1820 
                    1920 2814 7227 7233 7235 7237 7239 7245 7247 
                    7340 7351 9474 

INT                 (m)732 4716 4719 7334 

intabov             (m)8174 8877 9019 

IntExt              (m)583 4743 

INTO                (m)155 (m)463 3060 3488 

inttab              (s)8204 8701 8754 8881 

inttabv             (s)8205 8756 8882 

inttabx             (s)8206 8365 8692 8694 8743 8744 8746 8875 
                    8880 8880 8881 8882 

IOR                 9423 

isdot               2073 2080 2087 (f)2120 

IsStructItem        3581 3602 (f)3660 

Iszero              (g)267 7593 7610 9256 (f)9506 

Item                (d)1169 1171 1172 1177 

ITEML               (m)731 4635 4856 7785 

ITEMN               (m)727 3956 4368 7787 

ITEMNL              (m)732 3952 4362 7789 

J                   (i)7020 7022 7024 

j                   (v)1455 1461 1465 (v)2832 2836 2843 2846 
                    2846 (i)8397 8398 (v)9154 9158 9159 9160 
                    (i)9273 9273 

JF                  (m)731 4977 7618 7699 

jf                  (v)1623 1624 1625 

JFCL                7178 

jfn                 (d)1291 1295 

JfnToString         1275 (f)1291 

jimbytptr           (g)6 1594 

jimtbl              (g)7 1593 

jimtbptr            (g)5 1593 

jj                  (v)8755 8756 8757 8757 8757 (v)8765 8773 
                    8774 8774 8774 (v)8792 8794 8794 8796 8796 
                    (v)8817 

JNDRD               (e)330 1144 2814 

JRch                (e)328 1246 1252 1255 

JRFPTR              (e)329 796 1002 1147 1289 

JRST                7695 7707 7764 7771 7785 9448 9451 9470 

JSETUP              (e)327 1276 

JSP                 7734 9223 

JSPAC               (m)284 7731 7734 9223 

JSYS                1196 1297 1356 1385 1473 1616 1639 1643 1779 
                    1884 1887 1921 1959 2329 2338 

JT                  (m)731 4277 4977 7618 7620 7698 7701 

JUMP                (m)731 6477 7694 

Jumpcond            (g)635 4072 4079 4130 4159 (r)4923 4930 4935 
                    4936 4940 4941 4945 4946 4950 4951 4958 4959 
                    4962 4968 4969 4972 5223 5701 5796 

JUMPE               7701 9310 

JUMPG               9315 

JUMPGE              9313 

JUMPL               9314 

JUMPLE              9312 

JUMPN               7701 9311 

k                   (i)847 847 (i)1284 1284 1284 (v)1456 1457 
                    1457 1457 1459 1460 (i)1694 1694 (i)2268 
                    2268 (i)2281 2282 (i)2476 2476 (i)2488 2489 
                    (v)2591 2591 2591 2594 (i)2610 2610 (i)2720 
                    2720 2720 (i)2722 2722 2722 (i)2874 2874 
                    2874 (i)2905 2905 2905 (i)2929 2929 2929 
                    (i)2957 2957 2957 (i)3009 3009 3009 (i)3031 
                    3031 3031 (i)3068 3068 3068 (i)3614 3614 
                    3614 (i)3794 3794 (v)3905 3906 3906 (v)3910 
                    3915 3915 3915 3916 (i)3973 3973 (i)4197 
                    4198 (v)4752 4753 4753 4754 4754 4756 4758 
                    (i)5042 5043 5043 5043 (i)6317 (i)6386 6387 
                    (i)6762 6762 6762 (i)6858 6858 6858 (i)6877 
                    6877 6877 (v)6906 6907 6909 6910 (i)7001 
                    7001 (i)7007 7007 (d)7975 7979 (v)8301 8306 
                    8313 8317 

K                   (d)6392 6396 6396 6400 6403 6403 6403 6406 
                    (i)7024 7025 

Kind                802 851 868 917 927 963 970 978 985 989 995 
                    1010 1019 (f)1180 

kk                  (v)8765 (v)8792 

L                   (l)801 808 1016 3021 (l)3133 3152 3157 3163 
                    3171 3178 3185 3192 3213 3236 3241 3246 3256 
                    3264 3269 3276 3281 (v)3451 3453 3473 (l)3514 
                    3519 3528 (v)3594 3596 3598 (v)3628 3630 
                    (v)3636 3638 (v)3777 3781 3785 3793 (d)3866 
                    3892 (v)3947 3952 3953 (v)3959 3960 3964 
                    3972 3977 (v)4071 4072 4074 (v)4078 4079 
                    4082 (v)4114 4123 4130 (v)4141 4148 4149 
                    4152 4159 (v)4172 4176 4180 (v)4189 4191 
                    4198 (v)4236 4258 4271 (v)4359 4362 4363 
                    (v)4456 4465 4466 4504 (v)4698 4708 4709 
                    4711 4720 4722 (v)4832 4836 (d)4923 4925 
                    4930 4936 4940 4941 4945 4946 4951 4959 4962 
                    4969 4972 4977 (v)5019 5023 5027 (v)5219 
                    5227 5233 (v)5485 5489 5512 (v)5698 5703 
                    5708 5709 (v)5931 5934 5934 5934 5936 5938 
                    5942 5946 5954 (v)6134 6135 6135 6135 6136 
                    6138 (d)6466 6467 (d)6468 6471 (d)6474 6475 
                    (d)6476 6477 (v)6623 (v)6771 6773 (v)6924 
                    6927 6928 6929 (l)7298 7624 7656 (l)7849 
                    7855 (d)8997 9005 9025 (v)9279 9281 

l                   (l)910 915 (l)1245 1249 1251 (l)1924 2015 
                    2017 2046 2053 2392 (l)2403 (l)2794 2804 
                    2811 (v)7336 7342 (v)7347 7353 (v)7379 7380 
                    (d)8300 8303 8304 8304 8305 8312 8314 8315 
                    8315 (d)8539 8541 8548 (d)8870 8882 8886 
                    (d)8892 8901 8911 (d)9048 9082 9082 9125 
                    9130 (d)9163 9165 9178 9179 (d)9292 9317 
                    (v)9443 9448 (v)9456 9458 9460 9461 (d)9463 
                    9476 

LAAAA0              (v)5950 5955 5974 5980 5986 6010 6039 

LAAAA1              (v)5950 5957 5988 

LAB                 (m)732 6467 7711 

LABEL               (m)275 (m)669 3742 4709 5154 5339 5652 5770 
                    7178 7413 7434 7476 7478 7480 7482 7484 7486 
                    7488 7490 7492 7695 7701 7771 7785 9103 9317 
                    9448 9451 9458 9470 9655 

labsearch           (f)8539 8882 8901 9025 9104 9158 9179 

labtab              (s)8231 8541 8548 

labtabmax           (m)8163 8231 8232 (m)8238 8543 

labtabv             (s)8232 8549 8616 8756 8773 8902 8906 9159 
                    9160 

labtabx             (s)8233 8378 8540 8543 8547 8547 8548 8549 
                    8550 

LastCharPtr         (s)2752 2757 2821 2824 

LastItem            (g)301 883 883 888 1171 1177 (s)1228 1479 
                    1649 

LastLine            (s)7291 7312 7316 

LastName            (s)2447 2473 2692 2697 

LastOffA            (s)7290 7320 7322 

LastOffset          (s)7289 7324 7328 

LC                  (m)734 5594 (v)5946 5953 5992 5997 6006 7415 

LE                  (m)145 (m)402 (m)706 3200 3219 4277 5435 
                    5908 6337 7588 7602 7606 7644 9301 9304 9312 
                    9336 

LEFTLUMP            (m)147 (m)415 (m)708 977 3158 5266 5484 5485 
                    5817 6236 

LEFTSIDE            (m)149 (m)431 (m)711 3044 3368 5572 6284 

Length              493 2667 (v)2710 2713 2722 

LET                 (m)150 (m)438 (m)713 2803 2810 2918 2921 
                    3336 3997 

lex2rw              1322 1333 1361 1390 1415 1427 1436 (f)1487 

LexOut              850 893 895 896 916 940 943 948 949 951 952 
                    953 954 955 957 958 959 962 963 965 966 967 
                    970 972 977 978 984 985 989 990 991 995 1006 
                    1009 1013 1018 1020 1022 1040 1046 1135 1142 
                    (r)1169 

LF                  (v)5950 5961 6022 6032 6043 6049 6059 6069 

LG                  (m)735 5650 7409 

LH                  (m)143 (m)372 (m)701 3086 3361 5186 5194 
                    5563 6128 6369 7444 7462 7480 7498 7665 7963 
                    8037 8108 

lhh                 (v)9636 9638 9643 

lhw                 (s)8168 8342 9073 9074 9075 9127 9145 9147 
                    9148 

lhwr                (s)8171 8345 

LHZ                 (m)159 (m)377 (m)738 3092 3349 5184 5200 
                    5557 6122 6375 7456 7474 7492 7510 7659 7965 
                    8043 8124 

Limit               (v)4248 4253 4275 

LINE                (m)156 (m)719 2887 2898 2917 2922 2940 3333 
                    3415 3487 3516 3526 3540 3554 3559 3563 3630 
                    3638 3641 4021 4023 4127 4128 4156 4157 4324 
                    4347 4402 4403 4432 4433 4567 4610 4611 4902 
                    5424 5426 6287 6736 6815 7309 

Line                (s)2211 2248 2249 2249 (d)2632 2644 2647 

LineD               2634 2644 2647 

LineP               (g)307 1260 1260 1261 1261 1262 1652 (s)2739 
                    2819 2832 2837 2845 

LinePtr             (g)317 (f)1476 2818 2862 2876 3292 3344 3522 
                    3534 3576 3628 3636 

LineT               (m)333 1261 2756 2761 2835 2841 

LineV               (g)306 1262 (s)2742 2759 2761 2762 2819 2836 
                    2836 2842 2843 2843 2846 

LIST                (m)148 (m)425 (m)710 3126 4542 4586 4814 
                    6278 

List1               (g)38 (f)2286 3045 3481 

List2               (g)39 (f)2291 2766 2767 2768 2769 2879 2975 
                    3000 3020 3028 3034 3037 3055 3065 3076 3084 
                    3102 3109 3113 3120 3124 3130 3139 3322 3406 
                    3446 3510 3518 3540 3558 3582 3586 3590 3654 
                    3746 3751 3873 3891 3931 3936 4878 4891 5980 
                    5998 6017 6049 6051 6063 6065 6069 6193 6193 
                    6195 6298 

List3               (g)40 (f)2296 2887 2897 2898 2916 2917 2921 
                    2922 2939 2940 2949 2980 2991 3006 3075 3141 
                    3151 3156 3162 3170 3177 3184 3191 3206 3207 
                    3235 3240 3245 3255 3268 3275 3280 3333 3338 
                    3386 3400 3415 3419 3487 3491 3516 3526 3527 
                    3540 3554 3559 3562 3563 3596 3598 3630 3630 
                    3638 3638 3641 3656 3657 5997 6017 6203 

List4               (g)41 (f)2301 2886 3263 3322 3330 3393 3441 
                    3503 3552 3621 

List5               (g)42 (f)2306 3308 3316 3504 3553 3607 

List6               (g)43 (f)2311 3473 

listingname         (s)1572 1585 1602 1817 2095 

ListLength          (g)632 3879 3919 4039 4050 4586 (f)4793 4795 
                    4795 4801 5677 5689 

litsearch           (f)8524 9142 

littab              (s)8228 8526 8535 8725 

littabmax           (m)8165 8228 8229 (m)8237 8252 8530 

littabv             (s)8229 8527 8536 8726 

littabx             (s)8230 8377 8525 8530 8534 8534 8535 8536 
                    8537 8652 8724 

ll                  2802 (l)2806 (d)8422 8423 

LL                  (m)729 (v)4117 4134 (v)4144 4164 (v)4231 
                    4285 5638 5653 7413 

LLG                 (m)736 5768 7428 7434 

LLL                 (m)729 5718 5765 5771 7429 7430 

LLP                 (m)725 4542 5759 7427 7433 

ln                  (v)4039 4041 (v)5677 5680 

LN                  (m)725 4269 4275 5254 5258 5295 5301 5354 
                    5358 5408 5501 5507 5522 5526 5540 5545 5590 
                    5630 5834 5838 5840 6639 6642 6643 7417 

lnm                 (v)1981 1982 2007 2053 2055 2056 2080 2080 
                    2081 2081 2082 2082 2083 2083 2084 2084 2085 
                    2085 2095 (d)7093 7155 7166 7167 

Load                (g)641 4052 4059 4106 4242 4255 4497 4534 
                    4976 5004 5029 5094 5095 5111 5205 5222 5242 
                    5243 5270 (r)5402 5427 5448 5449 5476 5477 
                    5487 5568 5691 5702 5707 5781 5786 5787 5823 
                    6641 

Loadlist            (g)636 4040 4051 (r)4987 4991 4992 5000 5093 
                    5679 5690 

LoadLV              (g)642 5206 5279 5583 (r)5729 5799 5806 5820 

LoadNeeded          (m)6531 6596 

LoadT               (g)231 7409 7411 7413 7417 7422 7424 7437 
                    7776 (r)7820 7848 9227 9459 

LOCAL               (m)274 (m)668 4259 4652 5108 5120 5123 5316 
                    5327 5619 5641 5748 5756 7223 7224 7411 7433 
                    7440 7442 7444 7446 7448 7450 7452 7454 7456 
                    7731 7732 7764 7834 7848 7860 7927 7933 7936 
                    7940 7947 7949 7954 7956 9090 9220 9225 9542 

locationcounter     (s)8210 8367 8433 8433 8646 8652 8992 8992 
                    9160 

LOGAND              (m)145 (m)397 (m)705 966 3207 3237 3240 4932 
                    5459 5913 6021 6356 7675 9422 

LOGOR               (m)145 (m)398 (m)705 967 3242 3245 4944 5460 
                    5914 6029 6357 7676 9423 

Lookat              (g)645 4028 4028 4037 4049 4049 4059 4106 
                    4242 4250 4442 4497 4861 4872 4885 4896 5029 
                    (r)5881 5929 5929 6133 6165 6168 6168 6171 
                    6175 6175 6203 6205 6212 6218 6220 6237 6250 
                    6276 6279 6288 6416 6424 6587 

LOOP                (m)156 (m)468 (m)719 3477 4092 

Looplabel           (g)607 (s)3710 4094 4094 4095 4117 4120 4122 
                    4125 4134 4144 4148 4154 4154 4164 4231 4234 
                    4267 4267 4285 

Lose1               (g)236 7523 7535 7555 7566 7608 (r)7830 9260 
                    9266 9346 9363 9371 9385 9393 9407 9415 9434 
                    9602 9627 

LP                  (m)725 (v)3522 3526 4268 4272 4274 5645 7411 

lr                  (d)8607 8628 8633 8638 8642 

LS                  (m)145 (m)401 (m)705 978 3198 3216 5433 5906 
                    6335 7578 7586 7596 7600 7638 9302 9303 9314 
                    9334 

LSCALE              (m)147 (m)411 (m)707 3229 5439 5911 5997 
                    6037 6352 7559 

LSH                 8111 8115 9384 9392 9563 9565 9592 9594 9616 
                    9618 9650 9652 

LSHIFT              (m)146 (m)409 (m)707 3228 5437 5909 6041 
                    6350 7672 

lslide              (e)1545 1960 

lst                 (v)2326 2330 2334 

LSTR                (m)732 5602 7420 7420 

LT                  (v)5950 5959 6024 6030 6053 6063 

LV                  (m)142 (m)368 (m)700 3098 3373 5583 6199 
                    6211 

LVbitn              (d)7958 7959 7966 7967 7968 7969 

LVopcode            (d)7958 7959 7961 7962 7963 7964 7965 7971 

LVRTAP              (m)729 5096 

LvTree              (d)2754 2795 2797 

LVX                 (d)4844 4845 4918 (d)5881 5882 5897 6295 
                    6299 (d)6413 6414 6416 6417 6424 6425 6431 

LX                  (m)726 5647 (v)5948 5954 5955 5957 5959 5961 
                    5992 6006 6039 7401 

LZTR                (m)739 5602 7419 

m                   (v)3912 3913 3914 (v)4554 4555 4556 4557 
                    (v)4594 4595 4596 4597 (v)4798 4799 4800 
                    4801 (v)4810 4811 4811 4812 (v)4997 4998 
                    4999 5000 (v)5051 5052 5056 5062 5062 5062 
                    (v)5383 5384 5384 5385 (v)6315 6316 6316 
                    6317 (v)7985 7986 7987 7991 7992 7996 (v)9469 
                    9470 9472 

M                   675 798 (l)803 (v)4078 4081 4084 (v)4187 
                    4200 4206 (v)4238 4264 4277 (v)4934 4935 
                    4937 (v)4949 4950 4952 (v)4957 4958 4961 
                    (v)4967 4968 4971 (v)5219 5223 5230 5248 
                    5287 5346 5493 5536 (v)5698 5701 5706 (v)5716 
                    5717 5718 5827 6230 6242 6256 6660 (v)9498 
                    9500 9501 9502 9504 9504 (v)9509 9511 9513 
                    9513 9516 

MACfil              92 7154 7168 7170 7173 7312 

MacroJFN            (g)218 7170 (s)8146 8337 8425 8666 8790 8982 

MacroName           (s)7080 7162 7167 7170 

MainSubN            (v)6567 6627 6627 6656 6656 6661 

MainSubSw           (v)6561 6634 6638 6644 6646 6660 

Makeaddrble         (g)265 7519 7530 7545 7563 7626 7687 9219 
                    9245 9255 9329 9369 9431 (r)9507 9525 9545 
                    9546 9575 9606 9613 9632 9646 

MakeEven            2492 2544 2575 2603 (r)2725 

MakeNUMSimple       (g)239 7682 7945 (r)8030 8067 9247 9248 9251 
                    9327 9353 9354 9358 9379 9401 9499 9608 9634 

MANIFEST            (m)150 (m)435 (m)712 2864 4011 

Max                 (v)5041 5043 5043 5045 5052 5062 5065 

MAXAC               (m)281 7732 7733 9225 

MaxN                (m)2207 2260 2260 

MaxNames            (m)6727 6747 6836 6907 

maxnumelts          (d)7273 7274 

MAXSSP              (d)9216 9225 

MaxStack            (g)195 (s)7075 7141 7142 7730 7732 7740 7742 

MAXXRNUMBER         (g)212 (s)7061 7147 7207 9079 9079 

messagename         (s)1577 1590 1607 1678 1680 1856 1876 

MINUS               (m)144 (m)393 (m)704 1009 3107 3173 3378 
                    5432 5901 5979 6332 7542 

MODIFY              (m)742 

MONITOR             (g)16 1671 1686 1748 1796 1854 1868 1868 
                    (s)2166 3828 7201 7254 7303 7362 

More                (v)6575 6577 6580 6582 6609 (v)6670 6672 
                    6673 6675 

MOVE                8015 8076 8084 8086 8092 8099 9548 9577 

MOVEI               7436 7732 8007 9225 9458 

MOVEM               7731 7954 7961 

MoveNtoReg          (g)241 7939 (r)7999 8070 9614 9643 9648 

MovetoReg           (g)235 7520 7533 7547 7564 7669 7688 7700 
                    7706 7762 7770 7953 7977 7984 7994 (f)8054 
                    8090 8098 9221 9239 9258 9264 9306 9326 9368 
                    9383 9389 9390 9405 9411 9412 9432 9440 9515 
                    9520 9558 9568 9587 9610 9620 9633 

MOVN                9562 9591 

MOVNI               8013 

MOVNS               7689 9259 9391 9413 

MOVSI               8002 

muldef              (m)8142 9161 

MULT                (m)145 (m)394 (m)704 991 3166 5455 5902 5985 
                    6339 6639 6642 7513 

N                   676 (d)2132 2134 (v)2258 2259 2260 2260 2260 
                    (v)2362 2364 2364 2366 2379 2383 2389 (s)2438 
                    2475 2476 2482 2487 2493 2548 2555 2559 2564 
                    2577 2581 2591 2597 2605 2616 2621 2622 2666 
                    2667 2669 2675 2678 2703 2706 2707 2707 2711 
                    2713 2713 2714 2722 2727 (v)3293 3298 3308 
                    3316 3322 3330 (d)3827 3829 3829 3830 3837 
                    3852 (v)4191 4192 4194 4197 (v)4328 4331 
                    4332 4335 4335 4337 4338 (v)4957 4960 4963 
                    (v)4967 4970 4973 (v)5041 5043 5044 5045 
                    5052 5058 5065 (v)5113 5134 5146 5149 5149 
                    5151 5151 5153 5153 5163 5177 5178 (v)5246 
                    5246 5254 5258 5258 (v)5284 5284 5291 5293 
                    5295 5300 5301 (v)5344 5344 5350 5352 5354 
                    5357 5358 (v)5491 5491 5501 5506 5507 (v)5534 
                    5534 5540 5544 5545 (v)5611 5630 5633 5633 
                    5635 5635 5638 5642 5645 5647 5650 5653 (v)5753 
                    5757 5759 5762 5762 5763 5763 5765 5768 5771 
                    (v)5826 5826 5832 5832 5834 5834 5838 5838 
                    6233 (v)6258 6258 6260 6260 6262 6262 6265 
                    6266 (d)6303 6326 (v)6394 6394 6396 (d)6468 
                    6470 (v)6582 6583 6583 6586 6587 6588 6600 
                    6600 6602 6661 (v)6675 6676 6677 6677 (v)6760 
                    6761 6762 (v)6855 6856 6858 (v)6965 6968 
                    7001 7007 (v)7019 7020 7024 (d)7999 8000 
                    8001 8002 8002 8003 8004 8006 8007 8009 8010 
                    8012 8012 8013 8015 (d)8019 8020 8021 8022 
                    8022 8023 8024 8026 

n                   95 (v)846 847 847 848 (v)908 912 912 916 
                    (d)1484 1486 (d)2204 (d)2214 2216 2216 2216 
                    2218 2234 2236 2236 2240 2251 2254 2282 (d)2321 
                    2323 2325 2459 (v)2548 2550 2550 2553 (v)2559 
                    2559 2559 2566 (i)2584 2586 2588 2594 2610 
                    (v)2688 2688 2691 2695 2695 (i)2761 2761 
                    (d)2816 2817 2817 2817 2849 2849 (d)3016 
                    3153 3159 3166 3173 3180 3187 3201 3231 3237 
                    3242 3251 3257 3265 3271 3277 (v)3879 3880 
                    3881 3882 3883 (i)3914 (v)3919 3920 3921 
                    3922 3923 (i)3942 3942 3948 3949 3953 3956 
                    (i)3958 3959 3962 (v)4444 4447 4448 (v)4666 
                    4668 4670 (v)4714 4715 4716 4718 4719 4720 
                    (v)4870 4872 4873 4873 4874 4877 (v)4883 
                    4885 4886 4886 4887 4890 (i)5048 5051 5052 
                    5058 5062 (v)5992 5994 5998 (v)6013 6015 
                    6017 (s)6305 6310 6319 6323 6323 6326 (d)6410 
                    6410 (v)6780 6783 6786 6787 (v)6865 6868 
                    6873 6874 (v)6883 6885 6886 (v)7232 7234 
                    7236 7236 7238 7238 7240 7240 7241 (v)7244 
                    7246 7248 7248 7249 (d)7251 7255 7259 7260 
                    (v)7335 7339 7340 (v)7346 7350 7351 (v)7357 
                    7359 (v)7378 7380 (v)7721 7724 (v)7729 7735 
                    (v)7795 7796 (d)7841 7843 7845 7848 7850 
                    7857 7859 7864 (d)7975 7979 (v)7989 7990 
                    7990 7990 7991 (v)8096 8099 8317 8395 (d)8985 
                    8988 8992 8993 8995 (d)9153 9156 9158 (d)9455 
                    9460 9461 (d)9463 9465 9467 9474 9475 

na                  (v)7750 

Name                515 (v)875 877 879 (d)1264 1269 1275 1278 
                    1279 1284 (d)1308 1311 (d)1477 1478 1480 
                    (d)2500 2546 2546 2563 (d)2683 2685 2688 
                    (v)3577 3590 3607 3621 (d)3806 3808 (d)4779 
                    4782 (v)5310 5312 5315 5320 5323 5328 5337 
                    (v)6915 6916 6916 (v)7022 7023 7025 7026 

NAME                (m)141 (m)361 (m)698 896 2769 2784 2878 2879 
                    2970 2975 2995 3000 3018 3137 3139 3298 3301 
                    3355 3390 3445 3446 3589 3590 3653 3654 4651 
                    5101 5309 5469 5608 5739 5785 6141 6687 

NameB               502 2620 

NameChain           (s)2445 2469 2473 2608 

NAMELENGTH          (m)71 873 873 875 3767 6469 

NameN               501 2621 

NC                  2455 2608 2610 2614 2686 2686 2692 2693 2694 
                    2695 2696 

Ncs                 87 3044 5082 

NE                  (m)145 (m)400 (m)705 3197 3215 5458 5904 
                    6334 7585 7619 7635 9299 9300 9311 9333 

NEG                 (m)142 (m)700 3109 5552 5980 6119 6367 7680 
                    7681 7684 7689 

NegFlg              (v)8020 8022 8024 8026 

NEQUIV              (m)146 (m)408 (m)707 3250 5464 5918 6361 
                    7545 

NEQV                (m)146 (m)406 (m)706 3248 4955 5462 5916 
                    6058 6359 7678 9425 

NewC                (v)6426 6429 6429 

NewMax              (v)5047 5062 5062 5065 

NewN                (v)5047 5062 5062 5065 

newocp              (v)4505 4508 

NewOffset           (v)6825 6829 

Newvec              (g)31 1281 1486 1697 1725 (f)2132 2287 2292 
                    2297 2302 2307 2312 3030 3881 3921 6761 6777 
                    6856 6877 

Next                (l)799 947 1004 1149 1154 (l)7295 7308 7317 
                    7324 7330 7333 7343 7354 7369 7374 7381 7385 
                    7388 7392 7394 7397 7400 7408 7410 7412 7414 
                    7418 7421 7423 7425 7438 7441 7443 7445 7447 
                    7449 7451 7453 7455 7457 7459 7461 7463 7465 
                    7467 7469 7471 7473 7475 7477 7479 7481 7483 
                    7485 7487 7489 7491 7493 7495 7497 7499 7501 
                    7503 7505 7507 7509 7511 7524 7536 7540 7543 
                    7558 7561 7567 7621 7671 7674 7679 7685 7691 
                    7693 7697 7704 7710 7714 7716 7719 7726 7736 
                    7741 7743 7746 7760 7768 7774 7777 7780 7782 
                    7784 7786 7788 7790 7792 7797 

Nextfn              (d)3342 3392 3392 3501 3501 3509 3509 

NextName            (s)2449 2470 2616 2690 2691 2691 

NextP10reg          (g)232 7431 7548 7628 (f)7876 7938 8061 9339 
                    9457 9642 9647 

NextParam           (g)35 (f)2184 3948 4071 4078 4078 4089 4094 
                    4114 4120 4141 4172 4187 4215 4236 4238 4360 
                    4465 4626 4708 4743 4852 4934 4949 4957 4957 
                    4967 4967 5019 5020 5219 5219 5661 5699 5699 
                    5716 5795 5795 7105 9456 9469 

NextParameter       (g)24 1600 (s)2174 2185 2185 2186 

Nextsymb            (g)316 (r)789 885 889 2774 2789 2799 2870 
                    2875 2881 2884 2893 2901 2906 2912 2918 2925 
                    2930 2935 2943 2947 2958 2962 2965 2972 2976 
                    2978 2987 2989 2997 3001 3004 3020 3027 3032 
                    3035 3038 3040 3041 3042 3046 3048 3051 3053 
                    3058 3061 3064 3069 3072 3074 3100 3104 3107 
                    3111 3115 3118 3122 3128 3140 3142 3150 3154 
                    3168 3175 3182 3189 3204 3233 3238 3243 3253 
                    3258 3261 3266 3273 3278 3297 3304 3306 3314 
                    3328 3335 3336 3384 3391 3404 3412 3417 3421 
                    3425 3428 3434 3438 3444 3448 3450 3456 3459 
                    3464 3467 3471 3482 3486 3489 3493 3497 3500 
                    3506 3508 3517 3524 3536 3538 3544 3546 3549 
                    3560 3580 3585 3591 3593 3596 3604 3610 3615 
                    3618 3627 3635 3652 3655 3656 

NIL                 (m)142 (m)367 (m)699 2768 2984 3040 3301 
                    4657 5406 5579 5897 

NILNODE             (g)117 (s)2744 2768 2986 3040 

nl                  (d)2321 2322 2340 2340 2341 

NLPending           (g)298 888 1003 1148 1173 1175 1178 (s)1229 
                    1654 

nm                  (v)1985 1990 1990 1991 1991 1995 1996 2007 
                    2011 

nnn                 (v)1341 1346 1348 1351 1352 (v)1370 1375 
                    1377 1380 1381 

Nocg                1538 1808 2041 

Node                (d)2225 2226 (v)4848 4866 4878 4890 4893 
                    4900 4917 4917 4918 (v)5887 5974 5976 5980 
                    5982 5988 5990 5996 6008 6017 6024 6026 6032 
                    6034 6045 6049 6051 6053 6055 6059 6061 6063 
                    6065 6069 6169 6171 6190 6193 6195 6203 6212 
                    6212 6218 6218 6293 6294 6294 6295 6298 6299 
                    6299 

NOT                 (m)142 (m)370 (m)700 990 3122 3124 3369 4930 
                    5554 6049 6051 6063 6065 6120 6368 7682 

NoteGlobal          (g)243 7380 (r)8997 

Num                 (v)1507 1508 1510 1510 1510 1510 1511 

NumbArgs            2322 7083 9460 9466 

NUMBARGS            (m)149 (m)430 (m)711 3043 3367 4050 5571 
                    5689 6283 7416 

NUMBER              (m)141 (m)276 (m)360 (m)698 850 916 2782 
                    3028 3037 3037 3065 3322 3356 3751 3936 4012 
                    4341 5469 5590 5629 5893 5998 6017 6143 6156 
                    6193 6298 7417 7422 7424 7683 7778 7944 7996 
                    8002 8004 8007 8010 8013 8015 8024 8026 8031 
                    8066 8076 8092 8099 8111 8112 8115 8116 8120 
                    8128 8132 8133 9094 9222 9224 9249 9328 9343 
                    9355 9362 9380 9384 9402 9406 9445 9446 9501 
                    9502 9506 9527 9532 9547 9550 9559 9561 9563 
                    9564 9565 9576 9579 9588 9590 9592 9593 9594 
                    9599 9600 9609 9610 9616 9617 9618 9624 9625 
                    9635 9638 9650 9651 9652 9654 

Numinp              843 (f)1190 

NXOR                9424 

o                   (v)7977 7978 7979 (d)9042 9043 (d)9048 9071 
                    9073 (d)9192 9192 

Ocode               (g)25 84 1769 1770 1778 1784 1811 2031 2141 
                    2141 2143 2143 (s)2175 6505 6509 6510 6511 
                    6512 6516 6517 6520 6520 

ocodename           (s)1575 1588 1605 1766 1770 1811 

OcodeOp             (v)5322 5331 5334 5340 5361 

ocp                 (v)4489 4506 

off                 8159 8224 8613 

Off                 (m)277 7320 7321 7322 7326 7332 7332 9150 
                    9150 9151 9151 9189 9189 9190 9190 

Offset              539 (d)2568 2571 (d)2624 2627 (d)2653 2656 
                    2656 (v)3808 3809 3809 3810 (v)3815 3816 
                    3816 (s)6719 6744 6757 6771 6773 6823 6825 
                    6827 6829 6839 6844 6849 6849 6853 6871 6871 
                    6885 6886 6886 6917 

OFFSET              (m)143 (m)384 (m)702 3082 5530 6227 

OldDE               (v)2612 2614 

oldfnm              (v)4454 4515 

OldLI               (v)883 888 

oldmax              (v)4455 4514 

OldN                (v)2711 2718 2720 2722 

OldOffset           (v)6823 6827 (v)6839 6849 6853 

OldSDvec            (v)6839 6854 

OldSSP              (v)6574 6663 

OldVecSSP           (v)4413 4415 

oldwr               (v)7095 7218 

OP                  (d)9373 9381 9391 (d)9395 9403 9413 (d)9417 
                    9420 

Op                  (g)214 (v)2861 2869 2897 (v)3017 3083 3084 
                    3099 3102 3127 3130 3160 3162 3167 3170 3174 
                    3177 3181 3184 3188 3191 3203 3206 3232 3235 
                    3252 3255 3272 3275 (v)3291 (v)3343 3403 
                    3406 3411 3414 3414 3419 3485 3491 3523 3527 
                    (v)4070 4072 (v)4847 4850 4865 4877 4890 
                    (v)5166 5174 5175 5178 (v)5418 5419 5450 
                    5478 5479 5485 5569 5575 5602 (v)5888 5889 
                    5938 5938 5939 5939 5939 5940 5940 5940 5942 
                    5972 6138 (d)6329 6330 (d)6365 6366 (d)6493 
                    6494 (s)7060 7297 7300 7304 7383 7386 7420 
                    7430 7433 7433 7434 7435 7522 7534 7535 7550 
                    7560 7578 7580 7582 7592 7617 7618 7618 7620 
                    7670 7673 7678 7680 7684 7689 7701 7740 7796 
                    (d)9216 9227 9245 9265 9352 9370 9598 9623 
                    9637 9654 9655 

OPC                 (v)7628 7633 7636 7639 7642 7645 7648 7650 
                    (v)7985 7995 7996 (v)9295 9308 9317 (v)9323 
                    9330 9343 9344 (v)9420 9433 

opcode              9058 9073 

OPCODE              9071 (f)9192 

OpDPB               7971 9569 9638 9657 

OpenSource          (g)319 (r)1264 1480 2773 

OpJSYS              7778 

OpLDB               9597 9610 9621 

OR                  (m)153 (m)450 3436 9600 9625 9654 

ORI                 9564 9593 9617 9651 

Out1                (g)653 3759 4038 4060 4099 4103 4257 4269 
                    4277 4420 4495 4497 4509 5207 5251 5258 5301 
                    5358 5450 5478 5478 5479 5497 5507 5512 5545 
                    5569 5575 5678 5788 5830 5834 5838 5840 5842 
                    (r)6478 6639 6642 6643 6644 

Out1C               (g)657 5261 5304 5361 (r)6493 

Out2                (g)654 3755 3782 3809 3816 3956 3965 4023 
                    4048 4050 4053 4065 4128 4132 4157 4162 4268 
                    4269 4269 4272 4274 4275 4282 4368 4403 4419 
                    4427 4433 4487 4503 4542 4584 4611 5092 5096 
                    5126 5138 5178 5254 5258 5295 5301 5354 5358 
                    5407 5408 5426 5501 5507 5522 5526 5540 5545 
                    5581 5590 5594 5602 5630 5645 5647 5650 5666 
                    5688 5689 5692 5710 5759 5768 5811 5834 5838 
                    5840 (r)6480 6639 6642 6643 

Out2P               (g)655 3952 4109 4277 4362 4635 4856 4977 
                    5155 5638 5653 5703 5708 5718 5765 5771 5801 
                    5808 6467 6475 6477 (r)6484 

Out3P               (g)656 3769 3793 3972 4041 4537 4711 5039 
                    5680 6471 (r)6488 

OutA                (g)187 (s)7066 7106 7113 7113 7113 7113 7113 
                    7113 7113 7320 7321 7322 7326 7332 9150 9150 
                    9189 9189 

OutB                (g)188 (s)7067 7115 7122 7122 7122 7122 7122 
                    7122 7122 7332 9151 9151 9190 9190 

OutC                (g)660 3770 3794 3973 5517 5603 6472 (r)6500 

Outconsts           (g)250 7184 7696 7709 7767 7773 (r)9268 9471 

OutFunction         (v)5322 5331 5334 5361 

OutL                (g)659 4490 4507 5045 5322 (r)6498 

OutN                (g)658 5045 5331 5334 (r)6496 

Outnumbs            (g)251 7185 (r)9286 

OUTPUT              1664 1686 1736 1744 1748 1790 1795 1796 1842 
                    1843 1844 1870 2201 2202 2367 2367 2676 2677 
                    2679 2680 3828 3828 3861 7085 7201 7210 7253 
                    7254 7265 7302 7303 7305 7306 7361 7362 7366 
                    8418 8425 8666 8671 8681 8962 8965 8968 8977 
                    8982 8998 9001 9014 9020 9027 

OutputTable         3786 (r)3940 3978 

outrel              8561 (r)8564 

outtmp              (r)8430 9148 9175 9181 9186 

OVERLAY             (m)157 (m)475 (m)720 3605 3633 3638 6769 
                    6822 

P                   (v)2627 2628 2630 2630 (d)3575 3626 3634 
                    (v)5013 5035 5041 5041 5042 5048 5072 (d)7866 
                    7872 8221 8612 8613 9057 9073 9074 9075 9127 
                    9139 9145 

p                   (d)2142 2143 2143 (v)2390 2392 2394 (d)7975 
                    7978 (d)7982 7995 

P10reg              (m)280 7437 7516 7517 7523 7535 7553 7555 
                    7566 7653 7776 7889 7905 8056 8064 8071 8078 
                    8135 9095 9227 9266 9346 9371 9385 9391 9393 
                    9407 9413 9415 9429 9429 9434 9459 9503 9512 
                    9531 9562 9566 9569 9591 9595 9597 9602 9619 
                    9621 9627 9657 

P10regV             (g)211 (s)7062 7137 7138 7150 7150 7151 7151 
                    7878 7878 7886 7886 7889 7904 7904 7907 7907 
                    7916 7916 7917 7917 

P2                  8156 9105 9113 9144 9180 9185 

p2w                 (s)8195 8358 8520 8557 8558 8725 

p2wr                (s)8196 8359 8519 8559 8560 8726 

Packstring          877 936 1036 1193 1351 1380 1500 1512 1678 
                    1730 1766 1816 1838 1955 2094 2095 2096 7162 
                    7195 7198 7341 7352 9480 9483 

PageSize            (m)2673 2675 

PairP10reg          (g)237 7531 (f)7913 7922 9544 9574 9607 

Part                (d)7958 7960 

PBIN                1897 7724 

PBOUT               1702 1715 1734 1791 1853 2216 2216 2217 2269 
                    2282 2378 2380 2384 2405 2496 2678 2776 2781 
                    2783 2784 2784 2788 2830 2842 2847 3749 3857 
                    3859 

PDRMAXSSP           (g)593 (s)3690 3724 3754 3754 4047 4047 4055 
                    4055 4281 4281 4316 4316 4410 4410 4418 4418 
                    4424 4424 4455 4477 4500 4500 4507 4514 4539 
                    4539 4544 4544 4583 4583 4655 4655 4659 4659 
                    4671 4671 5091 5091 5098 5098 5229 5229 5235 
                    5235 5405 5405 5415 5415 5422 5422 5524 5524 
                    5528 5528 5549 5549 5577 5577 5580 5580 5592 
                    5592 5596 5596 5605 5605 5614 5614 5668 5668 
                    5682 5682 5687 5687 5694 5694 5705 5705 5712 
                    5712 5720 5720 5733 5733 5743 5743 5804 5804 
                    5814 5814 6664 6664 

Plist               (g)37 1742 1794 (r)2204 2251 2282 3859 

PLUS                (m)144 (m)392 (m)704 959 3104 3172 3377 4269 
                    5251 5258 5301 5358 5456 5478 5497 5507 5545 
                    5788 5830 5834 5838 5842 5900 5973 6203 6331 
                    6643 6644 7539 7930 7986 8036 8086 8103 9235 
                    9250 9356 9363 

point               9065 9138 

POINT               1594 

Pop                 (g)226 (f)7277 7742 

Pprep               89 1718 2035 2775 

progstart           (s)8150 8336 8786 8833 9026 

Ptr                 (d)2361 

PURE                (s)8215 8372 8426 8444 8445 8480 8481 8503 
                    8514 8520 8659 8661 8995 

purearea            (s)8179 8347 8924 8935 

pureblock           (s)8180 8436 8445 8449 8479 8481 

pureblockx          (s)8149 8334 8436 8437 8437 8442 8446 8448 
                    8448 8449 8463 8478 8479 8480 8481 8482 

purecount           (s)8242 8381 8434 8439 8441 8441 8450 8479 
                    8484 

purein              8661 (f)8917 

pureout             8426 (r)8930 

purerel             (s)8151 8338 8436 8438 8450 8479 8483 

Pures               (g)647 3792 3804 3971 4834 (r)6462 

purex               (s)8181 8348 8918 8931 8935 8936 8936 

purexx              (s)8182 8349 8918 8924 8925 8925 

Push                (g)224 (f)7267 7730 

Q                   9063 9137 9138 

q                   (v)9438 9441 (v)9536 9546 9555 9560 (v)9573 
                    9575 9584 9589 

Q1                  (m)143 (m)373 (m)701 3088 3363 5188 5195 
                    5564 6129 6371 7446 7464 7482 7500 7666 7966 
                    8039 8110 

Q1Z                 (m)159 (m)379 (m)738 3094 3351 5558 6123 
                    6377 7660 8045 8127 

Q2                  (m)143 (m)374 (m)701 3089 3364 5189 5196 
                    5565 6130 6372 7448 7466 7484 7502 7667 7967 
                    8040 8118 8119 

Q2Z                 (m)160 (m)380 (m)738 3095 3352 5559 6124 
                    6378 7661 8046 8130 8131 

Q3                  (m)143 (m)375 (m)701 3090 3365 5190 5197 
                    5566 6131 6373 7450 7468 7486 7504 7668 7968 
                    8041 8114 

Q3Z                 (m)160 (m)381 (m)739 3096 3353 5560 6125 
                    6379 7662 8047 8126 8127 

Q4                  (m)143 (m)376 (m)701 3091 3366 5191 5198 
                    5567 6132 6374 7452 7470 7488 7506 7669 7969 
                    8042 8119 

Q4Z                 (m)160 (m)382 (m)739 3097 3354 5561 6126 
                    6380 7663 8048 8131 

QN                  672 5246 5248 5261 5284 5284 5287 5344 5344 
                    5346 5491 5493 5510 5517 5534 5536 5826 5827 
                    6230 6233 6242 6256 6258 6260 6394 6394 6394 
                    6658 6659 6660 6661 

QQ                  (v)1505 1506 1507 1509 1510 1510 1510 1510 
                    1510 1512 

R                   (v)5931 5935 5935 5935 5936 5938 5942 5946 
                    5965 (v)6927 6928 6928 6929 (v)6964 6987 
                    6989 7000 7006 (d)7866 7871 (d)7999 8000 
                    8001 8002 8004 8007 8010 8013 8015 (d)8019 
                    8024 8026 

r                   (v)6885 6886 6886 (i)6989 (i)7006 (v)7515 
                    7520 7522 7523 (v)7529 7531 7533 7534 7535 
                    7535 (v)7564 7565 7566 (v)7628 7629 7651 
                    7653 (v)7749 (v)7906 7907 7907 (v)7926 (v)7938 
                    7939 7940 7953 7954 (v)7977 7979 8252 (v)8301 
                    8310 8311 8314 8317 8318 (d)8430 8450 8470 
                    (d)8524 8527 8527 8536 8536 (d)8564 8593 
                    8726 (v)9244 9264 9265 9266 (v)9295 9306 
                    9317 (v)9323 9326 9343 9344 (v)9350 9368 
                    9370 9371 (v)9375 9383 9384 9385 9390 9392 
                    9393 (v)9397 9405 9406 9407 9412 9414 9415 
                    (v)9419 9432 9433 9434 (v)9440 9445 9446 
                    (v)9457 9458 9459 

r1                  (v)7546 7547 7552 

r2                  (v)7546 7548 7550 7553 7555 

RAAAA0              (v)5950 5966 5976 5982 5986 6003 6045 

RAAAA1              (v)5950 5968 5990 6008 

radix50             8318 (f)8388 8714 8830 8836 8874 8893 

RB                  (v)4118 4135 (v)4145 4165 (v)4232 4286 (v)4459 
                    4511 

rbits               8251 8527 8536 8726 

Rblock              (g)120 (f)2954 3490 3512 

RBody               (v)4463 4464 4504 4513 

RBRA                (m)148 (m)422 957 3048 3142 3295 3375 

RC                  (v)5946 5964 6006 6012 

Rch                 (g)318 800 806 827 839 868 909 912 926 945 
                    960 968 975 982 988 993 997 1007 1015 1030 
                    1053 1060 1096 1098 (r)1242 1325 1397 1490 
                    1496 

Rcom                (g)127 2945 3054 3054 3307 3307 (f)3342 3418 
                    3418 3426 3426 3429 3429 3435 3435 3439 3439 
                    3472 3472 

Rdef                (g)126 2919 (f)3290 3337 

ReadAhead           (g)299 791 792 831 1174 (s)1224 1648 

Readblockbody       (g)119 2795 (f)2860 2896 2915 2920 2938 2944 
                    2945 2948 2959 

Readch              7227 7233 7235 7237 7239 7245 7247 7340 7351 
                    9474 

ReadL               (g)222 (f)7243 7336 7347 7379 7413 7430 7435 
                    7476 7478 7480 7482 7484 7486 7488 7490 7492 
                    7620 7695 7702 7713 7722 7730 7750 7771 7783 
                    7785 7789 7796 9439 9443 9655 

ReadMore            3582 3587 3608 (l)3623 3631 3639 

ReadNM              (g)221 (f)7231 7310 7332 7335 7346 7378 7406 
                    7409 7411 7417 7420 7430 7440 7442 7444 7446 
                    7448 7450 7452 7454 7456 7458 7460 7462 7464 
                    7466 7468 7470 7472 7474 7715 7721 7729 7740 
                    7749 7775 7787 7791 7795 9438 9442 9638 9654 
                    9656 

Readop              (g)220 (f)7226 7297 7357 7391 7396 7399 7617 
                    9537 

readtmp             (r)8499 8719 8734 

Real                (v)2127 2130 

RealTime            (s)1565 1885 2127 2130 

Reg                 (d)8054 8058 8058 8061 8061 8064 8064 8070 
                    8071 8072 8076 8078 8079 8084 8086 8087 8090 
                    8092 8092 8098 8099 8099 8106 8108 8110 8111 
                    8112 8114 8115 8116 8119 8120 8122 8124 8127 
                    8128 8131 8132 8133 8135 8136 

relbits             (s)8200 8362 8514 8519 

relbuf              (s)8246 8567 8568 8573 8582 8594 8600 8602 

relc                (s)8247 8576 8592 8592 8601 

relcounter          (s)8197 8360 8507 8507 8573 8595 8595 8634 
                    8635 8643 8644 8715 8866 

reljfn              (s)8194 8357 8566 8568 8601 8602 8689 8693 
                    8697 8701 8706 8710 8712 8713 8714 8744 8749 
                    8754 8757 8762 8768 8772 8774 8796 8802 8806 
                    8807 8813 8820 8824 8825 8828 8829 8830 8831 
                    8834 8835 8836 8837 8841 8842 8843 8844 8845 
                    8848 8849 8850 8851 8852 8856 8857 8858 8860 
                    8861 8864 8865 8866 8867 

relname             (s)1573 1586 1603 1817 2096 

Relop               (v)7592 7595 7597 7600 7603 7606 7613 7615 
                    7619 7619 7620 7624 7631 (d)9292 9297 9297 
                    9308 (d)9319 9330 

relr                (s)8245 8384 8567 8574 8582 8583 8593 8600 

rels                7579 7581 7583 (l)7590 

relx                (s)8241 8380 8565 8569 8571 8577 8582 8585 
                    8585 8589 8589 8594 8599 8600 8602 8603 8717 
                    8732 

relxr               (s)8244 8383 8575 8580 8584 8588 8588 8593 
                    8600 

REM                 (m)145 (m)396 (m)704 3165 5446 5920 6341 
                    7528 7535 

Rep                 (v)3577 3596 3598 3607 3621 

REP                 (m)158 (m)722 3596 3598 

REPEAT              (m)154 (m)455 (m)716 3517 3518 4138 4148 
                    4151 4878 4891 4910 

RepeatBlock         (g)602 (s)3704 3735 4088 4093 4118 4119 4135 
                    4145 4146 4165 4232 4235 4286 4459 4460 4511 

REPEATUNTIL         (m)154 (m)456 (m)717 3521 4140 4882 

REPEATWHILE         (m)154 (m)457 (m)717 3520 4139 4159 4881 
                    4890 

REPNAME             (m)149 (m)428 (m)711 2988 2991 3270 3908 
                    4553 4593 4665 4796 4810 4995 5383 6274 6313 

Report              (g)184 (s)7065 7152 7216 7301 7407 7823 7894 
                    8074 8531 8544 8620 8877 8895 8903 8932 8954 
                    9013 9019 9090 9115 9161 9168 9529 

Reportcount         (g)15 1597 1753 1799 1822 (s)2165 2374 2375 
                    3838 3838 

RepSW               (v)6842 6844 6849 6851 

RepSw               (v)6605 6609 6616 (v)6966 6982 

REPVAL              (m)149 (m)429 (m)711 2988 3271 3909 4550 
                    4796 5381 6275 

REQUEST             (m)161 (m)356 1365 

RequestSize         (m)77 1238 

RequestTable        (g)9 (s)1238 1371 1371 1376 1376 1388 1388 
                    1609 8847 8850 8851 

REQUIRE             (m)161 (m)357 1336 

RequireSize         (m)76 1237 

RequireTable        (g)10 (s)1237 1342 1342 1347 1347 1359 1359 
                    1608 8840 8843 8844 

RES                 (m)731 4109 5703 5708 5801 5808 7769 

RESERVE             (m)141 (m)353 1407 

ResLabel            (v)5794 5801 5808 5810 

restart             (l)1581 1757 1803 1826 1863 

RestoreDict         1645 

restups             (d)1453 1458 1467 1467 1468 1468 

RESULTIS            (m)149 (m)427 (m)710 3403 3558 4105 

Resultlabel         (g)604 (s)3706 4107 4109 5659 5661 5665 5670 

RETURN              (m)156 (m)469 (m)719 3481 4097 

Rexp                (g)124 2885 2990 (f)3016 3049 3059 3101 3105 
                    3108 3112 3116 3119 3123 3129 3147 3155 3169 
                    3176 3183 3190 3205 3234 3239 3244 3254 3259 
                    3262 3267 3274 3279 3315 3329 3382 3385 3405 
                    3413 3422 3453 3457 3460 3465 3467 3487 3494 
                    3497 3525 3545 3546 3557 3594 3596 3606 3656 

Rextlist            2931 (f)2969 2979 

RF                  (v)5950 5970 6022 6034 6051 6061 

RFNAP               (m)737 5680 7748 

rfptr               2141 

RH                  (m)142 (m)371 (m)700 3087 3362 5187 5193 
                    5562 6127 6370 7442 7460 7478 7496 7664 7962 
                    8038 8106 

rhw                 (s)8169 8343 9096 9104 9105 9112 9113 9118 
                    9137 9138 9139 9142 9142 9144 9147 

rhwr                (s)8170 8344 9095 9103 9111 9117 9142 9143 
                    9148 

RHZ                 (m)159 (m)378 (m)738 3093 3350 5185 5199 
                    5556 6069 6121 6376 7454 7472 7490 7508 7658 
                    7964 8044 8122 

RIGHTLUMP           (m)147 (m)414 (m)708 984 3159 5238 5483 5822 
                    6248 

RKET                (m)148 (m)423 958 3050 3143 3148 3303 

RL                  (v)5659 5670 

RLINIT              (e)175 7173 (r)8422 

RNAME               (m)159 (m)737 3018 3347 4035 4038 5675 5678 
                    7744 

RNAMECODE           (m)351 893 

Rnamelist           (g)121 (f)2982 3005 3293 3301 

rnm                 (v)1983 1984 1985 2053 2054 2059 2060 2061 
                    2064 2067 2069 2069 2070 2070 2087 2088 2088 
                    2089 2089 2090 2090 2091 2091 2092 2092 2096 
                    (d)7093 7188 7195 7199 (d)8649 8689 

rootname            (s)1571 1584 1601 1672 1673 1674 1675 1676 
                    1677 1678 1679 1726 1727 1728 1729 1730 1731 
                    1762 1763 1764 1765 1766 1767 1816 1817 1834 
                    1835 1836 1837 1838 1839 2099 2101 2101 2102 
                    2102 (d)7093 7156 7157 7158 7159 7160 7161 
                    7162 7163 7189 7190 7191 7192 7193 7194 7195 
                    7196 7198 

RoutineBody         (g)598 (s)3700 3731 4098 4463 4468 4469 4491 
                    4513 4704 4711 5572 

rp                  (v)9544 9549 9555 9558 9559 9560 9561 9562 
                    9562 9563 9564 9565 9566 9566 9568 9569 9569 
                    (v)9574 9578 9584 9587 9588 9589 9590 9591 
                    9591 9592 9593 9594 9595 9595 9597 9597 9599 
                    9600 9602 (v)9607 9610 9610 9614 9615 9616 
                    9617 9618 9619 9619 9620 9621 9621 9624 9625 
                    9627 (v)9631 9642 9643 9647 9648 9649 9650 
                    9651 9652 9654 9655 9656 9657 

Rqualname           (g)131 3084 3161 (f)3650 3657 

Rr                  (v)7985 7994 7996 (v)9323 9339 9341 9345 
                    9346 

RRTAP               (m)738 4041 7747 

RSCALE              (m)147 (m)412 (m)708 3231 5440 5912 6017 
                    6038 6354 7560 9403 9413 

RSclck              1705 (r)1882 2128 

Rselect             (g)128 3070 (f)3532 3539 3550 3561 

RSHIFT              (m)146 (m)410 (m)707 3230 5438 5910 6042 
                    6351 7673 9381 9391 

RsltAC              (m)283 7762 7770 7776 9227 

RSTACK              (m)726 5666 5710 5811 7775 

Rstruct             (g)130 2907 (f)3575 3616 3629 3637 

RT                  (v)5950 5969 6026 6030 6055 6065 

RTAP                (m)152 (m)714 3398 4034 4053 7740 

RTDEF               (m)151 (m)714 3308 4453 4468 4624 4630 

RTRN                (m)723 4099 4495 7764 

Run                 (v)2127 2129 

RunTime             (s)1566 1888 2127 2129 

ruppersptr          (g)32 (f)2141 4489 4505 

RV                  (m)142 (m)369 (m)700 3099 3374 5204 5277 
                    5478 5555 5780 6193 6195 6208 7692 8033 8034 
                    8074 8089 9232 9240 9502 9504 9513 9528 9531 

RVC                 (m)733 5514 7395 

RVCB                (m)725 5516 7383 

RVCN                (m)733 5515 7383 7396 9598 

RVPLUS              (m)737 8033 8094 9236 9504 9513 9531 9532 

rword               8256 8450 8470 8519 8593 

RX                  (v)5948 5965 5966 5968 5969 5970 5992 6006 
                    6013 

S                   (s)2436 2467 2472 2475 2476 2478 2481 2482 
                    2482 2484 2486 2494 2496 2548 2555 2559 2571 
                    2579 2580 2586 2588 2594 2600 2600 2601 2620 
                    2620 2621 2627 2663 2664 2664 2666 2667 2667 
                    2669 2678 2678 (v)3451 3457 3467 3473 (v)4027 
                    (v)4036 4042 (v)4045 4053 4054 (v)4229 4284 
                    (v)4300 4315 (v)4395 4409 4423 (v)4441 4444 
                    (v)4458 (v)4493 4499 (v)4619 4621 (v)4737 
                    4738 4738 4740 4742 4743 4745 4746 (v)5221 
                    5228 5228 5234 (v)5676 5681 (v)5685 5692 
                    5693 (v)5700 5704 5710 5711 (v)5793 5803 
                    5811 5813 (v)6397 6400 6403 6403 (d)6410 
                    6410 (v)6622 6627 6633 6636 6636 6642 6642 
                    (v)6961 6962 6973 6979 6983 6987 6990 6991 
                    7000 7008 (d)7220 7222 (v)7870 7871 7872 
                    (d)9216 9222 9224 9226 

s                   (d)1291 1298 1299 2456 2686 2693 (v)3843 
                    3844 3845 3845 3848 3849 (v)5085 5096 5097 
                    (v)6781 6783 (v)6866 6868 (d)8415 8418 (d)9048 
                    9086 9138 

S1                  (v)4240 4259 4261 4268 4269 4272 4280 

S2                  (v)4246 4253 4273 4274 

SAVE                (m)726 4487 7728 

Savespacesize       (m)686 4046 4476 4481 5090 5686 

SaveStaticItem      (g)618 (r)3866 4363 5717 

SB                  (v)4232 4286 (v)4304 4317 (v)4397 4425 (v)4459 
                    4511 (v)5017 5071 

Scan                (g)229 7182 (r)7293 

ScanLabels          4833 (r)4844 4858 4863 4875 4888 4898 4898 
                    4905 4907 4910 4912 4913 4917 

ScanRegs            7883 (r)7901 7914 

ScanTable           3883 (f)3901 3905 3906 3915 3923 

SD                  (m)158 (m)722 3621 6743 6833 

SDATOM              (m)158 (m)722 3607 6776 6862 

SDB                 500 (s)2442 2494 2562 2579 2579 2584 2584 

SDN                 499 (v)2577 2580 2580 2584 

SDT                 (v)2588 2595 (d)2709 2710 2718 2718 2720 
                    2722 

SDvec               (s)6721 6749 6839 6841 6854 6906 6909 6910 

SE                  (d)2557 2562 

SECTBRA             (m)157 (m)473 940 2780 2871 2902 2926 2956 
                    3062 3512 3612 

SECTKET             (m)157 (m)474 940 2781 2890 2909 2932 2941 
                    2960 3071 3605 3617 3641 

SELECTON            (m)150 (m)432 3057 3370 

SEMICOLON           (m)152 (m)442 965 1175 2889 2943 2946 2977 
                    3559 3605 3610 3625 

SeparateFN          1346 1375 (r)1453 

SEQ                 (m)152 (m)715 2949 3562 3630 4289 4912 6738 
                    6818 

Set                 6504 6508 6515 (r)6519 

SETCMM              7553 7689 

SETO                7550 7629 8001 9341 

SETOM               7949 

SETZ                7550 7651 8000 9345 

SETZM               7947 

SFD                 529 2637 2644 2644 

sfptr               2143 2389 2394 

SG                  (m)735 5138 7458 

SGC                 (m)735 5334 7390 

SGLH                (m)736 5140 7462 

SGLHZ               (m)740 5146 7474 

SGQ1                (m)736 5141 7464 

SGQ2                (m)736 5142 7466 

SGQ3                (m)737 5143 7468 

SGQ4                (m)737 5144 7470 

SGRH                (m)736 5139 7460 

SGRHZ               (m)740 5145 7472 

SI                  (v)3584 3586 (v)3603 3607 

Simpass             (r)5074 5225 5231 5391 5392 

Simple              (m)762 1188 

SingleBit           5992 6013 (f)6384 

Size                (v)2508 2509 2509 (v)9271 9273 9274 (v)9465 
                    9467 9468 9477 9484 

SIZE                (m)143 (m)383 (m)702 3081 3380 5526 6225 

SKIPE               7633 

SKIPG               7642 

SKIPGE              7648 

SKIPL               7639 

SKIPLE              7645 

SKIPN               7636 

SkipTo              (r)2214 2234 2236 2240 2254 

SL                  (m)730 5155 7476 

SlashUSW            507 2486 

SLC                 (m)734 5340 7391 9655 

SLLH                (m)729 5157 7480 

SLLHZ               (m)741 5163 7492 

SLQ1                (m)730 5158 7482 

SLQ2                (m)730 5159 7484 

SLQ3                (m)730 5160 7486 

SLQ4                (m)730 5161 7488 

SLRH                (m)729 5156 7478 

SLRHZ               (m)740 5162 7490 

slu                 (d)2465 2486 

Small               (m)770 855 863 1181 

SmallLocal          514 2510 

snm                 (v)1815 1816 1817 (v)1979 1980 2011 2053 
                    2054 2056 2057 2059 2061 2062 2065 2066 2067 
                    2070 2073 2074 2074 2075 2075 2076 2076 2077 
                    2077 2078 2078 2094 2097 2098 2099 2102 (d)7093 
                    7175 

so                  (v)8998 9014 9020 9027 

SOS                 7936 

sourcename          (s)1574 1587 1604 1684 1706 1738 1850 1872 
                    2094 

SP                  (m)726 4269 5126 7440 

SPC                 (m)734 5331 7389 9637 9654 

SPLH                (m)727 5128 7444 

SPLHZ               (m)740 5134 7456 

SPQ1                (m)727 5129 7446 

SPQ2                (m)727 5130 7448 

SPQ3                (m)728 5131 7450 

SPQ4                (m)728 5132 7452 

SPRH                (m)727 5127 7442 

SPRHZ               (m)740 5133 7454 

Sr                  (v)7984 7996 (v)9376 9389 9391 9392 (v)9398 
                    9411 9413 9414 

SSP                 (g)185 (g)588 (s)3688 3753 3754 3754 3755 
                    4027 4036 4042 4045 4046 4046 4047 4047 4048 
                    4054 4055 4055 4061 4061 4065 4110 4110 4132 
                    4162 4240 4246 4280 4281 4281 4282 4300 4315 
                    4316 4316 4395 4408 4409 4410 4410 4417 4418 
                    4418 4419 4423 4424 4424 4427 4441 4444 4458 
                    4476 4477 4481 4487 4493 4499 4500 4500 4503 
                    4538 4538 4539 4539 4543 4543 4544 4544 4582 
                    4582 4583 4583 4584 4586 4619 4621 4652 4653 
                    4654 4654 4655 4655 4658 4658 4659 4659 4670 
                    4670 4671 4671 4978 4978 5067 5067 5085 5090 
                    5090 5091 5091 5092 5097 5098 5098 5111 5111 
                    5216 5216 5221 5228 5229 5229 5234 5235 5235 
                    5263 5263 5306 5306 5362 5362 5404 5404 5405 
                    5405 5407 5414 5414 5415 5415 5421 5421 5422 
                    5422 5451 5451 5480 5480 5519 5519 5523 5523 
                    5524 5524 5527 5527 5528 5528 5548 5548 5549 
                    5549 5576 5576 5577 5577 5579 5579 5580 5580 
                    5581 5591 5591 5592 5592 5595 5595 5596 5596 
                    5604 5604 5605 5605 5613 5613 5614 5614 5666 
                    5667 5667 5668 5668 5676 5681 5682 5682 5685 
                    5686 5686 5687 5687 5688 5693 5694 5694 5700 
                    5704 5705 5705 5711 5712 5712 5719 5719 5720 
                    5720 5732 5732 5733 5733 5742 5742 5743 5743 
                    5789 5789 5793 5803 5804 5804 5813 5814 5814 
                    5844 5844 6574 6663 6664 6664 (s)7047 7222 
                    7223 7223 7224 7224 7324 7326 7328 7611 7694 
                    7699 7703 7705 7708 7711 7712 7717 7718 7763 
                    7763 7766 7769 7772 7827 7828 7828 7831 7831 
                    7835 7835 7839 7843 7844 7848 7848 7850 7854 
                    7854 7857 7859 7860 7861 7895 7921 7980 7997 
                    8335 9218 9252 9296 9307 9359 9453 9542 9542 
                    9570 9639 9658 

ST                  (d)3812 3814 3815 (v)4233 4283 (v)4302 4318 
                    (v)4398 4426 (v)4478 4502 

STACK               (m)726 3755 4048 4065 4132 4162 4282 4419 
                    4427 4503 4584 5092 5407 5581 5688 7715 

stack               (d)7267 7268 7268 7269 7269 7270 7270 (d)7273 
                    7274 7275 (d)7277 7278 7278 7279 7280 7280 
                    (d)7283 7283 7283 

Stack               (g)238 7611 7703 7715 7772 7775 (r)7841 7980 
                    7997 9226 9252 9359 9453 9570 9639 9658 

STACKABS            (m)742 

StackAC             (m)282 9092 9222 9224 9638 9654 

Start               (r)1579 

StartStack          (g)225 7142 (f)7273 

STATIC              (m)150 (m)433 (m)711 2865 4018 

StaticN             (g)23 1599 (s)2172 3874 3874 3880 3880 3920 
                    3920 3930 3930 4697 4697 

StatItemL           (s)3712 3746 3746 3748 3774 

StatItemP           (s)3714 3746 3774 3776 3777 3778 3802 3802 
                    3892 3892 3893 

StatP               (g)208 (s)7059 7132 9278 9284 

StatV               (g)207 (s)7058 7132 9279 9279 9280 

STcdYYYYc           527 2643 2644 2647 2649 

STcdYYYYcommand     (m)565 2643 

STcdYYYYs           533 2655 2656 2657 

STcdYYYYstack       (m)566 2655 

Stepsize            (v)4244 4269 4276 

STF                 7931 7933 7936 7941 7948 7950 (l)7955 

stf                 (r)1619 1623 

STfill              (m)556 2498 

STglobal            (m)551 2531 4005 

STglobalYYYYbig     (m)545 2531 

SThead              492 573 2478 2481 2482 2484 2486 2579 2580 
                    2600 2601 2620 2621 2664 2666 2667 

STIND               (m)735 5207 7494 

STINDC              (m)733 5261 5304 7393 

STindex             (m)554 2534 4009 

STINDLH             (m)724 5209 7498 

STINDLHZ            (m)741 5215 7510 

STINDQ1             (m)724 5210 7500 

STINDQ2             (m)724 5211 7502 

STINDQ3             (m)724 5212 7504 

STINDQ4             (m)724 5213 7506 

STINDRH             (m)723 5208 7496 

STINDRHZ            (m)741 5214 7508 

STlocal             (m)550 2506 2525 4261 4620 

STlocalYYYYbig      (m)544 2525 

STmanifest          (m)549 2521 4013 

STmanifestYYYYbig   (m)543 2523 

stn                 (d)2660 2677 

STORE               (m)723 4257 4420 7717 

Store               (g)240 2490 2551 2551 2565 2610 2651 2658 
                    2675 (r)2701 2727 7694 7699 7705 7711 7717 
                    7769 7844 (r)7866 7895 7921 9218 9296 

StoreCodes          (r)7958 7978 7995 

StoreI              (g)234 7494 7496 7498 7500 7502 7504 7506 
                    7508 7510 (r)7982 

Storein             (g)233 7440 7442 7444 7446 7448 7450 7452 
                    7454 7456 7458 7460 7462 7464 7466 7468 7470 
                    7472 7474 7476 7478 7480 7482 7484 7486 7488 
                    7490 7492 (r)7975 

storestring         (g)262 7796 9460 9461 (r)9463 

StoreT              7872 7898 (r)7924 

STparam             (m)552 2506 2533 4480 

str                 (v)1293 1294 1298 

String              94 2688 8310 8311 8314 8317 8395 8398 

STRINGCONST         (m)141 (m)362 (m)698 886 1040 1046 2779 3029 
                    3357 3789 3889 3934 3944 3948 3968 4357 4360 
                    5598 6186 6214 6252 6282 7794 7796 

StringLength        (m)107 2266 

StringMaxOb         (m)108 (m)688 1027 1043 3790 3969 5600 

StringToASCIZ       1194 1352 1381 1956 9481 

strng               (d)1487 1500 

StructB             504 2600 

StructN             503 (v)2597 2597 2597 2601 2601 

STRUCTURE           (m)150 (m)437 (m)712 2899 2916 4015 6692 
                    6800 6898 

STsd                510 570 2498 2508 2510 2514 2537 2539 2541 
                    2542 2546 2561 2563 2571 2586 2628 2630 2630 

STsectket           (m)555 2561 

STstatic            (m)547 2536 2542 2630 4724 

STstaticYYYYfunction(m)559 4630 

STstaticYYYYlabel   (m)563 4853 

STstaticYYYYroutine (m)561 4630 

STstaticYYYYvar     (m)558 4351 

STstructure         (m)548 2527 2586 6802 6900 

STtype              (v)4629 4632 

SType               519 2539 

STYYYYMaxDatum      (m)569 2513 

STYYYYSymbHeaderN   (m)572 2475 

SUB                 8026 9265 9615 9649 

Sub                 (v)6570 6588 6590 6592 6592 6627 6641 (v)6670 
                    6676 6677 6682 

SUBI                8024 9224 

SubSw               (v)6568 6585 6592 6598 6607 6625 6637 6646 
                    6651 6656 

suppersptr          (g)33 (r)2142 4506 4508 

Svec                (g)204 (s)7055 7130 9271 9272 9273 9476 9477 
                    9481 9483 

SvecP               (g)205 (s)7056 7130 9270 9276 9468 9476 9477 
                    9481 9483 9484 9484 

SvecT               (g)206 (s)7057 7130 9468 

Sw                  (v)1311 1314 (d)6812 6819 6820 6824 6828 
                    6834 6896 

SW                  82 1687 1688 1699 1708 1718 1750 1751 1770 
                    1773 1786 1811 1814 1832 1860 1879 2020 2023 
                    2024 2027 2031 2033 2035 2141 2143 2248 2280 
                    2368 2407 2495 2522 2527 2668 2704 2716 2772 
                    2775 3044 3747 3756 3858 4261 4283 4318 4338 
                    4426 4481 4502 4653 4723 5082 6802 6802 6900 
                    6900 7154 7168 7170 7173 7202 7312 7317 7332 

SWbit               (d)6558 6633 

SWbits              (g)14 1669 1671 1687 1687 1688 1699 1708 
                    1718 1719 1719 1740 1743 1750 1751 1770 1773 
                    1786 1787 1791 1808 1811 1814 1832 1847 1860 
                    1874 1879 1894 1925 2020 2023 2024 2027 2029 
                    2031 2033 2035 2037 2039 2041 2141 2143 (s)2164 
                    2248 2280 2368 2407 2495 2522 2527 2668 2704 
                    2715 2716 2772 2775 3044 3747 3756 3858 4261 
                    4283 4318 4338 4426 4481 4502 4653 4723 5082 
                    6802 6802 6900 6900 7154 7168 7170 7173 7202 
                    7312 7317 7332 

SWcontrol           (g)302 881 1178 (s)1233 1650 

SWdot               (v)810 816 822 825 834 842 

SWext               (v)4701 4704 4705 4724 

SWInit              (m)1552 1894 1925 

SwitchBlock         (g)601 (s)3703 3734 4169 4185 4211 4232 4235 
                    4286 4304 4305 4317 4397 4399 4425 4459 4460 
                    4511 5017 5018 5028 5071 

SWITCHON            (m)155 (m)461 (m)718 3075 3484 4225 4903 
                    5039 7781 

SWlocal             1532 1669 1671 1687 1719 1719 1740 1743 1787 
                    1791 1808 1847 1874 2029 2037 2039 2041 

SWnoload            (d)6558 6596 6663 

SWupper             (g)13 1247 1251 1665 1751 2018 (s)2179 

SWwide              (d)6558 6654 

SX                  (m)728 5166 5175 7402 

SXQ1                (m)728 5169 7403 

SXQ2                (m)728 5170 7404 

Symb                (g)310 792 886 1172 1174 1175 (s)2736 2777 
                    2778 2791 2796 2801 2801 2802 2803 2808 2810 
                    2863 2869 2871 2878 2882 2882 2889 2890 2902 
                    2909 2926 2932 2946 2956 2960 2961 2970 2977 
                    2984 2988 2988 2995 3003 3018 3018 3020 3024 
                    3031 3045 3050 3060 3062 3071 3083 3099 3127 
                    3135 3143 3148 3160 3167 3174 3181 3188 3203 
                    3208 3232 3252 3260 3272 3294 3301 3301 3303 
                    3305 3313 3334 3336 3345 3383 3389 3403 3411 
                    3416 3423 3427 3432 3432 3436 3436 3445 3449 
                    3454 3458 3463 3466 3470 3481 3485 3488 3495 
                    3499 3507 3515 3523 3535 3537 3542 3546 3548 
                    3559 3579 3581 3584 3589 3592 3595 3602 3603 
                    3605 3605 3605 3610 3612 3617 3624 3653 3656 
                    3657 

symbtabname         (v)1833 1838 1840 

SymbVersion         (m)489 2478 

Symtab              83 1751 1786 1832 2020 2704 2716 4261 4283 
                    4318 4338 4426 4481 4502 4653 4723 6802 6900 
                    7317 7332 

SymtabFinish        (g)56 1840 (r)2660 

SymtabInit          (g)47 1751 (r)2465 

SymtabLong          90 2023 2522 2527 6802 6900 

SymtabNextN         (g)49 (f)2555 3814 4233 4302 4398 4478 

SYMTABSTART         (m)2464 2467 

SymtabStoreArgs     (g)51 (r)2568 4481 

SymtabStoreCommand  (g)54 (r)2632 7321 

SymtabStoreEnd      (g)50 (f)2557 3815 

SymtabStoreILC      (g)53 (r)2624 7332 

SymtabStoreStack    (g)55 (r)2653 7326 

SymtabStoreSymbol   (g)48 (f)2500 3808 

SymtabTransEnd      (g)52 1786 (r)2573 

SYNONYM             (m)141 (m)354 1432 

Synrep              88 1687 1750 2033 

T                   674 (v)879 881 893 893 893 894 895 896 (v)1318 
                    1327 1328 1328 1328 1330 1335 1406 (v)1409 
                    1410 1410 1411 (v)1422 1423 1423 1424 (v)1434 
                    1441 1442 (d)3901 3905 3906 3915 3925 3931 
                    3934 3936 (v)4126 4127 4128 4128 4128 4130 
                    (v)4155 4156 4157 4157 4157 4159 (v)5510 
                    5510 5516 5517 (v)6394 6394 6398 6659 

t                   (v)1095 1097 1097 1099 1099 1100 (v)1279 
                    1281 1284 (v)1726 1727 1728 1729 1731 (v)1762 
                    1763 1764 1765 1767 (v)1834 1835 1836 1837 
                    1839 (v)1994 1997 2000 2001 (v)2055 2057 
                    (v)2060 2062 (v)2323 2333 2334 2344 2344 
                    (v)2560 2561 2563 2564 2565 (v)2642 2643 
                    2644 2647 2649 2651 (v)2654 2655 2656 2657 
                    2658 (v)2676 2680 (v)2715 2716 2716 (v)3840 
                    3842 3842 3843 3847 3847 3848 3849 (v)3881 
                    3882 3882 3883 3886 (v)3891 3892 3893 (v)3921 
                    3922 3922 3923 3925 (v)4353 4354 4360 4360 
                    4363 (v)4699 4701 4710 4711 4714 4718 (d)4736 
                    4740 4742 (v)5102 5104 5107 5113 5115 5124 
                    5151 (v)5474 5474 (v)5609 5611 5615 5624 
                    5635 5642 (v)5740 5744 5753 5754 5757 5763 
                    (v)6142 6143 6144 (v)6180 6180 (v)6689 6690 
                    6692 6695 (i)6702 6703 6703 (v)6735 6761 
                    6762 6764 6765 6777 6778 6779 6783 6784 6784 
                    6784 6784 6784 6784 6786 6787 6797 6797 6799 
                    6800 6802 (v)6816 6856 6858 6877 6877 6897 
                    6898 6900 6905 6905 6909 (d)7017 7019 7022 
                    7025 (v)7156 7157 7158 7159 7160 7161 7163 
                    (v)7189 7190 7191 7192 7193 7194 7196 (v)7432 
                    7436 (v)7868 7869 7870 7872 7873 7873 (d)9048 
                    9089 

t3                  (v)1171 1173 1173 

t4                  (v)1171 1173 1173 

TABLE               (m)148 (m)424 (m)710 3127 3784 3878 3882 
                    3918 3922 3945 3977 4355 5715 6189 6217 6252 
                    6265 6277 

Table               (v)6559 6602 6602 6604 6605 6620 6622 6623 
                    6650 6651 6656 6659 (v)6669 6677 6677 6679 
                    6682 6682 6682 6682 (d)6686 6688 6700 6700 
                    6702 

TableSpace          4545 (f)4806 4809 4809 4812 4814 

tabov               (m)8236 8531 8544 

TD1                 4443 (r)4530 4547 4548 4557 4587 

TD2                 4575 (r)4579 4588 4590 4591 4597 

TDNE                9599 9624 

Tempsize            (m)287 7221 7822 7837 7853 7858 7873 7890 
                    7909 9536 

TempT               (g)210 (s)7051 7135 7823 

TempV               (g)209 (s)7050 7134 7135 7221 7221 7832 7851 
                    7868 7888 7902 9539 

Terminate           1718 (l)1831 

TEST                (m)153 (m)446 (m)715 3421 3441 4077 4896 

Thisline            (v)2862 2898 2917 2922 2940 (v)3292 3333 
                    (v)3344 3415 3487 3503 3504 3516 

ThisLine            (v)3534 3540 3552 3553 3554 3559 3563 (v)3576 
                    3641 

TL                  (v)2876 2887 

tmpcount            (s)8248 8385 8500 8503 8505 8507 8515 8515 
                    8521 8521 8718 8733 

tmpx                (s)8201 8363 8510 8512 8516 8518 8518 8519 

tnm                 (d)8649 8714 

TO                  (m)154 (m)459 3458 3463 3495 3546 

TraceTable          6190 6218 6265 (f)6303 

Trans               (g)620 3758 (r)3993 4024 4066 4073 4080 4083 
                    4124 4150 4181 4207 4217 4266 4290 4291 4313 
                    4421 4494 5025 5664 

Transdef1           4412 (r)4429 4437 4438 

Transdef2           4414 (r)4564 4571 4572 

TranslateTree       (g)59 1772 (r)3718 

TransLET            (g)622 3998 (r)4394 

TransReport         (g)615 3799 (r)3827 3869 3884 3913 3924 3980 
                    4029 4088 4093 4098 4107 4169 4170 4185 4192 
                    4195 4211 4213 4220 4294 4332 4335 4448 4551 
                    4556 4596 4639 4668 4675 4716 4738 4757 4780 
                    4800 4811 4999 5036 5056 5082 5086 5087 5106 
                    5118 5124 5175 5177 5191 5239 5267 5275 5292 
                    5294 5314 5326 5329 5351 5353 5367 5372 5378 
                    5382 5384 5413 5420 5573 5587 5617 5627 5643 
                    5731 5746 5757 5774 5818 6004 6150 6289 6316 
                    6362 6381 6429 6578 6583 6611 6618 6654 6687 
                    6690 6693 6704 6773 6787 6792 6829 6874 6891 
                    6907 6928 6947 7012 7014 7015 7026 

TransStructDecl     (g)665 4016 (r)6734 6740 6741 6770 6772 

Transswitch         (g)638 4226 (r)5012 

Tree                1534 (v)1697 1701 1706 1712 1719 1740 1742 
                    1772 1791 1794 2039 (d)3827 3840 3858 3859 

Tree2               1536 1687 1719 1743 1787 2037 

treename            (s)1576 1589 1606 1725 1730 1733 1735 

TreeStream          (s)1556 1735 1736 1745 1790 1797 1846 1846 
                    1869 1869 

TRUE                (m)142 (m)365 (m)699 2766 3041 3371 5574 
                    5895 7422 7615 7619 7624 

TRUENODE            (g)115 (s)2747 2766 3041 

TSD                 6745 6752 (r)6812 6819 6820 6824 6828 6834 
                    6845 

tt                  (v)4531 4536 4537 4540 

Type                511 528 535 (v)1026 1031 1031 1131 1133 (d)2184 
                    2186 (v)2362 2364 2366 2367 2368 2370 2408 
                    2498 (d)2500 2506 2506 2516 2523 2525 2531 
                    2541 2541 2542 2561 2586 2630 2643 2655 (d)3806 
                    3808 (d)4648 4653 4662 4663 (d)4695 4724 
                    (d)4779 4782 (d)5074 5086 5134 5146 5163 
                    5172 5191 5192 5202 5215 5225 5231 5239 5267 
                    (d)5370 5380 5380 5386 5391 5392 

U                   (v)3451 3460 3465 3473 (v)4189 4191 (v)6700 
                    6702 (v)6926 6927 

undeflab            (m)8141 8620 

UNLESS              (m)153 (m)452 (m)716 3409 4069 4072 4861 

Unpackstring        1344 1373 1506 1942 2268 3768 3791 3970 5601 
                    6470 

UNRESERVE           (m)141 (m)355 1420 

UNTIL               (m)153 (m)453 (m)716 3411 3414 4113 4868 

UPLUMP              (m)148 (m)420 (m)709 1022 3592 3595 3656 
                    3656 6586 6676 

upperpptr           (s)1563 1591 2113 2118 

upperpull           1812 (f)2111 

uppersptr           (s)1564 1592 2108 2113 2141 2143 

upperstuff          1771 (r)2107 

ups                 (v)1343 1344 1346 1349 1353 1354 1355 1356 
                    1359 (v)1372 1373 1375 1378 1382 1383 1384 
                    1385 1388 (d)1448 1450 1450 1451 

UPSToSixbit         1348 1377 (f)1448 

v                   (d)1190 1193 (v)1292 1294 1295 1296 1297 
                    (v)1320 1322 1323 1333 1344 1361 1373 1390 
                    1405 1415 1416 1427 1428 1436 1437 (v)1438 
                    1439 1439 1439 1440 1442 (v)1472 1473 1474 
                    (v)1488 1489 1494 1494 1495 1495 1500 (v)1583 
                    1584 1585 1586 1587 1588 1589 1590 (s)1614 
                    1616 1617 1618 1620 1620 1621 1621 1627 1627 
                    (v)1632 1637 1638 1639 1641 1642 1642 1643 
                    (v)1689 1690 (v)1691 1692 (v)1777 1778 1779 
                    1780 (v)1895 1896 1900 1900 1901 1901 1904 
                    1906 1906 1907 1907 1914 (v)1919 1920 1921 
                    1930 1930 1935 1939 1939 1943 1945 1962 1963 
                    1964 1965 1966 1986 1988 1991 2015 2016 2044 
                    2046 (d)2120 2121 2122 (v)2266 2268 2268 
                    2268 (v)2324 (v)2327 2328 2329 2330 2332 
                    2333 2338 2339 2339 2343 (v)2503 2510 2514 
                    2537 2538 2539 2541 2542 2546 2551 2551 (v)2756 
                    2759 (v)2763 2763 (v)2764 2764 (d)3008 3009 
                    3009 (v)3738 3739 (v)3744 3745 (v)3767 3768 
                    3769 3770 3770 (v)3790 3791 3793 3794 3794 
                    (v)3969 3970 3972 3973 3973 (v)5600 5601 
                    5602 5603 5603 (v)6747 6749 6751 6755 6757 
                    6758 6758 6758 6758 6758 6758 6760 6762 (v)6836 
                    6838 6841 6842 6842 6848 6849 6851 6851 6851 
                    6851 6853 6853 6855 6858 (v)6863 6864 6868 
                    6869 6869 6869 6869 6869 6869 6871 6871 6873 
                    6874 6876 6877 (d)6913 6916 6917 6918 6920 
                    6929 6931 (v)7187 7198 7199 (v)7337 7339 
                    7340 7341 (v)7348 7350 7351 7352 (d)8388 
                    8395 8398 (d)8870 8874 8884 8888 (d)8892 
                    8893 8909 8913 (d)9042 9043 9043 9043 9043 
                    9043 9043 9043 (v)9217 9223 (v)9325 9344 
                    (v)9351 9370 (v)9428 9433 (v)9464 9474 9475 
                    9480 9483 (d)9522 9524 9526 9526 9530 9532 
                    9532 9532 9533 (v)9538 9541 

V                   (g)312 797 822 822 833 837 843 843 843 847 
                    848 866 877 877 887 893 896 916 936 938 1036 
                    1038 1045 1045 1135 (v)1277 1281 1282 1283 
                    1283 1284 1287 (v)2287 2288 2289 (v)2292 
                    2293 2293 2294 (v)2297 2298 2298 2298 2299 
                    (v)2302 2303 2303 2303 2303 2304 (v)2307 
                    2308 2308 2308 2308 2308 2309 (v)2312 2313 
                    2313 2313 2313 2313 2313 2314 (s)2745 2764 
                    2781 2783 2784 2785 2874 2874 2879 2905 2905 
                    2929 2929 2957 2957 2975 3000 3009 3020 3030 
                    3031 3031 3034 3037 3068 3068 3139 3446 3590 
                    3614 3614 3654 (v)4396 4422 (v)5244 5246 
                    5248 5261 (v)5282 5284 5284 5287 (v)5342 
                    5344 5344 5346 (v)5489 5491 5493 5510 5517 
                    (v)5531 5534 5536 (v)5824 5826 5827 (v)6228 
                    6230 6233 (v)6240 6242 6244 (v)6254 6256 
                    6258 6260 6268 (d)6392 6394 6394 6394 (v)6469 
                    6470 6471 6472 6472 

v1                  (v)1191 1193 1194 1195 1196 1198 (v)1940 
                    1942 1944 1944 1945 1945 1947 1947 1948 1948 
                    1949 1949 1950 1950 1951 1951 1952 1952 1953 
                    1953 1954 1954 1955 1956 1958 (v)7125 7126 
                    (v)7127 7128 (v)7129 7130 (v)7131 7132 (v)7133 
                    7134 (v)7136 7137 (v)7140 7141 (v)7171 7172 
                    (v)7338 7341 7342 (v)7349 7352 7353 

V1                  (s)290 (v)2868 2874 2893 (v)2900 2905 2912 
                    (v)2924 2929 2935 (v)2955 2957 2965 (v)3067 
                    3068 3072 (v)3613 3614 3618 7522 7534 7552 
                    7565 7650 7690 9259 9265 9555 9560 9584 9589 
                    9615 9649 

v2                  (v)1192 1194 1195 (v)1941 1955 1956 1957 
                    1958 1959 1960 

VALDEF              (m)151 (m)713 3322 3330 4440 4575 4618 

VALOF               (m)149 (m)426 (m)710 3053 3055 3076 3376 
                    5657 6280 

ValofBlock          (g)600 (s)3702 3733 4459 4460 4511 5660 5662 
                    5671 

Value               (v)5885 5942 5986 6006 6010 6022 6030 6039 
                    6043 6138 6144 (s)6153 6156 6159 6159 6187 
                    6215 6224 6226 6233 6244 6268 6298 6298 

VB                  (v)4459 4511 (v)5660 5671 

VEC                 (m)151 (m)441 (m)714 3111 3113 3780 3782 
                    3872 3873 3928 3931 3943 3964 3965 4356 4536 
                    4582 4813 6279 7791 

VECAP               (m)147 (m)413 (m)708 1006 3153 3156 5205 
                    5276 5454 5478 5783 6174 6202 

VecSSP              (g)608 (s)3711 4396 4408 4413 4415 4417 4422 
                    4537 4540 4540 4542 4545 4545 4586 

Version             495 2478 

Vmax                (m)334 864 2764 

VMINIT              (e)170 7097 (r)8332 

Vp                  (v)797 822 822 833 833 833 837 837 837 843 
                    847 864 866 866 866 873 873 877 929 929 930 
                    931 933 936 938 1036 1038 1043 1129 1129 
                    1129 

VV                  (v)925 933 936 936 (v)1027 1036 1036 1129 

vv                  (v)9479 9480 9481 

w                   (v)8301 8303 8314 (v)8392 8411 8411 8413 
                    (d)8430 8449 8471 (d)8564 8594 (r)9045 9070 
                    9072 9078 9081 9083 9087 9098 9106 9121 9123 
                    9131 9134 9140 9149 9155 9173 9188 (v)9537 
                    9551 9551 9561 9564 (d)9572 9580 9580 9590 
                    9593 9599 9600 (d)9604 9610 9610 9614 9617 
                    9624 9625 (d)9629 9636 9636 9648 9651 

W                   673 5261 (v)5284 5284 5293 5304 (v)5344 5344 
                    5352 5361 5517 (v)6394 6394 6397 6479 6481 
                    6485 6489 6494 6494 6501 (r)6503 (v)6573 
                    6650 6651 6651 6654 6654 6658 6658 

Warns               (g)28 1595 1847 1852 (s)2181 2373 

Wfline              (g)44 2249 (r)2321 3833 3849 7264 7314 

WHILE               (m)154 (m)454 (m)716 3410 3414 4112 4130 
                    4869 4877 

Word                531 2639 2647 2647 (d)2701 2706 

WORD                (m)158 (m)483 (m)722 3582 3668 6945 

WordOK              (v)6632 6635 6638 

WordSizeOb          (m)692 5291 5293 5350 5352 5522 5832 5840 
                    6224 6260 6262 6397 6633 6633 6636 6636 6639 
                    6654 6945 6973 6976 6979 6983 6983 6990 6990 
                    7000 

WRBLK               (e)179 7791 (r)8985 

WRCH                (e)169 7724 7725 (r)8961 8989 9046 

WRDATA              (g)244 7787 7789 (r)9163 9273 9281 9289 

WREXT               (e)178 7353 (r)8892 

WRIMP               (e)173 7179 7368 (r)8970 

WRINT               (e)177 7342 (r)8870 

Write2              6486 6491 6499 (r)6514 

Write4              6482 6490 6497 (r)6507 

Writech             1857 1877 1905 1906 1911 1928 1930 2201 2202 
                    2343 2347 2404 6505 6509 6510 6511 6512 6516 
                    6517 6520 6520 7095 7104 7210 7218 7305 8671 
                    8681 8783 8889 8912 8914 8962 9006 9009 

WriteChar           (g)36 1151 (r)2188 2268 2272 

WriteN              1624 1710 1775 1780 2129 2130 2259 2383 2783 
                    3848 8886 8911 8968 9005 

WriteOct            1152 1701 1712 1714 2260 2277 2280 2496 2669 
                    2777 2785 3748 7205 7207 7209 7261 7304 7364 
                    8782 8965 9003 9008 

WriteS              1140 1151 1152 1153 1683 1684 1685 1700 1704 
                    1709 1711 1713 1732 1733 1737 1738 1739 1761 
                    1774 1776 1782 1793 1813 1849 1850 1851 1852 
                    1855 1856 1871 1872 1873 1875 1876 1893 1915 
                    1926 1927 1929 1968 1969 1970 1971 1972 1973 
                    1974 1975 1976 2003 2129 2130 2219 2220 2221 
                    2222 2234 2236 2242 2243 2257 2260 2264 2264 
                    2267 2272 2275 2275 2277 2279 2280 2335 2380 
                    2496 2669 2670 2781 2784 2820 2822 2829 2829 
                    2833 2837 3748 3833 3835 3838 3845 3849 3853 
                    3854 3855 7204 7206 7208 7262 7313 7363 7365 
                    8418 8668 8674 8781 8786 8787 8788 8789 8884 
                    8885 8887 8888 8908 8909 8910 8913 9002 9004 
                    9007 

WRLAB               (g)246 7180 7713 7722 7783 (r)9153 9272 9280 
                    9288 9472 

WRLST               (e)174 7174 7175 7176 7177 7186 7723 (r)8415 
                    8987 9071 9085 9109 9116 9157 9171 9177 9183 

WRMAC               (g)247 7178 7436 7550 7553 7629 7651 7695 
                    7701 7707 7731 7732 7733 7734 7764 7771 7778 
                    7785 7933 7936 7940 7947 7949 7954 7979 7996 
                    8000 8001 8002 8004 8007 8010 8013 8015 8024 
                    8026 8076 8084 8086 8092 8099 8106 8108 8110 
                    8111 8112 8114 8115 8116 8119 8120 8122 8124 
                    8127 8128 8131 8132 8133 9043 (r)9048 9222 
                    9224 9225 9317 9341 9343 9345 9384 9391 9392 
                    9406 9413 9414 9445 9446 9448 9451 9458 9470 
                    9548 9559 9561 9562 9563 9564 9565 9566 9569 
                    9577 9588 9590 9591 9592 9593 9594 9595 9597 
                    9599 9600 9610 9616 9617 9618 9619 9621 9624 
                    9625 9638 9650 9651 9652 9654 9655 9656 9657 

WRN                 (r)8967 9086 9107 9135 9156 9178 

WROCT               (e)171 (r)8964 8988 9077 9101 9110 9122 9172 
                    9174 9184 

WRPU                (e)172 7181 7183 7372 (r)8980 

Wrtime              1717 1785 1821 (r)2126 

WUPFLG              (g)309 790 1254 1259 (s)2743 

x                   (v)924 940 940 (v)1449 1450 1450 1451 (v)1617 
                    1624 1626 1627 1627 1628 (d)2188 2190 2191 
                    2201 (d)2204 2231 2233 2233 2234 2238 2241 
                    2246 2248 2249 2251 2258 2264 2268 2272 2277 
                    2280 2282 (v)2489 2490 (d)3718 3757 3758 
                    (v)3778 3779 3782 3786 3791 3793 3799 (d)3866 
                    3867 3869 3873 3873 3874 3879 3883 3884 3886 
                    3892 (v)3902 3903 3905 3906 3912 3913 3915 
                    3919 3923 3924 3928 3928 3930 3931 3934 (d)3940 
                    3942 3942 3948 3949 3953 3956 3958 3959 3962 
                    3980 (d)3993 3994 3994 3995 3996 3998 4001 
                    4004 4008 4012 4016 4019 4022 4024 4028 4028 
                    4029 4029 4029 4035 4037 4039 4039 4040 4041 
                    4049 4049 4050 4050 4051 4052 4059 4059 4060 
                    4064 4066 4070 4072 4073 4079 4080 4083 4088 
                    4093 4098 4103 4106 4106 4107 4124 4126 4130 
                    4148 4150 4151 4155 4159 4169 4174 4177 4181 
                    4185 4189 4189 4192 4202 4207 4211 4213 4217 
                    4220 4226 4242 4242 4244 4244 4250 4251 4253 
                    4255 4259 4261 4265 4266 4290 4291 4294 (d)4297 
                    4306 4311 4313 (d)4322 4324 4324 4324 4324 
                    4325 4326 4328 4332 4335 4337 4338 (d)4345 
                    4347 4347 4347 4347 4348 4349 4351 4353 4368 
                    (d)4394 4400 4400 4401 4411 4421 (d)4429 
                    4431 4432 4433 4433 4433 4433 4435 4437 4438 
                    4442 4443 4444 4448 4468 4474 4475 4475 4480 
                    4481 4494 4494 4497 4497 (d)4530 4532 4532 
                    4533 4534 4536 4545 4547 4548 4550 4551 4554 
                    4556 4557 (d)4564 4565 4565 4566 4567 4568 
                    4568 4568 4570 4571 4572 4575 4575 (d)4579 
                    4580 4580 4581 4582 4586 4587 4588 4590 4591 
                    4594 4596 4597 (d)4608 4609 4610 4611 4611 
                    4611 4613 4615 4616 4620 4621 4626 4630 4632 
                    4632 4635 4639 (d)4648 4649 4650 4652 4653 
                    4662 4663 4666 4668 4675 (d)4695 4699 4709 
                    4716 4724 (d)4748 4751 4751 4751 4756 4757 
                    4757 4758 (d)4793 4794 4794 4795 4795 4795 
                    4796 4796 4798 4800 4801 (d)4806 4807 4807 
                    4808 4809 4809 4810 4811 4812 4813 4814 (d)4829 
                    4833 (v)4845 4846 4847 4852 4853 4856 4858 
                    4861 4862 4863 4865 4866 4870 4875 4878 4883 
                    4888 4892 4893 4896 4897 4898 4898 4900 4900 
                    4902 4905 4907 4910 4912 4913 (d)4923 4924 
                    4925 4928 4928 4929 4930 4935 4936 4940 4941 
                    4945 4946 4950 4951 4958 4959 4962 4968 4969 
                    4972 4976 (d)4987 4988 4989 4989 4990 4991 
                    4992 4995 4997 4999 5000 5004 (d)5012 5025 
                    5029 5029 5036 5056 (d)5074 5076 5076 5077 
                    5082 5086 5087 5093 5095 5102 5106 5108 5118 
                    5120 5124 5175 5177 5191 5192 5202 5206 5223 
                    5225 5231 5239 5243 5244 5267 5271 5275 5282 
                    5292 5294 5326 5329 5342 5351 5353 5367 (d)5370 
                    5371 5372 5375 5375 5377 5378 5380 5382 5386 
                    5386 5387 5391 5391 5391 5392 (d)5402 5403 
                    5406 5408 5411 5411 5412 5413 5418 5420 5425 
                    5427 5448 5449 5468 5468 5487 5489 5522 5526 
                    5531 5568 5573 5583 5590 5594 5601 5609 5617 
                    5619 5627 5643 5663 5664 5675 5677 5677 5679 
                    5680 5689 5689 5690 5691 5701 5702 5707 5717 
                    (d)5729 5730 5731 5736 5740 5746 5748 5757 
                    5774 5774 5781 5784 5784 5785 5785 5785 5796 
                    5799 5806 5818 5820 5823 5824 (v)5882 5883 
                    5884 5888 5897 5929 5929 5931 5931 5974 5976 
                    5980 5982 5988 5990 5997 6004 6008 6017 6024 
                    6026 6032 6034 6045 6049 6051 6053 6055 6059 
                    6061 6063 6065 6069 6133 6134 6142 6150 6156 
                    6165 6166 6168 6168 6169 6175 6175 6177 6177 
                    6200 6205 6209 6220 6224 6226 6228 6237 6238 
                    6240 6244 6250 6251 6254 6276 6279 6288 6289 
                    (d)6307 6308 6309 6311 6311 6313 6315 6316 
                    6318 6324 (d)6384 6387 6387 6388 6388 (v)6414 
                    6415 6415 6417 6417 6417 6425 6428 6428 6429 
                    (d)6478 6479 (d)6480 6481 (d)6484 6485 (d)6488 
                    6489 (d)6496 6497 (d)6498 6499 (d)6500 6501 
                    (d)6503 6505 (d)6507 6509 6510 6511 6512 
                    (d)6514 6516 6517 (d)6558 6578 6578 6580 
                    6582 6582 6611 6612 6612 6618 6618 6618 6624 
                    6624 6654 (d)6667 6673 6675 6675 6680 6680 
                    (d)6686 6687 6687 6689 6690 6690 6693 6699 
                    6699 6703 6704 (d)6734 6736 6736 6736 6736 
                    6737 6740 6741 6745 6745 6751 6752 6753 6770 
                    6772 6773 6778 6780 6781 6781 6787 6792 6800 
                    6802 (d)6812 6815 6815 6815 6815 6817 6819 
                    6820 6824 6828 6829 6834 6834 6838 6845 6846 
                    6864 6865 6866 6866 6874 6883 6891 6898 6900 
                    6907 (d)6913 6915 6922 6923 6928 (d)6937 
                    6938 6947 (d)6960 6961 6964 6965 6966 6966 
                    6971 7001 7007 7015 (v)7278 7281 (v)7882 
                    7888 7889 7889 7890 7890 7892 7898 (v)7902 
                    7905 7906 7909 7909 7911 (d)7924 7927 7927 
                    7927 7927 7931 7932 7933 7935 7936 7939 7940 
                    7944 7945 7946 7946 7947 7949 7953 7954 7956 
                    7956 7956 7956 7956 (d)8030 8031 8032 8033 
                    8033 8033 8033 8036 8036 8036 8037 8037 8038 
                    8038 8039 8039 8040 8040 8041 8041 8042 8042 
                    8043 8043 8044 8044 8045 8045 8046 8046 8047 
                    8047 8048 8048 8050 8051 (d)8054 8056 8058 
                    8064 8064 8064 8066 8067 8068 8070 8071 8071 
                    8071 8074 8076 8078 8078 8078 8078 8082 8084 
                    8084 8086 8086 8087 8089 8090 8094 8094 8094 
                    8096 8097 8098 8103 8106 8106 8108 8108 8110 
                    8110 8114 8114 8119 8119 8119 8122 8122 8124 
                    8124 8127 8127 8127 8131 8131 8131 8135 8135 
                    8135 8135 (d)8524 8526 8535 (v)8556 8557 
                    8559 8559 8561 8561 (v)8611 8612 8614 8617 
                    8619 (v)8874 8881 (v)8893 8899 (v)8924 8927 
                    (v)8946 8949 (d)9048 9090 9092 9120 9122 
                    9127 9139 (d)9496 9499 9500 9501 9502 9503 
                    9504 (d)9506 9506 9506 9506 (d)9507 9510 
                    9511 9511 9512 9514 9514 9515 9516 9516 9517 
                    9520 (d)9522 9525 9526 9526 9527 9528 9531 
                    9531 9531 9532 9532 9532 (v)9536 9541 9542 
                    9542 9542 9542 9545 9568 (v)9605 9606 9610 
                    9620 (v)9630 9632 9633 

X                   (d)1504 1506 1512 (v)1883 1884 1885 1886 
                    1887 1888 (v)2133 2139 (d)3660 3661 (d)3901 
                    3902 3936 (d)6303 6327 

XOR                 9425 

XR                  (v)7431 7436 7437 

XRBOT               (v)7148 7205 

xrg                 (v)9633 9638 9657 

XRTOP               (v)7149 7209 

y                   (v)2190 2201 2202 (v)3962 3963 3965 3970 
                    3972 3978 (d)5074 5087 5094 5111 5111 5202 
                    5205 5205 5216 5222 5222 5228 5242 5242 5263 
                    5270 5270 5306 5362 (d)5370 5371 5372 5375 
                    5375 5376 5380 5380 5381 5383 5384 5386 5391 
                    5392 (v)6200 6201 6202 6203 6203 6203 (v)6209 
                    6210 6211 6212 6214 6215 6217 6218 (v)6309 
                    6310 (v)6318 6319 (d)6480 6482 (d)6484 6486 
                    (d)6488 6490 (v)6923 6924 6924 6926 (v)8556 
                    8558 8560 8560 8561 8561 (v)8611 8613 8616 
                    8616 8617 8618 8618 8622 8623 8627 8634 8635 
                    8638 8638 8643 8644 8646 

z                   (d)6488 6491 (v)8611 8627 8628 8628 8628 
                    8629 8631 8632 8632 8636 8638 8639 8640 8641 
                    8641 8645 

Z                   (v)5271 5272 5279 5310 5314 5316 5329 (v)6251 
                    6252 6252 6265 6265 6266 

ZERONODE            (g)597 (s)3698 3751 6298 6431 6431 
