;<BCPL>XNTLIB.MAC;3    16-JUN-75 11:34:39    EDIT BY LIEB
;CHANGED INDEXING ON BYTE POINTERS FOR KI-TENEX
;<JOHNSON>XNTLIB.MAC;26    28-FEB-73 12:09:07	EDIT BY JOHNSON
; ADD HSTINF ROUTINE.
;<JOHNSON>XNTLIB.MAC;25    12-DEC-72 12:58:46	EDIT BY JOHNSON
;<JOHNSON>XNTLIB.MAC;23    11-DEC-72 18:00:47	EDIT BY JOHNSON
;<JOHNSON>XNTLIB.MAC;22    11-DEC-72 17:41:52	EDIT BY JOHNSON
; CORRECTIONS TO KEEP THE STACK COVERED IN NTGJFN
;<JOHNSON>XNTLIB.MAC;21     5-DEC-72 10:23:46	EDIT BY JOHNSON
;<JOHNSON>XNTLIB.MAC;20     4-DEC-72 12:36:18	EDIT BY JOHNSON
;<JOHNSON>XNTLIB.MAC;19    29-NOV-72 17:07:05	EDIT BY JOHNSON
TITLE	NETLIB
SUBTTL	BOB THOMAS

;A LIBRARY OF USEFUL FUNCTIONS FOR NETWORK USAGE

	SEARCH	STENEX

	AC0=0
	AC1=1
	AC2=2
	AC3=3
	AC4=4
	AC5=5
	AC6=6
	AC7=7
	AC10=10
	AC11=11
	AC12=12
	AC13=13
	AC14=14
	AC15=15
	AC16=16
	AC17=17
	P=17


;ERROR CODES
NTGJX1=500001	;STACK OVERFLOW IN CALL TO NTGJFN
NTOPX1=500002	;TIMEOUT IN WAITING FOR RFC IN CALL OF NTOPNF


MLON

	INTERN	NTLBEG,NTLEND

NTLBEG:

INTERN	LBINIT

LBINIT:	SKIPN	HSTNSZ
	 PUSHJ	P,RDHNAM
	POPJ	P,

INTERN	NTGJFN,NTGJFE

NTGJFN:			;GETS A JFN FOR A NETWORK FILE.
			;AC2=(DIR NUM/0/-1),,(LOCAL SKT NUM/-1).
			;     -1 IN LH MEANS JOB REL
			;      0 IN LH MEANS LOCAL DIR REL
			;     >0 IN LH MEANS OTHER DIR REL
			;     -1 IN RH MEANS LOCAL SKT = 10*JFN
			;OR
			;AC2=(4NNNNN,,NNNNNN)
			;  WHERE NNNNNNNNNNN IS THE (32-BIT)
			;  ABSOLUTE LOCAL SKT NUMBER.
			;AC3=0,,HOST NUM -- OR -- BYTE PTR TO HOST NAME
			;    0 - NO REMOTE HOST/SOCKET - FOR LISTENING
			;AC4=FOREIGN SKT NUM.
			;RETURNS + 1 IF UNSUCCESSFUL WITH ERROR IN AC1
			;  "     + 2 IF SUCCESSFUL WITH JFN IN AC1

DEFINE	CHKPDL
<	JSA	AC13,PDLCHK
>


	PUSH	P,AC2
	PUSH	P,AC5
	PUSH	P,AC6
	PUSH	P,AC7
	PUSH	P,AC10
	PUSH	P,AC11
	PUSH	P,AC12
	PUSH	P,AC13
	PUSH	P,AC16

	HLRE	AC11,P	;GET (NEG.) REMAINING SIZE OF STACK
	HRROI	AC12,-5	;INIT CHAR COUNT
	AOJGE	AC11,PDLOVR	;WANT ONE WOD TO START.

	MOVE	AC5,NTNPTR
	MOVE	AC16,P	;SET UP TO USE STACK AS STRING STORAGE
	PUSH	P,		;BUMP P UP ONE
	MOVE	AC7,NETPRF
	ADDI	AC12,4
	MOVEM	AC7,1(AC16)
	HLRE	AC6,AC2
	JUMPLE	AC6,GJFN6
	HRRZI	AC10,"<"	;RELATIVE TO A SPECIFIED DIR.
	CHKPDL
	IDPB	AC10,AC5
	MOVE	AC1,[POINT 7,GJFBF]
	EXCH	AC2,AC6
	DIRST
	JRST	GJFN7

	HRRZ	AC10,AC1	;GET SIZE OF DIR STRING
	SUBI	AC10,GJFBF
	IMULI	AC10,5
	ROT	AC1,6
	ANDI	AC1,77
	SUBI	AC1,44
	MOVNS	AC1
	IDIVI	AC1,7
	ADD	AC1,AC10
	IDIVI	AC1,5	;GET WORD AND CHAR COUNTS
	ADD	AC12,AC2	;ADD IN CHAR COUNT
	JUMPL	AC12,.+4	;JUMP IF LESS THAN A WORD EXTRA
	AOJGE	AC11,PDLOVR	;ADD THE EXTRA WORD, JUMP IF ERROR.
	PUSH	P,		;BUMP P
	SUBI	AC12,5		;GET NEW CHAR COUNT

	ADD	AC11,AC1	;ADD IN WORD COUNT
	JUMPGE	AC11,PDLOVR	;JUMP IF WE ARE OVER.
	PUSH	P,		;BUMP P
	SOJG	AC1,.-1		;DO IT ONCE FOR EACH WORD.

	HLRZ	AC2,AC6
	MOVE	AC1,AC5
	DIRST		;GET DIR STRING FOR REAL
	JRST	GJFN7

	MOVE	AC5,AC1
	HRRZI	AC10,">"
	CHKPDL
	IDPB	AC10,AC5
	MOVE	AC2,AC6
GJFN6:	CAMG	AC2,[477777,,-1]
	 JRST	GJFN8
	HRRZ	AC6,AC2
	CAIN	AC6,-1
	JRST	GJFN5
	MOVE	AC6,B326	;3 DIGIT LOCAL SKT NUMBER
	ADDI	AC6,2
	HRRZI	AC7,3
	JSA	AC13,ADNUM
	JRST	GJFN5

GJFN8:	MOVE	AC6,B32		;ABSOLUTE SOCKET NUMBER
	ADDI	AC6,2
	HRRZI	AC7,13
	JSA	AC13,ADNUM
	HRRZI	AC10,"#"
	CHKPDL
	IDPB	AC10,AC5

GJFN5:	HRRZI	AC6,"."
	CHKPDL
	IDPB	AC6,AC5

	JUMPE	AC3,GJFN4

	HLRZ	AC1,AC3
	JUMPE	AC1,GJFN1

	HRLI	AC3,440700	;FOREIGN HOST NAME.
	JSA	AC13,ADSTR
	JRST	GJFN2

GJFN1:	HRRZI	AC7,6	;FOREIGN HOST NUMBER.
	MOVE	AC6,B3317
	JSA	AC13,ADNUM

GJFN2:	HRRZI	AC6,"-"
	CHKPDL
	IDPB	AC6,AC5

	MOVE	AC6,B32	;FOREIGN SOCKET NUMBER.
	ADDI	AC6,4
	HRRZI	AC7,13
	JSA	AC13,ADNUM

	HLRZ	AC6,AC2
	CAIE	AC6,-1
	JRST	GJFN4
	HRRZI	AC6,";"	;JOB RELATIVE.
	CHKPDL
	IDPB	AC6,AC5
	HRRZI	AC6,"T"
	CHKPDL
	IDPB	AC6,AC5

GJFN4:	SETZ	AC6,		;FINAL ZERO BYTE.
	CHKPDL
	IDPB	AC6,AC5

	MOVSI	AC1,100001
;KI CHANGE--THEY CANT HANDLE INDEXING OR INDIRECTION THRU PAGER
;;;	MOVE	AC2,[POINT 7,1(AC16)]
	;ADD 2 LINES
	MOVSI	AC2,(POINT 7,0)	;GET POINTER PART
	HRRI	AC2,1(AC16)	;CALC ADDRESS
	GTJFN		;FINALLY, GET THE JFN.
	JRST	GJFN3

	AOS	-11(16)

GJFN3:	MOVE	P,AC16
	POP	P,AC16
	POP	P,AC13
	POP	P,AC12
	POP	P,AC11
	POP	P,AC10
	POP	P,AC7
	POP	P,AC6
	POP	P,AC5
	POP	P,AC2

	POPJ	P,

GJFN7:	MOVEI	AC1,GJFX17
	JRST	GJFN3

B326:	POINT	3,0,26
B32:	POINT	3,0,2
B3317:	POINT	3,3,17

NTNPTR:	POINT	7,1(AC16),27
NETPRF:	ASCII	/NET:/
GJFBF:	BLOCK 10



ADNUM:	0
	ILDB	AC10,AC6
	JUMPN	AC10,.+4	;FOUND THE FIRST NON-ZERO DIGIT.
	 SOJG	AC7,ADNUM+1	;ALL ZEROS SO FAR.
	 JRST	.+2	;ONLY ZEROS, SEND ONE OUT.

ADNUM1:	ILDB	AC10,AC6
	ADDI	AC10,060
	AOJL	AC12,.+4
	AOJGE	AC11,PDLOVR
	HRROI	AC12,-5
	PUSH	P,
	IDPB	AC10,AC5
	SOJG	AC7,ADNUM1
	JRA	AC13,(AC13)	;RETURN

ADSTR:	0
	ILDB	AC10,AC3
	CAIN	AC10,0
	JRA	AC13,(AC13)
	AOJL	AC12,.+4
	AOJGE	AC11,PDLOVR
	HRROI	AC12,-5
	PUSH	P,
	IDPB	AC10,AC5
	JRST	ADSTR+1

PDLCHK:	0
	AOJL	AC12,.+4	;COUNT CHAR.
	AOJGE	AC11,PDLOVR	;COUNT WORD.
	HRROI	AC12,-5	;5 CHARS/WORD.
	PUSH	P,		;BUMP P
	JRA	AC13,(AC13)	;RETURN


PDLOVR:	MOVEI	AC1,NTGJX1
	JRST	GJFN3

	LIT
NTGJFE:	BLOCK	0

;ROUTINE TO OPEN A NETWORK CONNECTION - WILL TRY FOR A SPECIFIED
;TIME AND IF MATCHINF RFC IS NOT RECEIVED WILL FAIL
;ACCEPTS IN AC1 - JFN FOR CONNECTION
;ACCEPTS IN AC2 - SUITABLE VALUE FOR AC2 IN OPENF
;ACCEPTS IN AC3 - TIME IN MS TO WAIT FOR RFC
;ACCEPTS IN AC4 - POLLING TIME
;RETURNS + 1 - IF CAN'T DO IT WITH ERROR CODE IN AC1
;RETURNS + 2 - IF OPEN SUCCEEDS


INTERN	NTOPNF,NTOPNE

	OPND=7

NTOPNF:	PUSH	P,AC5
	PUSH	P,AC4
	PUSH	P,AC3
	PUSH	P,AC2
	PUSH	P,AC1

	CAMG	AC3,AC4			;IS WAIT TIME > POLL TIME?
	MOVE	AC4,AC3			;NO - SET POLL TIME = WAIT TIME

	SETZ	AC5,			;U&E AC5 TO ACCUM. WAIT TIME

	TLO	AC2,3000		;DO IMMEDITATE RETURN
	OPENF
	JRST	[ POP P,
		  JRST NTOPN5 ]
	JRST	NTOPN0

NTOPN1:	MOVE	AC1,-2(P)
	SUB	AC1,AC5			;AC1=REMAINING TIME TO WAIT
	CAMLE	AC1,-3(P)		;GREATER THAN POLLING TIME?
	MOVE	AC1,-3(P)		;YES - DISMIS FOR POLLING TIME
	DISMS
	ADD	AC5,AC1			;INCR TOTAL WAIT TIME
	CAML	AC5,-2(P)		;WAITED LONG ENOUGH?
	JRST	NTOPN4			;YES - FINISH UP
	MOVE	AC1,0(P)
NTOPN0:	GDSTS				;FILE OPEN YET?
	LSH	AC2,-40
	CAIE	AC2,OPND
	JRST	NTOPN1			;NO, DISMIS AGAIN

NTOPN2:	AOS	-5(P)			;SUCCESSFUL OPEN
NTOPN3:	POP	P,AC1
NTOPN5:	POP	P,AC2
	POP	P,AC3
	POP	P,AC4
	POP	P,AC5
	POPJ	P,

NTOPN4:	POP	P,AC1
	HRLI	AC1,400000
	CLOSF
	JRST	.+1
	MOVEI	AC1,NTOPX1
	JRST	NTOPN5
	LIT
NTOPNE:	BLOCK	0

;ROUTINE TO GO THROUGH LOGGER PROTOCOL
;ACCEPTS IN AC2 A LOCAL SOCKET NUMBER - MUST BE EVEN
;          AC3 A HOST NUMBER OR A STRING POINTER TO A HOST NAME
;RETURNS +1 IF UNSUCCESSFUL WITH ERROR NUMBER IN RH AC1
;	AND LH AC1=1 IF ERROR WAS WITH LOGGER CONNECTION
;	AND LH AC1=2 IF ERROR WAS WITH SEND OR RECV CONNECTION
;RETURNS +2 WITH AC1 = SEND JFN,,RECV JFN  IF SUCCESSFUL
;THE SEND AND RECEIVE CONNECTIONS ARE OPENED.


	INTERN	LGRINT,LGRINE

LGRINT:
	PUSH	P,AC4
	HRRZI	AC4,1


LGRIN1:	PUSH	P,AC7	;ENTRY FOR ICP WITH FOREIGN SOCKET # IN AC4
	PUSH	P,AC10
	PUSH	P,AC11
	PUSH	P,AC12
	PUSH	P,AC13
	PUSH	P,AC14
	PUSH	P,AC15

	MOVEM	AC3,SITPTR		;SAVE PTR TO REMOTE HOST
	MOVEM	AC2,USRSKT		;SAVE USER SOCKET NUMBER
	SUBI	AC2,2			;FORM SKT NUMBER FOR LOGGER

	PUSHJ	P,NTGJFN		;GET JFN FOR LOGGER
	JRST	LGRER1
	MOVEM	AC1,LGRJFN		;SAVE IT.

					;OPEN LOGGER CONNECTION
	HRRI	AC2,200000		;READ OPEN
	HRLI	AC2,400000		;32 BIT BYTE
	OPENF
	PUSHJ	P,LGRER2

	BIN				;READ SOCKET NUMBER FOR LOGGER
	MOVEM	AC2,SNDSKT
	AOJ	AC2,
	MOVEM	AC2,RCVSKT

	CLOSF				;CLOSE LOGGER CONNECTION
	PUSHJ	P,LGRER3

	MOVE	AC2,USRSKT
	MOVE	AC3,SITPTR
	MOVE	AC4,SNDSKT
	PUSHJ	P,NTGJFN		;GET JFN FOR PRIMARY INPUT
	JRST	LGRER4
	MOVEM	AC1,SNDJFN		;SAVE IT

	HRRZ	AC1,SNDJFN
	HRRI	AC2,100000		;WRITE OPEN
	HRLI	AC2,100000		;7 BIT BYTES
	OPENF
	JRST	LGRER5

	MOVE	AC2,USRSKT
	MOVE	AC3,SITPTR
	MOVE	AC4,RCVSKT
	PUSHJ	P,NTGJFN		;GET JFN FOR PRIMARY OUTPUT
	JRST	LGRER6
	MOVEM	AC1,RCVJFN		;SAVE IT

	HRRZ	AC1,RCVJFN
	HRRI	AC2,200000		;READ OPEN
	HRLI	AC2,100000		;7 BIT BYTES
	OPENF
	JRST	LGRER7

	HRR	AC1,RCVJFN
	HRL	AC1,SNDJFN
	AOS	-10(P)
LGRRET:	POP	P,AC15
	POP	P,AC14
	POP	P,AC13
	POP	P,AC12
	POP	P,AC11
	POP	P,AC10
	POP	P,AC7
	POP	P,AC4
	POPJ	P,			;RETURN

LGRER1:	HRLI	AC1,1			;CAN'T GET JFN ERROR
	JRST	LGRRET			;GIVE UP

LGRER2:	CAIN	AC1,OPNX9		;LOGGER SKT BUSY?
	JRST	LGRE2A			;YES
	POP	P,
	MOVE	AC7,AC1	;SAVE ERROR CODE
	HRRZ	AC1,LGRJFN
	RLJFN
	JRST	.+1
	HRRZ	AC1,AC7
	HRLI	AC1,1
	JRST	LGRRET

LGRE2A:	MOVEI	AC1,^D1000		;WAIT 1 SEC AND TRY AGAIN
	DISMS
	POP	P,AC3
	HRLI	AC3,0
	JRST	-4(AC3)

LGRER3:	CAIN	AC1,CLSX1		;CAN'T CLOSE FILE
	POPJ	P,			;ALREADY CLOSED - JUST RETURN
	HRLI	AC1,1
	POP	P,
	JRST	LGRRET

LGRER4:	HRLI	AC1,2
	JRST	LGRRET

	LGRER5=LGRER4

	LGRER6=LGRER4

	LGRER7=LGRER4

SITPTR=AC7
USRSKT=AC10

SNDSKT=AC11
RCVSKT=AC12

LGRJFN=AC13
SNDJFN=AC14
RCVJFN=AC15

LGRINE:	BLOCK	0



;ROUTINE TO GO THROUGH ICP WITH ARBITRARY CONNECTION
;ACCEPTS ARGUMENTS AS FOR LGRINT
;EXCEPT ACCEPTS IN AC4 A FOREIGN SOCKET NUMBER TO WHICH
;   THE ICP IS TO GO.
;
;RETURNS AS FOR LGRINT

	INTERN	DOICP,DOICPE

DOICP:	PUSH	P,AC4
	JRST	LGRIN1

DOICPE:	BLOCK	0


;ROUTINE TO MAP PAGES FROM THE CURRENT FORK INTO A LOWER ONE.
;PAGE N IS MAPPED INTO PAGE N.
;ACCEPTS IN AC1 THE HANDLE OF THE LOWER FORK
;           AC2 BEGINNING ADDRESS,,END ADDRESS
;           AC3 ACCESS OR 0 FOR READ,WRITE,EXECUTE

	INTERN	MAPPGS,MAPPGE

MAPPGS:	PUSH	P,AC1
	PUSH	P,AC4
	PUSH	P,AC5
	HLRZ	AC4,AC2
	HRRZ	AC5,AC2
	LSH	AC4,-11
	LSH	AC5,-11
	SUB	AC5,AC4			;AC5_(#PAGES TO BE MAPPED)-1
	HRL	AC2,AC1
	HRLI	AC1,400000
	JUMPN	AC3,MAPGS1
	HRLZI	AC3,160000

MAPGS1:	HRR	AC1,AC4
	HRR	AC2,AC4
	PMAP
	AOJ	AC4,
	SOJGE	AC5,MAPGS1

	POP	P,AC5
	POP	P,AC4
	POP	P,AC1

	POPJ	P,

MAPPGE:	BLOCK	0

;ROUTINE TO LOG INTO ANOTHER TENEX ON THE NETWORK
;ACCEPTS IN AC1 (JFN FOR PRIM INPUT,,JFN FOR PRIM OUTPUT) FOR FOR. HOST
;           AC2 STRING POINTER TO USER NAME
;           AC3 STRING POINTER TO PASSWORD
;           AC4 STRING POINTER TO ACCOUNT NUMBER
;RETURNS +1 IF UNSUCCESSFUL
;RETURNS +2 IF SUCCESSFUL WITH JOB NUMBER IN AC1

	INTERN	NLOGIN,NLOGIE

NLOGIN:	PUSH	P,AC5
	PUSH	P,AC6
	PUSH	P,AC7

	MOVE	AC5,AC1
	MOVE	AC6,AC2
	MOVE	AC7,AC3

	SETZ	AC2,			;READ TO "@"
	HRRZ	AC1,AC5
	BIN
	CAIE	AC2,"@"
	JRST	.-2

	HLRZ	AC1,AC5			;SEND LOGIN TEXT
	HRROI	AC2,NLOGM1
	SETZ	AC3,
	SOUT
	MOVE	AC2,AC6			;SEND USER NAME
	SOUT
	HRRZI	AC2," "
	BOUT
	MOVE	AC2,AC7			;SEND PASSWORD
	SOUT
	HRROI	AC2,NLOGM2
	SOUT
	MOVE	AC2,AC4			;SEND ACCOUNT NUMBER
	SOUT
	HRROI	AC2,NLOGM2
	SOUT
	HRRZI	AC1,^D1000
	DISMS
	HLRZ	AC1,AC5
	HRRZI	AC2,37
	BOUT				;SEND EXTRA CR FOR SRI-ARC

	HRRZ	AC1,AC5			;READ RESPONSE FROM FOR. HOST
NLOG1:	BIN
	CAIN	AC2,"J"
	JRST	NLOG2
	CAIN	AC2,"?"
	JRST	NLOG3
	CAIN	AC2,"@"
	JRST	NLOGRT
	CAIN	AC2,0
	JRST	NLOGRT
	JRST	NLOG1

NLOG2:	BIN
	CAIE	AC2,"O"
	JRST	NLOG3
	BIN
	CAIE	AC2,"B"
	JRST	NLOG3
	BIN
	CAIN	AC2," "
	JRST	.-2

	SETZ	AC3,			;READ THE JOB NUMBER
	CAIA
NLOG5:	BIN
	SUBI	AC2,060
	CAIGE	AC2,0
	JRST	NLOG6
	CAILE	AC2,11
	JRST	NLOG6
	IMULI	AC3,^D10
	ADD	AC3,AC2
	JRST	NLOG5

NLOG6:	AOS	,-3(P)

NLOG3:	BIN
	CAIE	AC2,"@"
	JRST	.-2
	MOVE	AC1,AC3

NLOGRT:	POP	P,AC7
	POP	P,AC6
	POP	P,AC5
	POPJ	P,

NLOGM1:	ASCIZ	/LOG /
NLOGM2:	ASCIZ	/
/

NLOGIE:BLOCK	0

;ROUTINE TO DETERMINE WHICH TENEX IN NET PROGRAM IS RUNNING ON.
;RETURNS + 1 IF CAN'T DETERMINE THE TENEX
;RETURNS + 2 WITH NET ADDRESS OF TENEX IN AC1 IF CAN DETERMINE.

	INTERN	NTSITE,NTSTEE

NTSITE:	PUSH	P,AC2
	MOVE	AC1,[SIXBIT /LHOSTN/]
	SYSGT
	SKIPE	AC2	;SKIP IF NO NAME.
	 AOS	-1(P)
	POP	P,AC2
	POPJ	P,

	LIT

NTSTEE:	BLOCK	0

;ROUTINE TO CONVERT A STRING INTO A HOST NUMBER (I.E. NET ADDRESS)
;ACCEPTS IN AC2 A STRING POINTER
;RETURNS +1 IF STRING DOES NOT DESIGNATE A HOST
;        +2 IF IT DESIGNATES A HOST WITH THE HOST NUMBER IN AC1

	INTERN	STRHST,STRHSE,HSTNAM,HOSTN,RDHNAM,HSTNSZ

STRHST:	PUSH	P,AC3
	PUSH	P,AC4
	PUSH	P,AC5
	PUSH	P,AC6
	MOVE	AC4,AC2
	SKIPN	HSTNSZ	;ONLY READ IN TABLES ONCE
	 PUSHJ	P,RDHNAM
	HRLZ	AC1,HSTNSZ

SHMLP:	MOVE	AC2,AC4	;GET PTR TO GIVEN NAME
	HRRZ	AC3,HOSTN(AC1)	;AND TO COMPARISON HOST NAME
	ADD	AC3,[440700,,HSTNAM]

SHCLP:	ILDB	AC5,AC3
	ILDB	AC6,AC2
	CAMN	AC5,AC6
	JRST	.+3	;THESE CHARS ARE THE SAME.
	AOBJN	AC1,SHMLP	;NOT THE SAME, GET NEXT HOST NAME.
	JRST	.+5	;NOT FOUND.

	JUMPN	AC5,SHCLP	;IF NOT 0 THEN CONTINUE COMPARISON.
	HLRZ	AC1,HOSTN(AC1)	;MATCH.  RETURN  HOST NUM.
	ANDI	AC1,777
	AOS	-4(P)
	POP	P,AC6
	POP	P,AC5
	POP	P,AC4
	POP	P,AC3
	POPJ	P,


;ROUTINE TO CONVERT A HOST NUMBER INTO A HOST SNAME
;ACCEPTS IN AC2 A HOST NUMBER
;RETURNS +1 IF NOT A KNOWN HOST NUMBER
;        +2 IF SUCCESSFUL WITH STRING PTR IN AC1

	INTERN	HSTSTR,HSTSTE

HSTSTR:	PUSH	P,AC3
	SKIPN	HSTNSZ	;CHECK IF TABLES ARE IN.
	 PUSHJ	P,RDHNAM	;NO. GO GET THEM.
	HRLZ	AC3,HSTNSZ
	HLRZ	AC1,HOSTN(AC3)
	ANDI	AC1,777	;GET HOST NUM.
	CAMN	AC2,AC1
	 JRST	.+3
	AOBJN	AC3,.-4
	 JRST	HSSTRT

	HRRZ	AC1,HOSTN(AC3)	;POINTER TO NAME
	ADD	AC1,[440700,,HSTNAM]
	AOS	-1(P)
HSSTRT:	POP	P,AC3
	POPJ	P,


; ROUTINE TO RETURN THE HOSTN ENTRY FOR A GIVEN HOST NUMBER.
;ACCEPTS IN AC2 A HOST NUMBER.
;RETURNS +1 IF NOT A KNOWN HOST NUMBER.
;	 +2 IF SUCCESSFUL WITH ENTRY FROM HOSTN IN AC1.
;THE FORMAT OF THE ENTRY IS:
; BITS	0-3	SERVER/USER (BIT 0=>SERVER, BIT 1=>USER, BIT3=>NICKNAME)
; BITS	6-8	HOST TYPE (1-TENEX, 2-ITS, 3-DIC10, 4-TIP, 5-MTIP)
; BITS	9-17	HOST NUMBER.
; BITS	18-36	ADDRESS OF NAME STRING.
; IF BITS 0-8 ARE ZERO THEN THE HOST IS "NONEXISTENT" (IE. NOT ON NET)

	INTERN	HSTINF,HSTINE

HSTINF:	PUSH	P,AC3
	SKIPN	HSTNSZ			;CHECK IF TABLES ARE IN.
	 PUSHJ	P,RDHNAM		;NO.  GO GET THEM.
	HRLZ	AC3,HSTNSZ
	HLRZ	AC1,HOSTN(AC3)
	ANDI	AC1,777			;GET HOST NUMBER.
	CAMN	AC2,AC1
	 JRST	.+3
	AOBJN	AC3,.-4
	 JRST	HSTIRT

	MOVE	AC1,HOSTN(AC3)		;GET ENTRY
	ADDI	AC1,HSTNAM		;ADJUST NAME POINTER.
	AOS	-1(P)
HSTIRT:	POP	P,AC3
	POPJ	P,


; GET HOST NAME TABLES.
RDHNAM:	PUSH	P,AC1
	PUSH	P,AC2
	PUSH	P,AC3
	MOVE	AC1,[SIXBIT /HOSTN/]
	MOVE	AC3,[XWD -HSTNS,HOSTN]
	PUSHJ	P,READTB
	MOVNM	AC2,HSTNSZ
	MOVE	AC1,[SIXBIT /HSTNAM/]
	MOVE	AC3,[XWD -HSTNMS,HSTNAM]
	PUSHJ	P,READTB
	POP	P,AC3
	POP	P,AC2
	POP	P,AC1
	POPJ	P,


;SUBROUTINE TO READ IN SYSTEM TABLES
;ACCEPTS:	IN 1	SIXBIT NAME OF TABLE
;		IN 3 RH: STARTING ADDRESS OF LOCAL TABLE AREA
;		     LH: -(MAX SIZE OF LOCAL TABLE AREA)
;
;RETURNS: +1 WITH NUMBER OF ENTRIES IN 2
;
READTB:	PUSH	P,AC4
	SYSGT
	MOVE	AC4,AC3
	HLL	AC3,AC2
	CAMLE	AC4,AC3
	 HALTF	;TABLE IS TOO BIG.
	HRLZS	AC2
REDTBL:	MOVS	AC1,AC2
	GETAB
	0
	MOVEM	AC1,(AC3)
	AOS	AC2
	AOBJN	AC3,REDTBL
	HRRZS	AC2
	POP	P,AC4
	POPJ	P,

	LIT

HSTNSZ:	0	;ACTUAL SIZE OF HOSTN TABLE

HSTNS=200		;MAX SIZE FOR HOSTN TABLE
HSTNMS=HSTNS*2		;MAX SIZE FOR HSTNAM TABLE

HOSTN:	BLOCK	HSTNS
HSTNAM:	BLOCK	HSTNMS

STRHSE:	BLOCK 	0
HSTSTE:	BLOCK	0
HSTINE:	BLOCK	0

NTLEND:	BLOCK	0

END
